/**
 * Generated by orval v8.1.0 üç∫
 * Do not edit manually.
 * WAHA - WhatsApp HTTP API
 * <b>WhatsApp HTTP API</b> that you can run in a click!<br/><a href="/dashboard"><b>üìä Dashboard</b></a><br/><br/>Learn more:<ul><li><a href="https://waha.devlike.pro/" target="_blank">Documentation</a></li><li><a href="https://waha.devlike.pro/docs/how-to/engines/#features" target="_blank">Supported features in engines</a></li><li><a href="https://github.com/devlikeapro/waha" target="_blank">GitHub - WAHA Core</a></li><li><a href="https://github.com/devlikeapro/waha-plus" target="_blank">GitHub - WAHA Plus</a></li></ul><p>Support the project and get WAHA Plus version!</p><ul><li><a href="https://waha.devlike.pro/docs/how-to/plus-version/" target="_blank">WAHA Plus</a></li><li><a href="https://patreon.com/wa_http_api/" target="_blank">Patreon</a></li><li><a href="https://boosty.to/wa-http-api/" target="_blank">Boosty</a></li><li><a href="https://portal.devlike.pro/" target="_blank">Patron Portal</a></li></ul>
 * OpenAPI spec version: 2026.1.5
 */
import { useMutation, useQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
} from "@tanstack/react-query";

import type {
	ApiKeyDTO,
	ApiKeyRequest,
	App,
	AppsControllerListParams,
	AuthControllerGetQRParams,
	Base64File,
	Channel,
	ChannelCategory,
	ChannelCountry,
	ChannelListResult,
	ChannelMessage,
	ChannelSearchByText,
	ChannelSearchByView,
	ChannelView,
	ChannelsControllerListParams,
	ChannelsControllerPreviewChannelMessagesParams,
	ChatPictureResponse,
	ChatRequest,
	ChatSummary,
	ChatsControllerArchiveChat201,
	ChatsControllerGetChatMessageParams,
	ChatsControllerGetChatMessagesParams,
	ChatsControllerGetChatPictureParams,
	ChatsControllerGetChatsOverviewParams,
	ChatsControllerGetChatsParams,
	ChatsControllerReadChatMessagesParams,
	ChatsControllerUnarchiveChat201,
	ChatsControllerUnreadChat201,
	ChattingControllerDEPRECATEDCheckNumberStatusParams,
	ChattingControllerGetMessagesParams,
	ChattingControllerReply201,
	ChattingControllerSendFile201,
	ChattingControllerSendImage201,
	ChattingControllerSendLinkCustomPreview201,
	ChattingControllerSendList201,
	ChattingControllerSendLocation201,
	ChattingControllerSendSeen201,
	ChattingControllerSendTextGet200,
	ChattingControllerSendTextGetParams,
	ChattingControllerSendVoice201,
	ChattingControllerSetReaction200,
	ChatwootLocalesControllerGetLanguages200Item,
	ContactRequest,
	ContactUpdateBody,
	ContactsControllerCheckExistsParams,
	ContactsControllerGetAboutParams,
	ContactsControllerGetAllParams,
	ContactsControllerGetParams,
	ContactsControllerGetProfilePictureParams,
	CountResponse,
	CreateChannelRequest,
	CreateGroupRequest,
	DeleteStatusRequest,
	DescriptionRequest,
	EditMessageRequest,
	EventMessageRequest,
	GroupParticipant,
	GroupsControllerGetChatPictureParams,
	GroupsControllerGetGroups200,
	GroupsControllerGetGroupsParams,
	GroupsControllerJoinInfoGroup200,
	GroupsControllerJoinInfoGroupParams,
	HealthControllerCheck200,
	HealthControllerCheck503,
	ImageStatus,
	JoinGroupRequest,
	JoinGroupResponse,
	Label,
	LabelBody,
	LabelsControllerDelete200,
	LidToPhoneNumber,
	LidsControllerGetAllParams,
	MeInfo,
	MessageButtonReply,
	MessageContactVcardRequest,
	MessageFileRequest,
	MessageForwardRequest,
	MessageImageRequest,
	MessageLinkCustomPreviewRequest,
	MessageLinkPreviewRequest,
	MessageLocationRequest,
	MessagePollRequest,
	MessagePollVoteRequest,
	MessageReactionRequest,
	MessageReplyRequest,
	MessageStarRequest,
	MessageTextRequest,
	MessageVideoRequest,
	MessageVoiceRequest,
	MyProfile,
	NewMessageIDResponse,
	OverviewBodyRequest,
	ParticipantsRequest,
	PinMessageRequest,
	PingResponse,
	ProfileNameRequest,
	ProfilePictureRequest,
	ProfileStatusRequest,
	QRCodeValue,
	ReadChatMessagesResponse,
	RejectCallRequest,
	RequestCodeRequest,
	Result,
	ScreenshotControllerScreenshotParams,
	SendButtonsRequest,
	SendListRequest,
	SendSeenRequest,
	ServerControllerEnvironment200,
	ServerControllerEnvironmentParams,
	ServerDebugControllerBrowserTraceParams,
	ServerDebugControllerCpuProfileParams,
	ServerStatusResponse,
	SessionCreateRequest,
	SessionDTO,
	SessionInfo,
	SessionLogoutDeprecatedRequest,
	SessionStartDeprecatedRequest,
	SessionStopDeprecatedRequest,
	SessionUpdateRequest,
	SessionsControllerGetParams,
	SessionsControllerListParams,
	SetLabelsRequest,
	SettingsSecurityChangeInfo,
	StopRequest,
	StopResponse,
	SubjectRequest,
	TextStatus,
	VideoFileDTO,
	VideoStatus,
	VoiceFileDTO,
	VoiceStatus,
	WAHAChatPresences,
	WAHAEnvironment,
	WAHASessionPresence,
	WAMessage,
	WANumberExistResult,
} from "./models";

/**
 * @summary Get QR code for pairing WhatsApp API.
 */
export type authControllerGetQRResponse200ImagePng = {
	data: Blob;
	status: 200;
};

export type authControllerGetQRResponse200ApplicationJson = {
	data: Base64File | QRCodeValue;
	status: 200;
};

export type authControllerGetQRResponseSuccess = (
	| authControllerGetQRResponse200ImagePng
	| authControllerGetQRResponse200ApplicationJson
) & {
	headers: Headers;
};

export type authControllerGetQRResponse = authControllerGetQRResponseSuccess;

export const getAuthControllerGetQRUrl = (
	params: AuthControllerGetQRParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/auth/qr?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/auth/qr`;
};

export const authControllerGetQR = async (
	params: AuthControllerGetQRParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<authControllerGetQRResponse> => {
	const res = await fetch(getAuthControllerGetQRUrl(params, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: authControllerGetQRResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as authControllerGetQRResponse;
};

export const getAuthControllerGetQRQueryKey = (
	params?: AuthControllerGetQRParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/auth/qr`,
		...(params ? [params] : []),
	] as const;
};

export const getAuthControllerGetQRQueryOptions = <
	TData = Awaited<ReturnType<typeof authControllerGetQR>>,
	TError = unknown,
>(
	params: AuthControllerGetQRParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authControllerGetQR>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getAuthControllerGetQRQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof authControllerGetQR>>
	> = ({ signal }) =>
		authControllerGetQR(params, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof authControllerGetQR>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AuthControllerGetQRQueryResult = NonNullable<
	Awaited<ReturnType<typeof authControllerGetQR>>
>;
export type AuthControllerGetQRQueryError = unknown;

export function useAuthControllerGetQR<
	TData = Awaited<ReturnType<typeof authControllerGetQR>>,
	TError = unknown,
>(
	params: AuthControllerGetQRParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authControllerGetQR>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof authControllerGetQR>>,
					TError,
					Awaited<ReturnType<typeof authControllerGetQR>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthControllerGetQR<
	TData = Awaited<ReturnType<typeof authControllerGetQR>>,
	TError = unknown,
>(
	params: AuthControllerGetQRParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authControllerGetQR>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof authControllerGetQR>>,
					TError,
					Awaited<ReturnType<typeof authControllerGetQR>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAuthControllerGetQR<
	TData = Awaited<ReturnType<typeof authControllerGetQR>>,
	TError = unknown,
>(
	params: AuthControllerGetQRParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authControllerGetQR>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get QR code for pairing WhatsApp API.
 */

export function useAuthControllerGetQR<
	TData = Awaited<ReturnType<typeof authControllerGetQR>>,
	TError = unknown,
>(
	params: AuthControllerGetQRParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof authControllerGetQR>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getAuthControllerGetQRQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Request authentication code.
 */
export type authControllerRequestCodeResponse201 = {
	data: void;
	status: 201;
};

export type authControllerRequestCodeResponseSuccess =
	authControllerRequestCodeResponse201 & {
		headers: Headers;
	};

export type authControllerRequestCodeResponse =
	authControllerRequestCodeResponseSuccess;

export const getAuthControllerRequestCodeUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/auth/request-code`;
};

export const authControllerRequestCode = async (
	requestCodeRequest: RequestCodeRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<authControllerRequestCodeResponse> => {
	const res = await fetch(getAuthControllerRequestCodeUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(requestCodeRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: authControllerRequestCodeResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as authControllerRequestCodeResponse;
};

export const getAuthControllerRequestCodeMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof authControllerRequestCode>>,
		TError,
		{ data: RequestCodeRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof authControllerRequestCode>>,
	TError,
	{ data: RequestCodeRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["authControllerRequestCode"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof authControllerRequestCode>>,
		{ data: RequestCodeRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return authControllerRequestCode(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AuthControllerRequestCodeMutationResult = NonNullable<
	Awaited<ReturnType<typeof authControllerRequestCode>>
>;
export type AuthControllerRequestCodeMutationBody = RequestCodeRequest;
export type AuthControllerRequestCodeMutationError = unknown;

/**
 * @summary Request authentication code.
 */
export const useAuthControllerRequestCode = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof authControllerRequestCode>>,
			TError,
			{ data: RequestCodeRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof authControllerRequestCode>>,
	TError,
	{ data: RequestCodeRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getAuthControllerRequestCodeMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Create a new API key
 */
export type apiKeysControllerCreateResponse201 = {
	data: ApiKeyDTO;
	status: 201;
};

export type apiKeysControllerCreateResponseSuccess =
	apiKeysControllerCreateResponse201 & {
		headers: Headers;
	};

export type apiKeysControllerCreateResponse =
	apiKeysControllerCreateResponseSuccess;

export const getApiKeysControllerCreateUrl = () => {
	return `https://waha.gnardawgs.surf/api/keys`;
};

export const apiKeysControllerCreate = async (
	apiKeyRequest: ApiKeyRequest,
	options?: RequestInit,
): Promise<apiKeysControllerCreateResponse> => {
	const res = await fetch(getApiKeysControllerCreateUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(apiKeyRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: apiKeysControllerCreateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as apiKeysControllerCreateResponse;
};

export const getApiKeysControllerCreateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof apiKeysControllerCreate>>,
		TError,
		{ data: ApiKeyRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof apiKeysControllerCreate>>,
	TError,
	{ data: ApiKeyRequest },
	TContext
> => {
	const mutationKey = ["apiKeysControllerCreate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof apiKeysControllerCreate>>,
		{ data: ApiKeyRequest }
	> = (props) => {
		const { data } = props ?? {};

		return apiKeysControllerCreate(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ApiKeysControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof apiKeysControllerCreate>>
>;
export type ApiKeysControllerCreateMutationBody = ApiKeyRequest;
export type ApiKeysControllerCreateMutationError = unknown;

/**
 * @summary Create a new API key
 */
export const useApiKeysControllerCreate = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof apiKeysControllerCreate>>,
			TError,
			{ data: ApiKeyRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof apiKeysControllerCreate>>,
	TError,
	{ data: ApiKeyRequest },
	TContext
> => {
	return useMutation(
		getApiKeysControllerCreateMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get all API keys
 */
export type apiKeysControllerListResponse200 = {
	data: ApiKeyDTO[];
	status: 200;
};

export type apiKeysControllerListResponseSuccess =
	apiKeysControllerListResponse200 & {
		headers: Headers;
	};

export type apiKeysControllerListResponse =
	apiKeysControllerListResponseSuccess;

export const getApiKeysControllerListUrl = () => {
	return `https://waha.gnardawgs.surf/api/keys`;
};

export const apiKeysControllerList = async (
	options?: RequestInit,
): Promise<apiKeysControllerListResponse> => {
	const res = await fetch(getApiKeysControllerListUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: apiKeysControllerListResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as apiKeysControllerListResponse;
};

export const getApiKeysControllerListQueryKey = () => {
	return [`https://waha.gnardawgs.surf/api/keys`] as const;
};

export const getApiKeysControllerListQueryOptions = <
	TData = Awaited<ReturnType<typeof apiKeysControllerList>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof apiKeysControllerList>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getApiKeysControllerListQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof apiKeysControllerList>>
	> = ({ signal }) => apiKeysControllerList({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof apiKeysControllerList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ApiKeysControllerListQueryResult = NonNullable<
	Awaited<ReturnType<typeof apiKeysControllerList>>
>;
export type ApiKeysControllerListQueryError = unknown;

export function useApiKeysControllerList<
	TData = Awaited<ReturnType<typeof apiKeysControllerList>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof apiKeysControllerList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof apiKeysControllerList>>,
					TError,
					Awaited<ReturnType<typeof apiKeysControllerList>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiKeysControllerList<
	TData = Awaited<ReturnType<typeof apiKeysControllerList>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof apiKeysControllerList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof apiKeysControllerList>>,
					TError,
					Awaited<ReturnType<typeof apiKeysControllerList>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useApiKeysControllerList<
	TData = Awaited<ReturnType<typeof apiKeysControllerList>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof apiKeysControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all API keys
 */

export function useApiKeysControllerList<
	TData = Awaited<ReturnType<typeof apiKeysControllerList>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof apiKeysControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getApiKeysControllerListQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Update an API key
 */
export type apiKeysControllerUpdateResponse200 = {
	data: ApiKeyDTO;
	status: 200;
};

export type apiKeysControllerUpdateResponseSuccess =
	apiKeysControllerUpdateResponse200 & {
		headers: Headers;
	};

export type apiKeysControllerUpdateResponse =
	apiKeysControllerUpdateResponseSuccess;

export const getApiKeysControllerUpdateUrl = (id: string) => {
	return `https://waha.gnardawgs.surf/api/keys/${id}`;
};

export const apiKeysControllerUpdate = async (
	id: string,
	apiKeyRequest: ApiKeyRequest,
	options?: RequestInit,
): Promise<apiKeysControllerUpdateResponse> => {
	const res = await fetch(getApiKeysControllerUpdateUrl(id), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(apiKeyRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: apiKeysControllerUpdateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as apiKeysControllerUpdateResponse;
};

export const getApiKeysControllerUpdateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
		TError,
		{ id: string; data: ApiKeyRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
	TError,
	{ id: string; data: ApiKeyRequest },
	TContext
> => {
	const mutationKey = ["apiKeysControllerUpdate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
		{ id: string; data: ApiKeyRequest }
	> = (props) => {
		const { id, data } = props ?? {};

		return apiKeysControllerUpdate(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ApiKeysControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof apiKeysControllerUpdate>>
>;
export type ApiKeysControllerUpdateMutationBody = ApiKeyRequest;
export type ApiKeysControllerUpdateMutationError = unknown;

/**
 * @summary Update an API key
 */
export const useApiKeysControllerUpdate = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
			TError,
			{ id: string; data: ApiKeyRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof apiKeysControllerUpdate>>,
	TError,
	{ id: string; data: ApiKeyRequest },
	TContext
> => {
	return useMutation(
		getApiKeysControllerUpdateMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Delete an API key
 */
export type apiKeysControllerDeleteResponse200 = {
	data: void;
	status: 200;
};

export type apiKeysControllerDeleteResponseSuccess =
	apiKeysControllerDeleteResponse200 & {
		headers: Headers;
	};

export type apiKeysControllerDeleteResponse =
	apiKeysControllerDeleteResponseSuccess;

export const getApiKeysControllerDeleteUrl = (id: string) => {
	return `https://waha.gnardawgs.surf/api/keys/${id}`;
};

export const apiKeysControllerDelete = async (
	id: string,
	options?: RequestInit,
): Promise<apiKeysControllerDeleteResponse> => {
	const res = await fetch(getApiKeysControllerDeleteUrl(id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: apiKeysControllerDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as apiKeysControllerDeleteResponse;
};

export const getApiKeysControllerDeleteMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof apiKeysControllerDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof apiKeysControllerDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["apiKeysControllerDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof apiKeysControllerDelete>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return apiKeysControllerDelete(id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ApiKeysControllerDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof apiKeysControllerDelete>>
>;

export type ApiKeysControllerDeleteMutationError = unknown;

/**
 * @summary Delete an API key
 */
export const useApiKeysControllerDelete = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof apiKeysControllerDelete>>,
			TError,
			{ id: string },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof apiKeysControllerDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	return useMutation(
		getApiKeysControllerDeleteMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary List all sessions
 */
export type sessionsControllerListResponse200 = {
	data: SessionInfo[];
	status: 200;
};

export type sessionsControllerListResponseSuccess =
	sessionsControllerListResponse200 & {
		headers: Headers;
	};

export type sessionsControllerListResponse =
	sessionsControllerListResponseSuccess;

export const getSessionsControllerListUrl = (
	params?: SessionsControllerListParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/sessions?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/sessions`;
};

export const sessionsControllerList = async (
	params?: SessionsControllerListParams,
	options?: RequestInit,
): Promise<sessionsControllerListResponse> => {
	const res = await fetch(getSessionsControllerListUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerListResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerListResponse;
};

export const getSessionsControllerListQueryKey = (
	params?: SessionsControllerListParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/sessions`,
		...(params ? [params] : []),
	] as const;
};

export const getSessionsControllerListQueryOptions = <
	TData = Awaited<ReturnType<typeof sessionsControllerList>>,
	TError = unknown,
>(
	params?: SessionsControllerListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getSessionsControllerListQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof sessionsControllerList>>
	> = ({ signal }) =>
		sessionsControllerList(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof sessionsControllerList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SessionsControllerListQueryResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerList>>
>;
export type SessionsControllerListQueryError = unknown;

export function useSessionsControllerList<
	TData = Awaited<ReturnType<typeof sessionsControllerList>>,
	TError = unknown,
>(
	params: undefined | SessionsControllerListParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof sessionsControllerList>>,
					TError,
					Awaited<ReturnType<typeof sessionsControllerList>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSessionsControllerList<
	TData = Awaited<ReturnType<typeof sessionsControllerList>>,
	TError = unknown,
>(
	params?: SessionsControllerListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof sessionsControllerList>>,
					TError,
					Awaited<ReturnType<typeof sessionsControllerList>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSessionsControllerList<
	TData = Awaited<ReturnType<typeof sessionsControllerList>>,
	TError = unknown,
>(
	params?: SessionsControllerListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all sessions
 */

export function useSessionsControllerList<
	TData = Awaited<ReturnType<typeof sessionsControllerList>>,
	TError = unknown,
>(
	params?: SessionsControllerListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getSessionsControllerListQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Create session a new session (and start it at the same time if required).
 * @summary Create a session
 */
export type sessionsControllerCreateResponse201 = {
	data: SessionDTO;
	status: 201;
};

export type sessionsControllerCreateResponseSuccess =
	sessionsControllerCreateResponse201 & {
		headers: Headers;
	};

export type sessionsControllerCreateResponse =
	sessionsControllerCreateResponseSuccess;

export const getSessionsControllerCreateUrl = () => {
	return `https://waha.gnardawgs.surf/api/sessions`;
};

export const sessionsControllerCreate = async (
	sessionCreateRequest: SessionCreateRequest,
	options?: RequestInit,
): Promise<sessionsControllerCreateResponse> => {
	const res = await fetch(getSessionsControllerCreateUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(sessionCreateRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerCreateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerCreateResponse;
};

export const getSessionsControllerCreateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerCreate>>,
		TError,
		{ data: SessionCreateRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerCreate>>,
	TError,
	{ data: SessionCreateRequest },
	TContext
> => {
	const mutationKey = ["sessionsControllerCreate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerCreate>>,
		{ data: SessionCreateRequest }
	> = (props) => {
		const { data } = props ?? {};

		return sessionsControllerCreate(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerCreate>>
>;
export type SessionsControllerCreateMutationBody = SessionCreateRequest;
export type SessionsControllerCreateMutationError = unknown;

/**
 * @summary Create a session
 */
export const useSessionsControllerCreate = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerCreate>>,
			TError,
			{ data: SessionCreateRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerCreate>>,
	TError,
	{ data: SessionCreateRequest },
	TContext
> => {
	return useMutation(
		getSessionsControllerCreateMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get session information
 */
export type sessionsControllerGetResponse200 = {
	data: SessionInfo;
	status: 200;
};

export type sessionsControllerGetResponseSuccess =
	sessionsControllerGetResponse200 & {
		headers: Headers;
	};

export type sessionsControllerGetResponse =
	sessionsControllerGetResponseSuccess;

export const getSessionsControllerGetUrl = (
	params?: SessionsControllerGetParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/sessions/${session}?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/sessions/${session}`;
};

export const sessionsControllerGet = async (
	params?: SessionsControllerGetParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<sessionsControllerGetResponse> => {
	const res = await fetch(getSessionsControllerGetUrl(params, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerGetResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerGetResponse;
};

export const getSessionsControllerGetQueryKey = (
	params?: SessionsControllerGetParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/sessions/${session}`,
		...(params ? [params] : []),
	] as const;
};

export const getSessionsControllerGetQueryOptions = <
	TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
	TError = unknown,
>(
	params?: SessionsControllerGetParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getSessionsControllerGetQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof sessionsControllerGet>>
	> = ({ signal }) =>
		sessionsControllerGet(params, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof sessionsControllerGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SessionsControllerGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerGet>>
>;
export type SessionsControllerGetQueryError = unknown;

export function useSessionsControllerGet<
	TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
	TError = unknown,
>(
	params: undefined | SessionsControllerGetParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof sessionsControllerGet>>,
					TError,
					Awaited<ReturnType<typeof sessionsControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSessionsControllerGet<
	TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
	TError = unknown,
>(
	params?: SessionsControllerGetParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof sessionsControllerGet>>,
					TError,
					Awaited<ReturnType<typeof sessionsControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSessionsControllerGet<
	TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
	TError = unknown,
>(
	params?: SessionsControllerGetParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get session information
 */

export function useSessionsControllerGet<
	TData = Awaited<ReturnType<typeof sessionsControllerGet>>,
	TError = unknown,
>(
	params?: SessionsControllerGetParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getSessionsControllerGetQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Update a session
 */
export type sessionsControllerUpdateResponse200 = {
	data: SessionDTO;
	status: 200;
};

export type sessionsControllerUpdateResponseSuccess =
	sessionsControllerUpdateResponse200 & {
		headers: Headers;
	};

export type sessionsControllerUpdateResponse =
	sessionsControllerUpdateResponseSuccess;

export const getSessionsControllerUpdateUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/sessions/${session}`;
};

export const sessionsControllerUpdate = async (
	sessionUpdateRequest: SessionUpdateRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<sessionsControllerUpdateResponse> => {
	const res = await fetch(getSessionsControllerUpdateUrl(session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(sessionUpdateRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerUpdateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerUpdateResponse;
};

export const getSessionsControllerUpdateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerUpdate>>,
		TError,
		{ data: SessionUpdateRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerUpdate>>,
	TError,
	{ data: SessionUpdateRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["sessionsControllerUpdate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerUpdate>>,
		{ data: SessionUpdateRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return sessionsControllerUpdate(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerUpdate>>
>;
export type SessionsControllerUpdateMutationBody = SessionUpdateRequest;
export type SessionsControllerUpdateMutationError = unknown;

/**
 * @summary Update a session
 */
export const useSessionsControllerUpdate = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerUpdate>>,
			TError,
			{ data: SessionUpdateRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerUpdate>>,
	TError,
	{ data: SessionUpdateRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getSessionsControllerUpdateMutationOptions(options),
		queryClient,
	);
};

/**
 * Delete the session with the given name. Stop and logout as well. Idempotent operation.
 * @summary Delete the session
 */
export type sessionsControllerDeleteResponse200 = {
	data: void;
	status: 200;
};

export type sessionsControllerDeleteResponseSuccess =
	sessionsControllerDeleteResponse200 & {
		headers: Headers;
	};

export type sessionsControllerDeleteResponse =
	sessionsControllerDeleteResponseSuccess;

export const getSessionsControllerDeleteUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/sessions/${session}`;
};

export const sessionsControllerDelete = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<sessionsControllerDeleteResponse> => {
	const res = await fetch(getSessionsControllerDeleteUrl(session), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerDeleteResponse;
};

export const getSessionsControllerDeleteMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerDelete>>,
		TError,
		{ session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerDelete>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	const mutationKey = ["sessionsControllerDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerDelete>>,
		{ session?: unknown }
	> = (props) => {
		const { session } = props ?? {};

		return sessionsControllerDelete(session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerDelete>>
>;

export type SessionsControllerDeleteMutationError = unknown;

/**
 * @summary Delete the session
 */
export const useSessionsControllerDelete = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerDelete>>,
			TError,
			{ session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerDelete>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	return useMutation(
		getSessionsControllerDeleteMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get information about the authenticated account
 */
export type sessionsControllerGetMeResponse200 = {
	data: MeInfo;
	status: 200;
};

export type sessionsControllerGetMeResponseSuccess =
	sessionsControllerGetMeResponse200 & {
		headers: Headers;
	};

export type sessionsControllerGetMeResponse =
	sessionsControllerGetMeResponseSuccess;

export const getSessionsControllerGetMeUrl = (session: unknown = "default") => {
	return `https://waha.gnardawgs.surf/api/sessions/${session}/me`;
};

export const sessionsControllerGetMe = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<sessionsControllerGetMeResponse> => {
	const res = await fetch(getSessionsControllerGetMeUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerGetMeResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerGetMeResponse;
};

export const getSessionsControllerGetMeQueryKey = (
	session: unknown = "default",
) => {
	return [`https://waha.gnardawgs.surf/api/sessions/${session}/me`] as const;
};

export const getSessionsControllerGetMeQueryOptions = <
	TData = Awaited<ReturnType<typeof sessionsControllerGetMe>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGetMe>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getSessionsControllerGetMeQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof sessionsControllerGetMe>>
	> = ({ signal }) =>
		sessionsControllerGetMe(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof sessionsControllerGetMe>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type SessionsControllerGetMeQueryResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerGetMe>>
>;
export type SessionsControllerGetMeQueryError = unknown;

export function useSessionsControllerGetMe<
	TData = Awaited<ReturnType<typeof sessionsControllerGetMe>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGetMe>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof sessionsControllerGetMe>>,
					TError,
					Awaited<ReturnType<typeof sessionsControllerGetMe>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSessionsControllerGetMe<
	TData = Awaited<ReturnType<typeof sessionsControllerGetMe>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGetMe>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof sessionsControllerGetMe>>,
					TError,
					Awaited<ReturnType<typeof sessionsControllerGetMe>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useSessionsControllerGetMe<
	TData = Awaited<ReturnType<typeof sessionsControllerGetMe>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGetMe>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get information about the authenticated account
 */

export function useSessionsControllerGetMe<
	TData = Awaited<ReturnType<typeof sessionsControllerGetMe>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof sessionsControllerGetMe>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getSessionsControllerGetMeQueryOptions(session, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Start the session with the given name. The session must exist. Idempotent operation.
 * @summary Start the session
 */
export type sessionsControllerStartResponse201 = {
	data: SessionDTO;
	status: 201;
};

export type sessionsControllerStartResponseSuccess =
	sessionsControllerStartResponse201 & {
		headers: Headers;
	};

export type sessionsControllerStartResponse =
	sessionsControllerStartResponseSuccess;

export const getSessionsControllerStartUrl = (session: unknown = "default") => {
	return `https://waha.gnardawgs.surf/api/sessions/${session}/start`;
};

export const sessionsControllerStart = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<sessionsControllerStartResponse> => {
	const res = await fetch(getSessionsControllerStartUrl(session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerStartResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerStartResponse;
};

export const getSessionsControllerStartMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerStart>>,
		TError,
		{ session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerStart>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	const mutationKey = ["sessionsControllerStart"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerStart>>,
		{ session?: unknown }
	> = (props) => {
		const { session } = props ?? {};

		return sessionsControllerStart(session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerStartMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerStart>>
>;

export type SessionsControllerStartMutationError = unknown;

/**
 * @summary Start the session
 */
export const useSessionsControllerStart = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerStart>>,
			TError,
			{ session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerStart>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	return useMutation(
		getSessionsControllerStartMutationOptions(options),
		queryClient,
	);
};

/**
 * Stop the session with the given name. Idempotent operation.
 * @summary Stop the session
 */
export type sessionsControllerStopResponse201 = {
	data: SessionDTO;
	status: 201;
};

export type sessionsControllerStopResponseSuccess =
	sessionsControllerStopResponse201 & {
		headers: Headers;
	};

export type sessionsControllerStopResponse =
	sessionsControllerStopResponseSuccess;

export const getSessionsControllerStopUrl = (session: unknown = "default") => {
	return `https://waha.gnardawgs.surf/api/sessions/${session}/stop`;
};

export const sessionsControllerStop = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<sessionsControllerStopResponse> => {
	const res = await fetch(getSessionsControllerStopUrl(session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerStopResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerStopResponse;
};

export const getSessionsControllerStopMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerStop>>,
		TError,
		{ session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerStop>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	const mutationKey = ["sessionsControllerStop"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerStop>>,
		{ session?: unknown }
	> = (props) => {
		const { session } = props ?? {};

		return sessionsControllerStop(session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerStopMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerStop>>
>;

export type SessionsControllerStopMutationError = unknown;

/**
 * @summary Stop the session
 */
export const useSessionsControllerStop = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerStop>>,
			TError,
			{ session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerStop>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	return useMutation(
		getSessionsControllerStopMutationOptions(options),
		queryClient,
	);
};

/**
 * Logout the session, restart a session if it was not STOPPED
 * @summary Logout from the session
 */
export type sessionsControllerLogoutResponse201 = {
	data: SessionDTO;
	status: 201;
};

export type sessionsControllerLogoutResponseSuccess =
	sessionsControllerLogoutResponse201 & {
		headers: Headers;
	};

export type sessionsControllerLogoutResponse =
	sessionsControllerLogoutResponseSuccess;

export const getSessionsControllerLogoutUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/sessions/${session}/logout`;
};

export const sessionsControllerLogout = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<sessionsControllerLogoutResponse> => {
	const res = await fetch(getSessionsControllerLogoutUrl(session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerLogoutResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerLogoutResponse;
};

export const getSessionsControllerLogoutMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerLogout>>,
		TError,
		{ session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerLogout>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	const mutationKey = ["sessionsControllerLogout"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerLogout>>,
		{ session?: unknown }
	> = (props) => {
		const { session } = props ?? {};

		return sessionsControllerLogout(session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerLogoutMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerLogout>>
>;

export type SessionsControllerLogoutMutationError = unknown;

/**
 * @summary Logout from the session
 */
export const useSessionsControllerLogout = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerLogout>>,
			TError,
			{ session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerLogout>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	return useMutation(
		getSessionsControllerLogoutMutationOptions(options),
		queryClient,
	);
};

/**
 * Restart the session with the given name.
 * @summary Restart the session
 */
export type sessionsControllerRestartResponse201 = {
	data: SessionDTO;
	status: 201;
};

export type sessionsControllerRestartResponseSuccess =
	sessionsControllerRestartResponse201 & {
		headers: Headers;
	};

export type sessionsControllerRestartResponse =
	sessionsControllerRestartResponseSuccess;

export const getSessionsControllerRestartUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/sessions/${session}/restart`;
};

export const sessionsControllerRestart = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<sessionsControllerRestartResponse> => {
	const res = await fetch(getSessionsControllerRestartUrl(session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerRestartResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerRestartResponse;
};

export const getSessionsControllerRestartMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerRestart>>,
		TError,
		{ session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerRestart>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	const mutationKey = ["sessionsControllerRestart"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerRestart>>,
		{ session?: unknown }
	> = (props) => {
		const { session } = props ?? {};

		return sessionsControllerRestart(session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerRestartMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerRestart>>
>;

export type SessionsControllerRestartMutationError = unknown;

/**
 * @summary Restart the session
 */
export const useSessionsControllerRestart = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerRestart>>,
			TError,
			{ session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerRestart>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	return useMutation(
		getSessionsControllerRestartMutationOptions(options),
		queryClient,
	);
};

/**
 * Create session (if not exists) or update a config (if exists) and start it.
 * @deprecated
 * @summary Upsert and Start session
 */
export type sessionsControllerDEPRACATEDStartResponse201 = {
	data: SessionDTO;
	status: 201;
};

export type sessionsControllerDEPRACATEDStartResponseSuccess =
	sessionsControllerDEPRACATEDStartResponse201 & {
		headers: Headers;
	};

export type sessionsControllerDEPRACATEDStartResponse =
	sessionsControllerDEPRACATEDStartResponseSuccess;

export const getSessionsControllerDEPRACATEDStartUrl = () => {
	return `https://waha.gnardawgs.surf/api/sessions/start`;
};

export const sessionsControllerDEPRACATEDStart = async (
	sessionStartDeprecatedRequest: SessionStartDeprecatedRequest,
	options?: RequestInit,
): Promise<sessionsControllerDEPRACATEDStartResponse> => {
	const res = await fetch(getSessionsControllerDEPRACATEDStartUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(sessionStartDeprecatedRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerDEPRACATEDStartResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerDEPRACATEDStartResponse;
};

export const getSessionsControllerDEPRACATEDStartMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerDEPRACATEDStart>>,
		TError,
		{ data: SessionStartDeprecatedRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerDEPRACATEDStart>>,
	TError,
	{ data: SessionStartDeprecatedRequest },
	TContext
> => {
	const mutationKey = ["sessionsControllerDEPRACATEDStart"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerDEPRACATEDStart>>,
		{ data: SessionStartDeprecatedRequest }
	> = (props) => {
		const { data } = props ?? {};

		return sessionsControllerDEPRACATEDStart(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerDEPRACATEDStartMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerDEPRACATEDStart>>
>;
export type SessionsControllerDEPRACATEDStartMutationBody =
	SessionStartDeprecatedRequest;
export type SessionsControllerDEPRACATEDStartMutationError = unknown;

/**
 * @deprecated
 * @summary Upsert and Start session
 */
export const useSessionsControllerDEPRACATEDStart = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerDEPRACATEDStart>>,
			TError,
			{ data: SessionStartDeprecatedRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerDEPRACATEDStart>>,
	TError,
	{ data: SessionStartDeprecatedRequest },
	TContext
> => {
	return useMutation(
		getSessionsControllerDEPRACATEDStartMutationOptions(options),
		queryClient,
	);
};

/**
 * Stop session and Logout by default.
 * @deprecated
 * @summary Stop (and Logout if asked) session
 */
export type sessionsControllerDEPRECATEDStopResponse201 = {
	data: void;
	status: 201;
};

export type sessionsControllerDEPRECATEDStopResponseSuccess =
	sessionsControllerDEPRECATEDStopResponse201 & {
		headers: Headers;
	};

export type sessionsControllerDEPRECATEDStopResponse =
	sessionsControllerDEPRECATEDStopResponseSuccess;

export const getSessionsControllerDEPRECATEDStopUrl = () => {
	return `https://waha.gnardawgs.surf/api/sessions/stop`;
};

export const sessionsControllerDEPRECATEDStop = async (
	sessionStopDeprecatedRequest: SessionStopDeprecatedRequest,
	options?: RequestInit,
): Promise<sessionsControllerDEPRECATEDStopResponse> => {
	const res = await fetch(getSessionsControllerDEPRECATEDStopUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(sessionStopDeprecatedRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerDEPRECATEDStopResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerDEPRECATEDStopResponse;
};

export const getSessionsControllerDEPRECATEDStopMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerDEPRECATEDStop>>,
		TError,
		{ data: SessionStopDeprecatedRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerDEPRECATEDStop>>,
	TError,
	{ data: SessionStopDeprecatedRequest },
	TContext
> => {
	const mutationKey = ["sessionsControllerDEPRECATEDStop"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerDEPRECATEDStop>>,
		{ data: SessionStopDeprecatedRequest }
	> = (props) => {
		const { data } = props ?? {};

		return sessionsControllerDEPRECATEDStop(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerDEPRECATEDStopMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerDEPRECATEDStop>>
>;
export type SessionsControllerDEPRECATEDStopMutationBody =
	SessionStopDeprecatedRequest;
export type SessionsControllerDEPRECATEDStopMutationError = unknown;

/**
 * @deprecated
 * @summary Stop (and Logout if asked) session
 */
export const useSessionsControllerDEPRECATEDStop = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerDEPRECATEDStop>>,
			TError,
			{ data: SessionStopDeprecatedRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerDEPRECATEDStop>>,
	TError,
	{ data: SessionStopDeprecatedRequest },
	TContext
> => {
	return useMutation(
		getSessionsControllerDEPRECATEDStopMutationOptions(options),
		queryClient,
	);
};

/**
 * Stop, Logout and Delete session.
 * @deprecated
 * @summary Logout and Delete session.
 */
export type sessionsControllerDEPRECATEDLogoutResponse201 = {
	data: void;
	status: 201;
};

export type sessionsControllerDEPRECATEDLogoutResponseSuccess =
	sessionsControllerDEPRECATEDLogoutResponse201 & {
		headers: Headers;
	};

export type sessionsControllerDEPRECATEDLogoutResponse =
	sessionsControllerDEPRECATEDLogoutResponseSuccess;

export const getSessionsControllerDEPRECATEDLogoutUrl = () => {
	return `https://waha.gnardawgs.surf/api/sessions/logout`;
};

export const sessionsControllerDEPRECATEDLogout = async (
	sessionLogoutDeprecatedRequest: SessionLogoutDeprecatedRequest,
	options?: RequestInit,
): Promise<sessionsControllerDEPRECATEDLogoutResponse> => {
	const res = await fetch(getSessionsControllerDEPRECATEDLogoutUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(sessionLogoutDeprecatedRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: sessionsControllerDEPRECATEDLogoutResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as sessionsControllerDEPRECATEDLogoutResponse;
};

export const getSessionsControllerDEPRECATEDLogoutMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof sessionsControllerDEPRECATEDLogout>>,
		TError,
		{ data: SessionLogoutDeprecatedRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof sessionsControllerDEPRECATEDLogout>>,
	TError,
	{ data: SessionLogoutDeprecatedRequest },
	TContext
> => {
	const mutationKey = ["sessionsControllerDEPRECATEDLogout"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof sessionsControllerDEPRECATEDLogout>>,
		{ data: SessionLogoutDeprecatedRequest }
	> = (props) => {
		const { data } = props ?? {};

		return sessionsControllerDEPRECATEDLogout(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SessionsControllerDEPRECATEDLogoutMutationResult = NonNullable<
	Awaited<ReturnType<typeof sessionsControllerDEPRECATEDLogout>>
>;
export type SessionsControllerDEPRECATEDLogoutMutationBody =
	SessionLogoutDeprecatedRequest;
export type SessionsControllerDEPRECATEDLogoutMutationError = unknown;

/**
 * @deprecated
 * @summary Logout and Delete session.
 */
export const useSessionsControllerDEPRECATEDLogout = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof sessionsControllerDEPRECATEDLogout>>,
			TError,
			{ data: SessionLogoutDeprecatedRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof sessionsControllerDEPRECATEDLogout>>,
	TError,
	{ data: SessionLogoutDeprecatedRequest },
	TContext
> => {
	return useMutation(
		getSessionsControllerDEPRECATEDLogoutMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get my profile
 */
export type profileControllerGetMyProfileResponse200 = {
	data: MyProfile;
	status: 200;
};

export type profileControllerGetMyProfileResponseSuccess =
	profileControllerGetMyProfileResponse200 & {
		headers: Headers;
	};

export type profileControllerGetMyProfileResponse =
	profileControllerGetMyProfileResponseSuccess;

export const getProfileControllerGetMyProfileUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/profile`;
};

export const profileControllerGetMyProfile = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<profileControllerGetMyProfileResponse> => {
	const res = await fetch(getProfileControllerGetMyProfileUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: profileControllerGetMyProfileResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as profileControllerGetMyProfileResponse;
};

export const getProfileControllerGetMyProfileQueryKey = (
	session: unknown = "default",
) => {
	return [`https://waha.gnardawgs.surf/api/${session}/profile`] as const;
};

export const getProfileControllerGetMyProfileQueryOptions = <
	TData = Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getProfileControllerGetMyProfileQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof profileControllerGetMyProfile>>
	> = ({ signal }) =>
		profileControllerGetMyProfile(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ProfileControllerGetMyProfileQueryResult = NonNullable<
	Awaited<ReturnType<typeof profileControllerGetMyProfile>>
>;
export type ProfileControllerGetMyProfileQueryError = unknown;

export function useProfileControllerGetMyProfile<
	TData = Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
					TError,
					Awaited<ReturnType<typeof profileControllerGetMyProfile>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProfileControllerGetMyProfile<
	TData = Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
					TError,
					Awaited<ReturnType<typeof profileControllerGetMyProfile>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useProfileControllerGetMyProfile<
	TData = Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get my profile
 */

export function useProfileControllerGetMyProfile<
	TData = Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof profileControllerGetMyProfile>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getProfileControllerGetMyProfileQueryOptions(
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Set my profile name
 */
export type profileControllerSetProfileNameResponse200 = {
	data: Result;
	status: 200;
};

export type profileControllerSetProfileNameResponseSuccess =
	profileControllerSetProfileNameResponse200 & {
		headers: Headers;
	};

export type profileControllerSetProfileNameResponse =
	profileControllerSetProfileNameResponseSuccess;

export const getProfileControllerSetProfileNameUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/profile/name`;
};

export const profileControllerSetProfileName = async (
	profileNameRequest: ProfileNameRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<profileControllerSetProfileNameResponse> => {
	const res = await fetch(getProfileControllerSetProfileNameUrl(session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(profileNameRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: profileControllerSetProfileNameResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as profileControllerSetProfileNameResponse;
};

export const getProfileControllerSetProfileNameMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof profileControllerSetProfileName>>,
		TError,
		{ data: ProfileNameRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof profileControllerSetProfileName>>,
	TError,
	{ data: ProfileNameRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["profileControllerSetProfileName"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof profileControllerSetProfileName>>,
		{ data: ProfileNameRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return profileControllerSetProfileName(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ProfileControllerSetProfileNameMutationResult = NonNullable<
	Awaited<ReturnType<typeof profileControllerSetProfileName>>
>;
export type ProfileControllerSetProfileNameMutationBody = ProfileNameRequest;
export type ProfileControllerSetProfileNameMutationError = unknown;

/**
 * @summary Set my profile name
 */
export const useProfileControllerSetProfileName = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof profileControllerSetProfileName>>,
			TError,
			{ data: ProfileNameRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof profileControllerSetProfileName>>,
	TError,
	{ data: ProfileNameRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getProfileControllerSetProfileNameMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Set profile status (About)
 */
export type profileControllerSetProfileStatusResponse200 = {
	data: Result;
	status: 200;
};

export type profileControllerSetProfileStatusResponseSuccess =
	profileControllerSetProfileStatusResponse200 & {
		headers: Headers;
	};

export type profileControllerSetProfileStatusResponse =
	profileControllerSetProfileStatusResponseSuccess;

export const getProfileControllerSetProfileStatusUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/profile/status`;
};

export const profileControllerSetProfileStatus = async (
	profileStatusRequest: ProfileStatusRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<profileControllerSetProfileStatusResponse> => {
	const res = await fetch(getProfileControllerSetProfileStatusUrl(session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(profileStatusRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: profileControllerSetProfileStatusResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as profileControllerSetProfileStatusResponse;
};

export const getProfileControllerSetProfileStatusMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof profileControllerSetProfileStatus>>,
		TError,
		{ data: ProfileStatusRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof profileControllerSetProfileStatus>>,
	TError,
	{ data: ProfileStatusRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["profileControllerSetProfileStatus"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof profileControllerSetProfileStatus>>,
		{ data: ProfileStatusRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return profileControllerSetProfileStatus(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ProfileControllerSetProfileStatusMutationResult = NonNullable<
	Awaited<ReturnType<typeof profileControllerSetProfileStatus>>
>;
export type ProfileControllerSetProfileStatusMutationBody =
	ProfileStatusRequest;
export type ProfileControllerSetProfileStatusMutationError = unknown;

/**
 * @summary Set profile status (About)
 */
export const useProfileControllerSetProfileStatus = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof profileControllerSetProfileStatus>>,
			TError,
			{ data: ProfileStatusRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof profileControllerSetProfileStatus>>,
	TError,
	{ data: ProfileStatusRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getProfileControllerSetProfileStatusMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Set profile picture
 */
export type profileControllerSetProfilePictureResponse200 = {
	data: Result;
	status: 200;
};

export type profileControllerSetProfilePictureResponseSuccess =
	profileControllerSetProfilePictureResponse200 & {
		headers: Headers;
	};

export type profileControllerSetProfilePictureResponse =
	profileControllerSetProfilePictureResponseSuccess;

export const getProfileControllerSetProfilePictureUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/profile/picture`;
};

export const profileControllerSetProfilePicture = async (
	profilePictureRequest: ProfilePictureRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<profileControllerSetProfilePictureResponse> => {
	const res = await fetch(getProfileControllerSetProfilePictureUrl(session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(profilePictureRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: profileControllerSetProfilePictureResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as profileControllerSetProfilePictureResponse;
};

export const getProfileControllerSetProfilePictureMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof profileControllerSetProfilePicture>>,
		TError,
		{ data: ProfilePictureRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof profileControllerSetProfilePicture>>,
	TError,
	{ data: ProfilePictureRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["profileControllerSetProfilePicture"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof profileControllerSetProfilePicture>>,
		{ data: ProfilePictureRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return profileControllerSetProfilePicture(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ProfileControllerSetProfilePictureMutationResult = NonNullable<
	Awaited<ReturnType<typeof profileControllerSetProfilePicture>>
>;
export type ProfileControllerSetProfilePictureMutationBody =
	ProfilePictureRequest;
export type ProfileControllerSetProfilePictureMutationError = unknown;

/**
 * @summary Set profile picture
 */
export const useProfileControllerSetProfilePicture = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof profileControllerSetProfilePicture>>,
			TError,
			{ data: ProfilePictureRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof profileControllerSetProfilePicture>>,
	TError,
	{ data: ProfilePictureRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getProfileControllerSetProfilePictureMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Delete profile picture
 */
export type profileControllerDeleteProfilePictureResponse200 = {
	data: Result;
	status: 200;
};

export type profileControllerDeleteProfilePictureResponseSuccess =
	profileControllerDeleteProfilePictureResponse200 & {
		headers: Headers;
	};

export type profileControllerDeleteProfilePictureResponse =
	profileControllerDeleteProfilePictureResponseSuccess;

export const getProfileControllerDeleteProfilePictureUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/profile/picture`;
};

export const profileControllerDeleteProfilePicture = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<profileControllerDeleteProfilePictureResponse> => {
	const res = await fetch(
		getProfileControllerDeleteProfilePictureUrl(session),
		{
			...options,
			method: "DELETE",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: profileControllerDeleteProfilePictureResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as profileControllerDeleteProfilePictureResponse;
};

export const getProfileControllerDeleteProfilePictureMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof profileControllerDeleteProfilePicture>>,
		TError,
		{ session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof profileControllerDeleteProfilePicture>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	const mutationKey = ["profileControllerDeleteProfilePicture"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof profileControllerDeleteProfilePicture>>,
		{ session?: unknown }
	> = (props) => {
		const { session } = props ?? {};

		return profileControllerDeleteProfilePicture(session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ProfileControllerDeleteProfilePictureMutationResult = NonNullable<
	Awaited<ReturnType<typeof profileControllerDeleteProfilePicture>>
>;

export type ProfileControllerDeleteProfilePictureMutationError = unknown;

/**
 * @summary Delete profile picture
 */
export const useProfileControllerDeleteProfilePicture = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof profileControllerDeleteProfilePicture>>,
			TError,
			{ session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof profileControllerDeleteProfilePicture>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	return useMutation(
		getProfileControllerDeleteProfilePictureMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Send a text message
 */
export type chattingControllerSendTextResponse201 = {
	data: WAMessage;
	status: 201;
};

export type chattingControllerSendTextResponseSuccess =
	chattingControllerSendTextResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendTextResponse =
	chattingControllerSendTextResponseSuccess;

export const getChattingControllerSendTextUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendText`;
};

export const chattingControllerSendText = async (
	messageTextRequest: MessageTextRequest,
	options?: RequestInit,
): Promise<chattingControllerSendTextResponse> => {
	const res = await fetch(getChattingControllerSendTextUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageTextRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendTextResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendTextResponse;
};

export const getChattingControllerSendTextMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendText>>,
		TError,
		{ data: MessageTextRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendText>>,
	TError,
	{ data: MessageTextRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendText"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendText>>,
		{ data: MessageTextRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendText(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendTextMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendText>>
>;
export type ChattingControllerSendTextMutationBody = MessageTextRequest;
export type ChattingControllerSendTextMutationError = unknown;

/**
 * @summary Send a text message
 */
export const useChattingControllerSendText = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendText>>,
			TError,
			{ data: MessageTextRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendText>>,
	TError,
	{ data: MessageTextRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendTextMutationOptions(options),
		queryClient,
	);
};

/**
 * @deprecated
 * @summary Send a text message
 */
export type chattingControllerSendTextGetResponse200 = {
	data: ChattingControllerSendTextGet200;
	status: 200;
};

export type chattingControllerSendTextGetResponseSuccess =
	chattingControllerSendTextGetResponse200 & {
		headers: Headers;
	};

export type chattingControllerSendTextGetResponse =
	chattingControllerSendTextGetResponseSuccess;

export const getChattingControllerSendTextGetUrl = (
	params: ChattingControllerSendTextGetParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/sendText?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/sendText`;
};

export const chattingControllerSendTextGet = async (
	params: ChattingControllerSendTextGetParams,
	options?: RequestInit,
): Promise<chattingControllerSendTextGetResponse> => {
	const res = await fetch(getChattingControllerSendTextGetUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendTextGetResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendTextGetResponse;
};

export const getChattingControllerSendTextGetQueryKey = (
	params?: ChattingControllerSendTextGetParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/sendText`,
		...(params ? [params] : []),
	] as const;
};

export const getChattingControllerSendTextGetQueryOptions = <
	TData = Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
	TError = unknown,
>(
	params: ChattingControllerSendTextGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getChattingControllerSendTextGetQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chattingControllerSendTextGet>>
	> = ({ signal }) =>
		chattingControllerSendTextGet(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChattingControllerSendTextGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendTextGet>>
>;
export type ChattingControllerSendTextGetQueryError = unknown;

export function useChattingControllerSendTextGet<
	TData = Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
	TError = unknown,
>(
	params: ChattingControllerSendTextGetParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
					TError,
					Awaited<ReturnType<typeof chattingControllerSendTextGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChattingControllerSendTextGet<
	TData = Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
	TError = unknown,
>(
	params: ChattingControllerSendTextGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
					TError,
					Awaited<ReturnType<typeof chattingControllerSendTextGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChattingControllerSendTextGet<
	TData = Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
	TError = unknown,
>(
	params: ChattingControllerSendTextGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary Send a text message
 */

export function useChattingControllerSendTextGet<
	TData = Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
	TError = unknown,
>(
	params: ChattingControllerSendTextGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerSendTextGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChattingControllerSendTextGetQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Either from an URL or base64 data - look at the request schemas for details.
 * @summary Send an image
 */
export type chattingControllerSendImageResponse201 = {
	data: ChattingControllerSendImage201;
	status: 201;
};

export type chattingControllerSendImageResponseSuccess =
	chattingControllerSendImageResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendImageResponse =
	chattingControllerSendImageResponseSuccess;

export const getChattingControllerSendImageUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendImage`;
};

export const chattingControllerSendImage = async (
	messageImageRequest: MessageImageRequest,
	options?: RequestInit,
): Promise<chattingControllerSendImageResponse> => {
	const res = await fetch(getChattingControllerSendImageUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageImageRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendImageResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendImageResponse;
};

export const getChattingControllerSendImageMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendImage>>,
		TError,
		{ data: MessageImageRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendImage>>,
	TError,
	{ data: MessageImageRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendImage"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendImage>>,
		{ data: MessageImageRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendImage(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendImageMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendImage>>
>;
export type ChattingControllerSendImageMutationBody = MessageImageRequest;
export type ChattingControllerSendImageMutationError = unknown;

/**
 * @summary Send an image
 */
export const useChattingControllerSendImage = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendImage>>,
			TError,
			{ data: MessageImageRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendImage>>,
	TError,
	{ data: MessageImageRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendImageMutationOptions(options),
		queryClient,
	);
};

/**
 * Either from an URL or base64 data - look at the request schemas for details.
 * @summary Send a file
 */
export type chattingControllerSendFileResponse201 = {
	data: ChattingControllerSendFile201;
	status: 201;
};

export type chattingControllerSendFileResponseSuccess =
	chattingControllerSendFileResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendFileResponse =
	chattingControllerSendFileResponseSuccess;

export const getChattingControllerSendFileUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendFile`;
};

export const chattingControllerSendFile = async (
	messageFileRequest: MessageFileRequest,
	options?: RequestInit,
): Promise<chattingControllerSendFileResponse> => {
	const res = await fetch(getChattingControllerSendFileUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageFileRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendFileResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendFileResponse;
};

export const getChattingControllerSendFileMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendFile>>,
		TError,
		{ data: MessageFileRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendFile>>,
	TError,
	{ data: MessageFileRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendFile"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendFile>>,
		{ data: MessageFileRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendFile(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendFileMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendFile>>
>;
export type ChattingControllerSendFileMutationBody = MessageFileRequest;
export type ChattingControllerSendFileMutationError = unknown;

/**
 * @summary Send a file
 */
export const useChattingControllerSendFile = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendFile>>,
			TError,
			{ data: MessageFileRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendFile>>,
	TError,
	{ data: MessageFileRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendFileMutationOptions(options),
		queryClient,
	);
};

/**
 * Either from an URL or base64 data - look at the request schemas for details.
 * @summary Send an voice message
 */
export type chattingControllerSendVoiceResponse201 = {
	data: ChattingControllerSendVoice201;
	status: 201;
};

export type chattingControllerSendVoiceResponseSuccess =
	chattingControllerSendVoiceResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendVoiceResponse =
	chattingControllerSendVoiceResponseSuccess;

export const getChattingControllerSendVoiceUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendVoice`;
};

export const chattingControllerSendVoice = async (
	messageVoiceRequest: MessageVoiceRequest,
	options?: RequestInit,
): Promise<chattingControllerSendVoiceResponse> => {
	const res = await fetch(getChattingControllerSendVoiceUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageVoiceRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendVoiceResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendVoiceResponse;
};

export const getChattingControllerSendVoiceMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendVoice>>,
		TError,
		{ data: MessageVoiceRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendVoice>>,
	TError,
	{ data: MessageVoiceRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendVoice"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendVoice>>,
		{ data: MessageVoiceRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendVoice(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendVoiceMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendVoice>>
>;
export type ChattingControllerSendVoiceMutationBody = MessageVoiceRequest;
export type ChattingControllerSendVoiceMutationError = unknown;

/**
 * @summary Send an voice message
 */
export const useChattingControllerSendVoice = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendVoice>>,
			TError,
			{ data: MessageVoiceRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendVoice>>,
	TError,
	{ data: MessageVoiceRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendVoiceMutationOptions(options),
		queryClient,
	);
};

/**
 * Either from an URL or base64 data - look at the request schemas for details.
 * @summary Send a video
 */
export type chattingControllerSendVideoResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerSendVideoResponseSuccess =
	chattingControllerSendVideoResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendVideoResponse =
	chattingControllerSendVideoResponseSuccess;

export const getChattingControllerSendVideoUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendVideo`;
};

export const chattingControllerSendVideo = async (
	messageVideoRequest: MessageVideoRequest,
	options?: RequestInit,
): Promise<chattingControllerSendVideoResponse> => {
	const res = await fetch(getChattingControllerSendVideoUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageVideoRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendVideoResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendVideoResponse;
};

export const getChattingControllerSendVideoMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendVideo>>,
		TError,
		{ data: MessageVideoRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendVideo>>,
	TError,
	{ data: MessageVideoRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendVideo"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendVideo>>,
		{ data: MessageVideoRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendVideo(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendVideoMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendVideo>>
>;
export type ChattingControllerSendVideoMutationBody = MessageVideoRequest;
export type ChattingControllerSendVideoMutationError = unknown;

/**
 * @summary Send a video
 */
export const useChattingControllerSendVideo = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendVideo>>,
			TError,
			{ data: MessageVideoRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendVideo>>,
	TError,
	{ data: MessageVideoRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendVideoMutationOptions(options),
		queryClient,
	);
};

/**
 * You can use regular /api/sendText if you wanna send auto-generated link preview.
 * @summary Send a text message with a CUSTOM link preview.
 */
export type chattingControllerSendLinkCustomPreviewResponse201 = {
	data: ChattingControllerSendLinkCustomPreview201;
	status: 201;
};

export type chattingControllerSendLinkCustomPreviewResponseSuccess =
	chattingControllerSendLinkCustomPreviewResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendLinkCustomPreviewResponse =
	chattingControllerSendLinkCustomPreviewResponseSuccess;

export const getChattingControllerSendLinkCustomPreviewUrl = () => {
	return `https://waha.gnardawgs.surf/api/send/link-custom-preview`;
};

export const chattingControllerSendLinkCustomPreview = async (
	messageLinkCustomPreviewRequest: MessageLinkCustomPreviewRequest,
	options?: RequestInit,
): Promise<chattingControllerSendLinkCustomPreviewResponse> => {
	const res = await fetch(getChattingControllerSendLinkCustomPreviewUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageLinkCustomPreviewRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendLinkCustomPreviewResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendLinkCustomPreviewResponse;
};

export const getChattingControllerSendLinkCustomPreviewMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendLinkCustomPreview>>,
		TError,
		{ data: MessageLinkCustomPreviewRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendLinkCustomPreview>>,
	TError,
	{ data: MessageLinkCustomPreviewRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendLinkCustomPreview"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendLinkCustomPreview>>,
		{ data: MessageLinkCustomPreviewRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendLinkCustomPreview(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendLinkCustomPreviewMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendLinkCustomPreview>>
>;
export type ChattingControllerSendLinkCustomPreviewMutationBody =
	MessageLinkCustomPreviewRequest;
export type ChattingControllerSendLinkCustomPreviewMutationError = unknown;

/**
 * @summary Send a text message with a CUSTOM link preview.
 */
export const useChattingControllerSendLinkCustomPreview = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendLinkCustomPreview>>,
			TError,
			{ data: MessageLinkCustomPreviewRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendLinkCustomPreview>>,
	TError,
	{ data: MessageLinkCustomPreviewRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendLinkCustomPreviewMutationOptions(options),
		queryClient,
	);
};

/**
 * Send Buttons
 * @deprecated
 * @summary Send buttons message (interactive)
 */
export type chattingControllerSendButtonsResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerSendButtonsResponseSuccess =
	chattingControllerSendButtonsResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendButtonsResponse =
	chattingControllerSendButtonsResponseSuccess;

export const getChattingControllerSendButtonsUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendButtons`;
};

export const chattingControllerSendButtons = async (
	sendButtonsRequest: SendButtonsRequest,
	options?: RequestInit,
): Promise<chattingControllerSendButtonsResponse> => {
	const res = await fetch(getChattingControllerSendButtonsUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(sendButtonsRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendButtonsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendButtonsResponse;
};

export const getChattingControllerSendButtonsMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendButtons>>,
		TError,
		{ data: SendButtonsRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendButtons>>,
	TError,
	{ data: SendButtonsRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendButtons"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendButtons>>,
		{ data: SendButtonsRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendButtons(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendButtonsMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendButtons>>
>;
export type ChattingControllerSendButtonsMutationBody = SendButtonsRequest;
export type ChattingControllerSendButtonsMutationError = unknown;

/**
 * @deprecated
 * @summary Send buttons message (interactive)
 */
export const useChattingControllerSendButtons = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendButtons>>,
			TError,
			{ data: SendButtonsRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendButtons>>,
	TError,
	{ data: SendButtonsRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendButtonsMutationOptions(options),
		queryClient,
	);
};

/**
 * Send a List message with sections and rows
 * @summary Send a list message (interactive)
 */
export type chattingControllerSendListResponse201 = {
	data: ChattingControllerSendList201;
	status: 201;
};

export type chattingControllerSendListResponseSuccess =
	chattingControllerSendListResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendListResponse =
	chattingControllerSendListResponseSuccess;

export const getChattingControllerSendListUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendList`;
};

export const chattingControllerSendList = async (
	sendListRequest: SendListRequest,
	options?: RequestInit,
): Promise<chattingControllerSendListResponse> => {
	const res = await fetch(getChattingControllerSendListUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(sendListRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendListResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendListResponse;
};

export const getChattingControllerSendListMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendList>>,
		TError,
		{ data: SendListRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendList>>,
	TError,
	{ data: SendListRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendList"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendList>>,
		{ data: SendListRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendList(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendListMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendList>>
>;
export type ChattingControllerSendListMutationBody = SendListRequest;
export type ChattingControllerSendListMutationError = unknown;

/**
 * @summary Send a list message (interactive)
 */
export const useChattingControllerSendList = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendList>>,
			TError,
			{ data: SendListRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendList>>,
	TError,
	{ data: SendListRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendListMutationOptions(options),
		queryClient,
	);
};

export type chattingControllerForwardMessageResponse201 = {
	data: WAMessage;
	status: 201;
};

export type chattingControllerForwardMessageResponseSuccess =
	chattingControllerForwardMessageResponse201 & {
		headers: Headers;
	};

export type chattingControllerForwardMessageResponse =
	chattingControllerForwardMessageResponseSuccess;

export const getChattingControllerForwardMessageUrl = () => {
	return `https://waha.gnardawgs.surf/api/forwardMessage`;
};

export const chattingControllerForwardMessage = async (
	messageForwardRequest: MessageForwardRequest,
	options?: RequestInit,
): Promise<chattingControllerForwardMessageResponse> => {
	const res = await fetch(getChattingControllerForwardMessageUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageForwardRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerForwardMessageResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerForwardMessageResponse;
};

export const getChattingControllerForwardMessageMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerForwardMessage>>,
		TError,
		{ data: MessageForwardRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerForwardMessage>>,
	TError,
	{ data: MessageForwardRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerForwardMessage"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerForwardMessage>>,
		{ data: MessageForwardRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerForwardMessage(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerForwardMessageMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerForwardMessage>>
>;
export type ChattingControllerForwardMessageMutationBody =
	MessageForwardRequest;
export type ChattingControllerForwardMessageMutationError = unknown;

export const useChattingControllerForwardMessage = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerForwardMessage>>,
			TError,
			{ data: MessageForwardRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerForwardMessage>>,
	TError,
	{ data: MessageForwardRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerForwardMessageMutationOptions(options),
		queryClient,
	);
};

export type chattingControllerSendSeenResponse201 = {
	data: ChattingControllerSendSeen201;
	status: 201;
};

export type chattingControllerSendSeenResponseSuccess =
	chattingControllerSendSeenResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendSeenResponse =
	chattingControllerSendSeenResponseSuccess;

export const getChattingControllerSendSeenUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendSeen`;
};

export const chattingControllerSendSeen = async (
	sendSeenRequest: SendSeenRequest,
	options?: RequestInit,
): Promise<chattingControllerSendSeenResponse> => {
	const res = await fetch(getChattingControllerSendSeenUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(sendSeenRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendSeenResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendSeenResponse;
};

export const getChattingControllerSendSeenMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendSeen>>,
		TError,
		{ data: SendSeenRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendSeen>>,
	TError,
	{ data: SendSeenRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendSeen"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendSeen>>,
		{ data: SendSeenRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendSeen(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendSeenMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendSeen>>
>;
export type ChattingControllerSendSeenMutationBody = SendSeenRequest;
export type ChattingControllerSendSeenMutationError = unknown;

export const useChattingControllerSendSeen = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendSeen>>,
			TError,
			{ data: SendSeenRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendSeen>>,
	TError,
	{ data: SendSeenRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendSeenMutationOptions(options),
		queryClient,
	);
};

export type chattingControllerStartTypingResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerStartTypingResponseSuccess =
	chattingControllerStartTypingResponse201 & {
		headers: Headers;
	};

export type chattingControllerStartTypingResponse =
	chattingControllerStartTypingResponseSuccess;

export const getChattingControllerStartTypingUrl = () => {
	return `https://waha.gnardawgs.surf/api/startTyping`;
};

export const chattingControllerStartTyping = async (
	chatRequest: ChatRequest,
	options?: RequestInit,
): Promise<chattingControllerStartTypingResponse> => {
	const res = await fetch(getChattingControllerStartTypingUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(chatRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerStartTypingResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerStartTypingResponse;
};

export const getChattingControllerStartTypingMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerStartTyping>>,
		TError,
		{ data: ChatRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerStartTyping>>,
	TError,
	{ data: ChatRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerStartTyping"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerStartTyping>>,
		{ data: ChatRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerStartTyping(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerStartTypingMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerStartTyping>>
>;
export type ChattingControllerStartTypingMutationBody = ChatRequest;
export type ChattingControllerStartTypingMutationError = unknown;

export const useChattingControllerStartTyping = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerStartTyping>>,
			TError,
			{ data: ChatRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerStartTyping>>,
	TError,
	{ data: ChatRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerStartTypingMutationOptions(options),
		queryClient,
	);
};

export type chattingControllerStopTypingResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerStopTypingResponseSuccess =
	chattingControllerStopTypingResponse201 & {
		headers: Headers;
	};

export type chattingControllerStopTypingResponse =
	chattingControllerStopTypingResponseSuccess;

export const getChattingControllerStopTypingUrl = () => {
	return `https://waha.gnardawgs.surf/api/stopTyping`;
};

export const chattingControllerStopTyping = async (
	chatRequest: ChatRequest,
	options?: RequestInit,
): Promise<chattingControllerStopTypingResponse> => {
	const res = await fetch(getChattingControllerStopTypingUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(chatRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerStopTypingResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerStopTypingResponse;
};

export const getChattingControllerStopTypingMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerStopTyping>>,
		TError,
		{ data: ChatRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerStopTyping>>,
	TError,
	{ data: ChatRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerStopTyping"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerStopTyping>>,
		{ data: ChatRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerStopTyping(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerStopTypingMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerStopTyping>>
>;
export type ChattingControllerStopTypingMutationBody = ChatRequest;
export type ChattingControllerStopTypingMutationError = unknown;

export const useChattingControllerStopTyping = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerStopTyping>>,
			TError,
			{ data: ChatRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerStopTyping>>,
	TError,
	{ data: ChatRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerStopTypingMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary React to a message with an emoji
 */
export type chattingControllerSetReactionResponse200 = {
	data: ChattingControllerSetReaction200;
	status: 200;
};

export type chattingControllerSetReactionResponseSuccess =
	chattingControllerSetReactionResponse200 & {
		headers: Headers;
	};

export type chattingControllerSetReactionResponse =
	chattingControllerSetReactionResponseSuccess;

export const getChattingControllerSetReactionUrl = () => {
	return `https://waha.gnardawgs.surf/api/reaction`;
};

export const chattingControllerSetReaction = async (
	messageReactionRequest: MessageReactionRequest,
	options?: RequestInit,
): Promise<chattingControllerSetReactionResponse> => {
	const res = await fetch(getChattingControllerSetReactionUrl(), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageReactionRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSetReactionResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSetReactionResponse;
};

export const getChattingControllerSetReactionMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSetReaction>>,
		TError,
		{ data: MessageReactionRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSetReaction>>,
	TError,
	{ data: MessageReactionRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSetReaction"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSetReaction>>,
		{ data: MessageReactionRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSetReaction(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSetReactionMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSetReaction>>
>;
export type ChattingControllerSetReactionMutationBody = MessageReactionRequest;
export type ChattingControllerSetReactionMutationError = unknown;

/**
 * @summary React to a message with an emoji
 */
export const useChattingControllerSetReaction = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSetReaction>>,
			TError,
			{ data: MessageReactionRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSetReaction>>,
	TError,
	{ data: MessageReactionRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSetReactionMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Star or unstar a message
 */
export type chattingControllerSetStarResponse200 = {
	data: void;
	status: 200;
};

export type chattingControllerSetStarResponseSuccess =
	chattingControllerSetStarResponse200 & {
		headers: Headers;
	};

export type chattingControllerSetStarResponse =
	chattingControllerSetStarResponseSuccess;

export const getChattingControllerSetStarUrl = () => {
	return `https://waha.gnardawgs.surf/api/star`;
};

export const chattingControllerSetStar = async (
	messageStarRequest: MessageStarRequest,
	options?: RequestInit,
): Promise<chattingControllerSetStarResponse> => {
	const res = await fetch(getChattingControllerSetStarUrl(), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageStarRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSetStarResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSetStarResponse;
};

export const getChattingControllerSetStarMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSetStar>>,
		TError,
		{ data: MessageStarRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSetStar>>,
	TError,
	{ data: MessageStarRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSetStar"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSetStar>>,
		{ data: MessageStarRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSetStar(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSetStarMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSetStar>>
>;
export type ChattingControllerSetStarMutationBody = MessageStarRequest;
export type ChattingControllerSetStarMutationError = unknown;

/**
 * @summary Star or unstar a message
 */
export const useChattingControllerSetStar = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSetStar>>,
			TError,
			{ data: MessageStarRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSetStar>>,
	TError,
	{ data: MessageStarRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSetStarMutationOptions(options),
		queryClient,
	);
};

/**
 * You can use it as buttons or list replacement
 * @summary Send a poll with options
 */
export type chattingControllerSendPollResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerSendPollResponseSuccess =
	chattingControllerSendPollResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendPollResponse =
	chattingControllerSendPollResponseSuccess;

export const getChattingControllerSendPollUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendPoll`;
};

export const chattingControllerSendPoll = async (
	messagePollRequest: MessagePollRequest,
	options?: RequestInit,
): Promise<chattingControllerSendPollResponse> => {
	const res = await fetch(getChattingControllerSendPollUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messagePollRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendPollResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendPollResponse;
};

export const getChattingControllerSendPollMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendPoll>>,
		TError,
		{ data: MessagePollRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendPoll>>,
	TError,
	{ data: MessagePollRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendPoll"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendPoll>>,
		{ data: MessagePollRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendPoll(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendPollMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendPoll>>
>;
export type ChattingControllerSendPollMutationBody = MessagePollRequest;
export type ChattingControllerSendPollMutationError = unknown;

/**
 * @summary Send a poll with options
 */
export const useChattingControllerSendPoll = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendPoll>>,
			TError,
			{ data: MessagePollRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendPoll>>,
	TError,
	{ data: MessagePollRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendPollMutationOptions(options),
		queryClient,
	);
};

/**
 * Cast vote(s) on an existing poll message
 * @summary Vote on a poll
 */
export type chattingControllerSendPollVoteResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerSendPollVoteResponseSuccess =
	chattingControllerSendPollVoteResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendPollVoteResponse =
	chattingControllerSendPollVoteResponseSuccess;

export const getChattingControllerSendPollVoteUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendPollVote`;
};

export const chattingControllerSendPollVote = async (
	messagePollVoteRequest: MessagePollVoteRequest,
	options?: RequestInit,
): Promise<chattingControllerSendPollVoteResponse> => {
	const res = await fetch(getChattingControllerSendPollVoteUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messagePollVoteRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendPollVoteResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendPollVoteResponse;
};

export const getChattingControllerSendPollVoteMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendPollVote>>,
		TError,
		{ data: MessagePollVoteRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendPollVote>>,
	TError,
	{ data: MessagePollVoteRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendPollVote"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendPollVote>>,
		{ data: MessagePollVoteRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendPollVote(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendPollVoteMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendPollVote>>
>;
export type ChattingControllerSendPollVoteMutationBody = MessagePollVoteRequest;
export type ChattingControllerSendPollVoteMutationError = unknown;

/**
 * @summary Vote on a poll
 */
export const useChattingControllerSendPollVote = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendPollVote>>,
			TError,
			{ data: MessagePollVoteRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendPollVote>>,
	TError,
	{ data: MessagePollVoteRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendPollVoteMutationOptions(options),
		queryClient,
	);
};

export type chattingControllerSendLocationResponse201 = {
	data: ChattingControllerSendLocation201;
	status: 201;
};

export type chattingControllerSendLocationResponseSuccess =
	chattingControllerSendLocationResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendLocationResponse =
	chattingControllerSendLocationResponseSuccess;

export const getChattingControllerSendLocationUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendLocation`;
};

export const chattingControllerSendLocation = async (
	messageLocationRequest: MessageLocationRequest,
	options?: RequestInit,
): Promise<chattingControllerSendLocationResponse> => {
	const res = await fetch(getChattingControllerSendLocationUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageLocationRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendLocationResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendLocationResponse;
};

export const getChattingControllerSendLocationMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendLocation>>,
		TError,
		{ data: MessageLocationRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendLocation>>,
	TError,
	{ data: MessageLocationRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendLocation"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendLocation>>,
		{ data: MessageLocationRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendLocation(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendLocationMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendLocation>>
>;
export type ChattingControllerSendLocationMutationBody = MessageLocationRequest;
export type ChattingControllerSendLocationMutationError = unknown;

export const useChattingControllerSendLocation = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendLocation>>,
			TError,
			{ data: MessageLocationRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendLocation>>,
	TError,
	{ data: MessageLocationRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendLocationMutationOptions(options),
		queryClient,
	);
};

export type chattingControllerSendContactVcardResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerSendContactVcardResponseSuccess =
	chattingControllerSendContactVcardResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendContactVcardResponse =
	chattingControllerSendContactVcardResponseSuccess;

export const getChattingControllerSendContactVcardUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendContactVcard`;
};

export const chattingControllerSendContactVcard = async (
	messageContactVcardRequest: MessageContactVcardRequest,
	options?: RequestInit,
): Promise<chattingControllerSendContactVcardResponse> => {
	const res = await fetch(getChattingControllerSendContactVcardUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageContactVcardRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendContactVcardResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendContactVcardResponse;
};

export const getChattingControllerSendContactVcardMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendContactVcard>>,
		TError,
		{ data: MessageContactVcardRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendContactVcard>>,
	TError,
	{ data: MessageContactVcardRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendContactVcard"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendContactVcard>>,
		{ data: MessageContactVcardRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendContactVcard(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendContactVcardMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendContactVcard>>
>;
export type ChattingControllerSendContactVcardMutationBody =
	MessageContactVcardRequest;
export type ChattingControllerSendContactVcardMutationError = unknown;

export const useChattingControllerSendContactVcard = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendContactVcard>>,
			TError,
			{ data: MessageContactVcardRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendContactVcard>>,
	TError,
	{ data: MessageContactVcardRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendContactVcardMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Reply on a button message
 */
export type chattingControllerSendButtonsReplyResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerSendButtonsReplyResponseSuccess =
	chattingControllerSendButtonsReplyResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendButtonsReplyResponse =
	chattingControllerSendButtonsReplyResponseSuccess;

export const getChattingControllerSendButtonsReplyUrl = () => {
	return `https://waha.gnardawgs.surf/api/send/buttons/reply`;
};

export const chattingControllerSendButtonsReply = async (
	messageButtonReply: MessageButtonReply,
	options?: RequestInit,
): Promise<chattingControllerSendButtonsReplyResponse> => {
	const res = await fetch(getChattingControllerSendButtonsReplyUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageButtonReply),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendButtonsReplyResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendButtonsReplyResponse;
};

export const getChattingControllerSendButtonsReplyMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendButtonsReply>>,
		TError,
		{ data: MessageButtonReply },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendButtonsReply>>,
	TError,
	{ data: MessageButtonReply },
	TContext
> => {
	const mutationKey = ["chattingControllerSendButtonsReply"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendButtonsReply>>,
		{ data: MessageButtonReply }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendButtonsReply(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendButtonsReplyMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerSendButtonsReply>>
>;
export type ChattingControllerSendButtonsReplyMutationBody = MessageButtonReply;
export type ChattingControllerSendButtonsReplyMutationError = unknown;

/**
 * @summary Reply on a button message
 */
export const useChattingControllerSendButtonsReply = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendButtonsReply>>,
			TError,
			{ data: MessageButtonReply },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendButtonsReply>>,
	TError,
	{ data: MessageButtonReply },
	TContext
> => {
	return useMutation(
		getChattingControllerSendButtonsReplyMutationOptions(options),
		queryClient,
	);
};

/**
 * DEPRECATED. Use "GET /api/chats/{id}/messages" instead
 * @deprecated
 * @summary Get messages in a chat
 */
export type chattingControllerGetMessagesResponse200 = {
	data: WAMessage[];
	status: 200;
};

export type chattingControllerGetMessagesResponseSuccess =
	chattingControllerGetMessagesResponse200 & {
		headers: Headers;
	};

export type chattingControllerGetMessagesResponse =
	chattingControllerGetMessagesResponseSuccess;

export const getChattingControllerGetMessagesUrl = (
	params: ChattingControllerGetMessagesParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/messages?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/messages`;
};

export const chattingControllerGetMessages = async (
	params: ChattingControllerGetMessagesParams,
	options?: RequestInit,
): Promise<chattingControllerGetMessagesResponse> => {
	const res = await fetch(getChattingControllerGetMessagesUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerGetMessagesResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerGetMessagesResponse;
};

export const getChattingControllerGetMessagesQueryKey = (
	params?: ChattingControllerGetMessagesParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/messages`,
		...(params ? [params] : []),
	] as const;
};

export const getChattingControllerGetMessagesQueryOptions = <
	TData = Awaited<ReturnType<typeof chattingControllerGetMessages>>,
	TError = unknown,
>(
	params: ChattingControllerGetMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerGetMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getChattingControllerGetMessagesQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chattingControllerGetMessages>>
	> = ({ signal }) =>
		chattingControllerGetMessages(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof chattingControllerGetMessages>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChattingControllerGetMessagesQueryResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerGetMessages>>
>;
export type ChattingControllerGetMessagesQueryError = unknown;

export function useChattingControllerGetMessages<
	TData = Awaited<ReturnType<typeof chattingControllerGetMessages>>,
	TError = unknown,
>(
	params: ChattingControllerGetMessagesParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerGetMessages>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof chattingControllerGetMessages>>,
					TError,
					Awaited<ReturnType<typeof chattingControllerGetMessages>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChattingControllerGetMessages<
	TData = Awaited<ReturnType<typeof chattingControllerGetMessages>>,
	TError = unknown,
>(
	params: ChattingControllerGetMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerGetMessages>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof chattingControllerGetMessages>>,
					TError,
					Awaited<ReturnType<typeof chattingControllerGetMessages>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChattingControllerGetMessages<
	TData = Awaited<ReturnType<typeof chattingControllerGetMessages>>,
	TError = unknown,
>(
	params: ChattingControllerGetMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerGetMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary Get messages in a chat
 */

export function useChattingControllerGetMessages<
	TData = Awaited<ReturnType<typeof chattingControllerGetMessages>>,
	TError = unknown,
>(
	params: ChattingControllerGetMessagesParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chattingControllerGetMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChattingControllerGetMessagesQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * DEPRECATED. Use "POST /contacts/check-exists" instead
 * @deprecated
 * @summary Check number status
 */
export type chattingControllerDEPRECATEDCheckNumberStatusResponse200 = {
	data: WANumberExistResult;
	status: 200;
};

export type chattingControllerDEPRECATEDCheckNumberStatusResponseSuccess =
	chattingControllerDEPRECATEDCheckNumberStatusResponse200 & {
		headers: Headers;
	};

export type chattingControllerDEPRECATEDCheckNumberStatusResponse =
	chattingControllerDEPRECATEDCheckNumberStatusResponseSuccess;

export const getChattingControllerDEPRECATEDCheckNumberStatusUrl = (
	params: ChattingControllerDEPRECATEDCheckNumberStatusParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/checkNumberStatus?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/checkNumberStatus`;
};

export const chattingControllerDEPRECATEDCheckNumberStatus = async (
	params: ChattingControllerDEPRECATEDCheckNumberStatusParams,
	options?: RequestInit,
): Promise<chattingControllerDEPRECATEDCheckNumberStatusResponse> => {
	const res = await fetch(
		getChattingControllerDEPRECATEDCheckNumberStatusUrl(params),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerDEPRECATEDCheckNumberStatusResponse["data"] =
		body ? JSON.parse(body) : {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerDEPRECATEDCheckNumberStatusResponse;
};

export const getChattingControllerDEPRECATEDCheckNumberStatusQueryKey = (
	params?: ChattingControllerDEPRECATEDCheckNumberStatusParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/checkNumberStatus`,
		...(params ? [params] : []),
	] as const;
};

export const getChattingControllerDEPRECATEDCheckNumberStatusQueryOptions = <
	TData = Awaited<
		ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
	>,
	TError = unknown,
>(
	params: ChattingControllerDEPRECATEDCheckNumberStatusParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChattingControllerDEPRECATEDCheckNumberStatusQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>>
	> = ({ signal }) =>
		chattingControllerDEPRECATEDCheckNumberStatus(params, {
			signal,
			...fetchOptions,
		});

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChattingControllerDEPRECATEDCheckNumberStatusQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>>
	>;
export type ChattingControllerDEPRECATEDCheckNumberStatusQueryError = unknown;

export function useChattingControllerDEPRECATEDCheckNumberStatus<
	TData = Awaited<
		ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
	>,
	TError = unknown,
>(
	params: ChattingControllerDEPRECATEDCheckNumberStatusParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
					>,
					TError,
					Awaited<
						ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChattingControllerDEPRECATEDCheckNumberStatus<
	TData = Awaited<
		ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
	>,
	TError = unknown,
>(
	params: ChattingControllerDEPRECATEDCheckNumberStatusParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
					>,
					TError,
					Awaited<
						ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChattingControllerDEPRECATEDCheckNumberStatus<
	TData = Awaited<
		ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
	>,
	TError = unknown,
>(
	params: ChattingControllerDEPRECATEDCheckNumberStatusParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary Check number status
 */

export function useChattingControllerDEPRECATEDCheckNumberStatus<
	TData = Awaited<
		ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
	>,
	TError = unknown,
>(
	params: ChattingControllerDEPRECATEDCheckNumberStatusParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof chattingControllerDEPRECATEDCheckNumberStatus>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getChattingControllerDEPRECATEDCheckNumberStatusQueryOptions(
			params,
			options,
		);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @deprecated
 * @summary DEPRECATED - you can set "reply_to" field when sending text, image, etc
 */
export type chattingControllerReplyResponse201 = {
	data: ChattingControllerReply201;
	status: 201;
};

export type chattingControllerReplyResponseSuccess =
	chattingControllerReplyResponse201 & {
		headers: Headers;
	};

export type chattingControllerReplyResponse =
	chattingControllerReplyResponseSuccess;

export const getChattingControllerReplyUrl = () => {
	return `https://waha.gnardawgs.surf/api/reply`;
};

export const chattingControllerReply = async (
	messageReplyRequest: MessageReplyRequest,
	options?: RequestInit,
): Promise<chattingControllerReplyResponse> => {
	const res = await fetch(getChattingControllerReplyUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageReplyRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerReplyResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerReplyResponse;
};

export const getChattingControllerReplyMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerReply>>,
		TError,
		{ data: MessageReplyRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerReply>>,
	TError,
	{ data: MessageReplyRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerReply"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerReply>>,
		{ data: MessageReplyRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerReply(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerReplyMutationResult = NonNullable<
	Awaited<ReturnType<typeof chattingControllerReply>>
>;
export type ChattingControllerReplyMutationBody = MessageReplyRequest;
export type ChattingControllerReplyMutationError = unknown;

/**
 * @deprecated
 * @summary DEPRECATED - you can set "reply_to" field when sending text, image, etc
 */
export const useChattingControllerReply = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerReply>>,
			TError,
			{ data: MessageReplyRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerReply>>,
	TError,
	{ data: MessageReplyRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerReplyMutationOptions(options),
		queryClient,
	);
};

/**
 * @deprecated
 */
export type chattingControllerSendLinkPreviewDEPRECATEDResponse201 = {
	data: void;
	status: 201;
};

export type chattingControllerSendLinkPreviewDEPRECATEDResponseSuccess =
	chattingControllerSendLinkPreviewDEPRECATEDResponse201 & {
		headers: Headers;
	};

export type chattingControllerSendLinkPreviewDEPRECATEDResponse =
	chattingControllerSendLinkPreviewDEPRECATEDResponseSuccess;

export const getChattingControllerSendLinkPreviewDEPRECATEDUrl = () => {
	return `https://waha.gnardawgs.surf/api/sendLinkPreview`;
};

export const chattingControllerSendLinkPreviewDEPRECATED = async (
	messageLinkPreviewRequest: MessageLinkPreviewRequest,
	options?: RequestInit,
): Promise<chattingControllerSendLinkPreviewDEPRECATEDResponse> => {
	const res = await fetch(getChattingControllerSendLinkPreviewDEPRECATEDUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(messageLinkPreviewRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chattingControllerSendLinkPreviewDEPRECATEDResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chattingControllerSendLinkPreviewDEPRECATEDResponse;
};

export const getChattingControllerSendLinkPreviewDEPRECATEDMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chattingControllerSendLinkPreviewDEPRECATED>>,
		TError,
		{ data: MessageLinkPreviewRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chattingControllerSendLinkPreviewDEPRECATED>>,
	TError,
	{ data: MessageLinkPreviewRequest },
	TContext
> => {
	const mutationKey = ["chattingControllerSendLinkPreviewDEPRECATED"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chattingControllerSendLinkPreviewDEPRECATED>>,
		{ data: MessageLinkPreviewRequest }
	> = (props) => {
		const { data } = props ?? {};

		return chattingControllerSendLinkPreviewDEPRECATED(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChattingControllerSendLinkPreviewDEPRECATEDMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof chattingControllerSendLinkPreviewDEPRECATED>>
	>;
export type ChattingControllerSendLinkPreviewDEPRECATEDMutationBody =
	MessageLinkPreviewRequest;
export type ChattingControllerSendLinkPreviewDEPRECATEDMutationError = unknown;

/**
 * @deprecated
 */
export const useChattingControllerSendLinkPreviewDEPRECATED = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chattingControllerSendLinkPreviewDEPRECATED>>,
			TError,
			{ data: MessageLinkPreviewRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chattingControllerSendLinkPreviewDEPRECATED>>,
	TError,
	{ data: MessageLinkPreviewRequest },
	TContext
> => {
	return useMutation(
		getChattingControllerSendLinkPreviewDEPRECATEDMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get chats
 */
export type chatsControllerGetChatsResponse200 = {
	data: void;
	status: 200;
};

export type chatsControllerGetChatsResponseSuccess =
	chatsControllerGetChatsResponse200 & {
		headers: Headers;
	};

export type chatsControllerGetChatsResponse =
	chatsControllerGetChatsResponseSuccess;

export const getChatsControllerGetChatsUrl = (
	params?: ChatsControllerGetChatsParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/chats?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/chats`;
};

export const chatsControllerGetChats = async (
	params?: ChatsControllerGetChatsParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerGetChatsResponse> => {
	const res = await fetch(getChatsControllerGetChatsUrl(params, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerGetChatsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerGetChatsResponse;
};

export const getChatsControllerGetChatsQueryKey = (
	params?: ChatsControllerGetChatsParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/chats`,
		...(params ? [params] : []),
	] as const;
};

export const getChatsControllerGetChatsQueryOptions = <
	TData = Awaited<ReturnType<typeof chatsControllerGetChats>>,
	TError = unknown,
>(
	params?: ChatsControllerGetChatsParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChats>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChatsControllerGetChatsQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chatsControllerGetChats>>
	> = ({ signal }) =>
		chatsControllerGetChats(params, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof chatsControllerGetChats>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChatsControllerGetChatsQueryResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerGetChats>>
>;
export type ChatsControllerGetChatsQueryError = unknown;

export function useChatsControllerGetChats<
	TData = Awaited<ReturnType<typeof chatsControllerGetChats>>,
	TError = unknown,
>(
	params: undefined | ChatsControllerGetChatsParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChats>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChats>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChats>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChats<
	TData = Awaited<ReturnType<typeof chatsControllerGetChats>>,
	TError = unknown,
>(
	params?: ChatsControllerGetChatsParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChats>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChats>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChats>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChats<
	TData = Awaited<ReturnType<typeof chatsControllerGetChats>>,
	TError = unknown,
>(
	params?: ChatsControllerGetChatsParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChats>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get chats
 */

export function useChatsControllerGetChats<
	TData = Awaited<ReturnType<typeof chatsControllerGetChats>>,
	TError = unknown,
>(
	params?: ChatsControllerGetChatsParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChats>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChatsControllerGetChatsQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get chats overview. Includes all necessary things to build UI "your chats overview" page - chat id, name, picture, last message. Sorting by last message timestamp
 */
export type chatsControllerGetChatsOverviewResponse200 = {
	data: ChatSummary[];
	status: 200;
};

export type chatsControllerGetChatsOverviewResponseSuccess =
	chatsControllerGetChatsOverviewResponse200 & {
		headers: Headers;
	};

export type chatsControllerGetChatsOverviewResponse =
	chatsControllerGetChatsOverviewResponseSuccess;

export const getChatsControllerGetChatsOverviewUrl = (
	params?: ChatsControllerGetChatsOverviewParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/chats/overview?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/chats/overview`;
};

export const chatsControllerGetChatsOverview = async (
	params?: ChatsControllerGetChatsOverviewParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerGetChatsOverviewResponse> => {
	const res = await fetch(
		getChatsControllerGetChatsOverviewUrl(params, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerGetChatsOverviewResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerGetChatsOverviewResponse;
};

export const getChatsControllerGetChatsOverviewQueryKey = (
	params?: ChatsControllerGetChatsOverviewParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/chats/overview`,
		...(params ? [params] : []),
	] as const;
};

export const getChatsControllerGetChatsOverviewQueryOptions = <
	TData = Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
	TError = unknown,
>(
	params?: ChatsControllerGetChatsOverviewParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChatsControllerGetChatsOverviewQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>
	> = ({ signal }) =>
		chatsControllerGetChatsOverview(params, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChatsControllerGetChatsOverviewQueryResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>
>;
export type ChatsControllerGetChatsOverviewQueryError = unknown;

export function useChatsControllerGetChatsOverview<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
	TError = unknown,
>(
	params: undefined | ChatsControllerGetChatsOverviewParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChatsOverview<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
	TError = unknown,
>(
	params?: ChatsControllerGetChatsOverviewParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChatsOverview<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
	TError = unknown,
>(
	params?: ChatsControllerGetChatsOverviewParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get chats overview. Includes all necessary things to build UI "your chats overview" page - chat id, name, picture, last message. Sorting by last message timestamp
 */

export function useChatsControllerGetChatsOverview<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
	TError = unknown,
>(
	params?: ChatsControllerGetChatsOverviewParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatsOverview>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChatsControllerGetChatsOverviewQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get chats overview. Use POST if you have too many "ids" params - GET can limit it
 */
export type chatsControllerPostChatsOverviewResponse201 = {
	data: ChatSummary[];
	status: 201;
};

export type chatsControllerPostChatsOverviewResponseSuccess =
	chatsControllerPostChatsOverviewResponse201 & {
		headers: Headers;
	};

export type chatsControllerPostChatsOverviewResponse =
	chatsControllerPostChatsOverviewResponseSuccess;

export const getChatsControllerPostChatsOverviewUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/overview`;
};

export const chatsControllerPostChatsOverview = async (
	overviewBodyRequest: OverviewBodyRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerPostChatsOverviewResponse> => {
	const res = await fetch(getChatsControllerPostChatsOverviewUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(overviewBodyRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerPostChatsOverviewResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerPostChatsOverviewResponse;
};

export const getChatsControllerPostChatsOverviewMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerPostChatsOverview>>,
		TError,
		{ data: OverviewBodyRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerPostChatsOverview>>,
	TError,
	{ data: OverviewBodyRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["chatsControllerPostChatsOverview"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerPostChatsOverview>>,
		{ data: OverviewBodyRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return chatsControllerPostChatsOverview(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerPostChatsOverviewMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerPostChatsOverview>>
>;
export type ChatsControllerPostChatsOverviewMutationBody = OverviewBodyRequest;
export type ChatsControllerPostChatsOverviewMutationError = unknown;

/**
 * @summary Get chats overview. Use POST if you have too many "ids" params - GET can limit it
 */
export const useChatsControllerPostChatsOverview = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerPostChatsOverview>>,
			TError,
			{ data: OverviewBodyRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerPostChatsOverview>>,
	TError,
	{ data: OverviewBodyRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getChatsControllerPostChatsOverviewMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Deletes the chat
 */
export type chatsControllerDeleteChatResponse200 = {
	data: void;
	status: 200;
};

export type chatsControllerDeleteChatResponseSuccess =
	chatsControllerDeleteChatResponse200 & {
		headers: Headers;
	};

export type chatsControllerDeleteChatResponse =
	chatsControllerDeleteChatResponseSuccess;

export const getChatsControllerDeleteChatUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}`;
};

export const chatsControllerDeleteChat = async (
	chatId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerDeleteChatResponse> => {
	const res = await fetch(getChatsControllerDeleteChatUrl(chatId, session), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerDeleteChatResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerDeleteChatResponse;
};

export const getChatsControllerDeleteChatMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerDeleteChat>>,
		TError,
		{ chatId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerDeleteChat>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["chatsControllerDeleteChat"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerDeleteChat>>,
		{ chatId: string; session?: unknown }
	> = (props) => {
		const { chatId, session } = props ?? {};

		return chatsControllerDeleteChat(chatId, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerDeleteChatMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerDeleteChat>>
>;

export type ChatsControllerDeleteChatMutationError = unknown;

/**
 * @summary Deletes the chat
 */
export const useChatsControllerDeleteChat = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerDeleteChat>>,
			TError,
			{ chatId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerDeleteChat>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getChatsControllerDeleteChatMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Gets chat picture
 */
export type chatsControllerGetChatPictureResponse200 = {
	data: ChatPictureResponse;
	status: 200;
};

export type chatsControllerGetChatPictureResponseSuccess =
	chatsControllerGetChatPictureResponse200 & {
		headers: Headers;
	};

export type chatsControllerGetChatPictureResponse =
	chatsControllerGetChatPictureResponseSuccess;

export const getChatsControllerGetChatPictureUrl = (
	chatId: string,
	params?: ChatsControllerGetChatPictureParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/picture?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/picture`;
};

export const chatsControllerGetChatPicture = async (
	chatId: string,
	params?: ChatsControllerGetChatPictureParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerGetChatPictureResponse> => {
	const res = await fetch(
		getChatsControllerGetChatPictureUrl(chatId, params, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerGetChatPictureResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerGetChatPictureResponse;
};

export const getChatsControllerGetChatPictureQueryKey = (
	chatId: string,
	params?: ChatsControllerGetChatPictureParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/picture`,
		...(params ? [params] : []),
	] as const;
};

export const getChatsControllerGetChatPictureQueryOptions = <
	TData = Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
	TError = unknown,
>(
	chatId: string,
	params?: ChatsControllerGetChatPictureParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChatsControllerGetChatPictureQueryKey(chatId, params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chatsControllerGetChatPicture>>
	> = ({ signal }) =>
		chatsControllerGetChatPicture(chatId, params, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && chatId),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChatsControllerGetChatPictureQueryResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerGetChatPicture>>
>;
export type ChatsControllerGetChatPictureQueryError = unknown;

export function useChatsControllerGetChatPicture<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
	TError = unknown,
>(
	chatId: string,
	params: undefined | ChatsControllerGetChatPictureParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChatPicture>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChatPicture<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
	TError = unknown,
>(
	chatId: string,
	params?: ChatsControllerGetChatPictureParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChatPicture>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChatPicture<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
	TError = unknown,
>(
	chatId: string,
	params?: ChatsControllerGetChatPictureParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets chat picture
 */

export function useChatsControllerGetChatPicture<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
	TError = unknown,
>(
	chatId: string,
	params?: ChatsControllerGetChatPictureParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatPicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChatsControllerGetChatPictureQueryOptions(
		chatId,
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Gets messages in the chat
 */
export type chatsControllerGetChatMessagesResponse200 = {
	data: WAMessage[];
	status: 200;
};

export type chatsControllerGetChatMessagesResponseSuccess =
	chatsControllerGetChatMessagesResponse200 & {
		headers: Headers;
	};

export type chatsControllerGetChatMessagesResponse =
	chatsControllerGetChatMessagesResponseSuccess;

export const getChatsControllerGetChatMessagesUrl = (
	chatId: string,
	params: ChatsControllerGetChatMessagesParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages`;
};

export const chatsControllerGetChatMessages = async (
	chatId: string,
	params: ChatsControllerGetChatMessagesParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerGetChatMessagesResponse> => {
	const res = await fetch(
		getChatsControllerGetChatMessagesUrl(chatId, params, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerGetChatMessagesResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerGetChatMessagesResponse;
};

export const getChatsControllerGetChatMessagesQueryKey = (
	chatId: string,
	params?: ChatsControllerGetChatMessagesParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages`,
		...(params ? [params] : []),
	] as const;
};

export const getChatsControllerGetChatMessagesQueryOptions = <
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
	TError = unknown,
>(
	chatId: string,
	params: ChatsControllerGetChatMessagesParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChatsControllerGetChatMessagesQueryKey(chatId, params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chatsControllerGetChatMessages>>
	> = ({ signal }) =>
		chatsControllerGetChatMessages(chatId, params, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && chatId),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChatsControllerGetChatMessagesQueryResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerGetChatMessages>>
>;
export type ChatsControllerGetChatMessagesQueryError = unknown;

export function useChatsControllerGetChatMessages<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
	TError = unknown,
>(
	chatId: string,
	params: ChatsControllerGetChatMessagesParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChatMessages>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChatMessages<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
	TError = unknown,
>(
	chatId: string,
	params: ChatsControllerGetChatMessagesParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChatMessages>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChatMessages<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
	TError = unknown,
>(
	chatId: string,
	params: ChatsControllerGetChatMessagesParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets messages in the chat
 */

export function useChatsControllerGetChatMessages<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
	TError = unknown,
>(
	chatId: string,
	params: ChatsControllerGetChatMessagesParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChatsControllerGetChatMessagesQueryOptions(
		chatId,
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Clears all messages from the chat
 */
export type chatsControllerClearMessagesResponse200 = {
	data: void;
	status: 200;
};

export type chatsControllerClearMessagesResponseSuccess =
	chatsControllerClearMessagesResponse200 & {
		headers: Headers;
	};

export type chatsControllerClearMessagesResponse =
	chatsControllerClearMessagesResponseSuccess;

export const getChatsControllerClearMessagesUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages`;
};

export const chatsControllerClearMessages = async (
	chatId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerClearMessagesResponse> => {
	const res = await fetch(getChatsControllerClearMessagesUrl(chatId, session), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerClearMessagesResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerClearMessagesResponse;
};

export const getChatsControllerClearMessagesMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerClearMessages>>,
		TError,
		{ chatId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerClearMessages>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["chatsControllerClearMessages"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerClearMessages>>,
		{ chatId: string; session?: unknown }
	> = (props) => {
		const { chatId, session } = props ?? {};

		return chatsControllerClearMessages(chatId, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerClearMessagesMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerClearMessages>>
>;

export type ChatsControllerClearMessagesMutationError = unknown;

/**
 * @summary Clears all messages from the chat
 */
export const useChatsControllerClearMessages = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerClearMessages>>,
			TError,
			{ chatId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerClearMessages>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getChatsControllerClearMessagesMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Read unread messages in the chat
 */
export type chatsControllerReadChatMessagesResponse201 = {
	data: ReadChatMessagesResponse;
	status: 201;
};

export type chatsControllerReadChatMessagesResponseSuccess =
	chatsControllerReadChatMessagesResponse201 & {
		headers: Headers;
	};

export type chatsControllerReadChatMessagesResponse =
	chatsControllerReadChatMessagesResponseSuccess;

export const getChatsControllerReadChatMessagesUrl = (
	chatId: string,
	params?: ChatsControllerReadChatMessagesParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/read?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/read`;
};

export const chatsControllerReadChatMessages = async (
	chatId: string,
	params?: ChatsControllerReadChatMessagesParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerReadChatMessagesResponse> => {
	const res = await fetch(
		getChatsControllerReadChatMessagesUrl(chatId, params, session),
		{
			...options,
			method: "POST",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerReadChatMessagesResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerReadChatMessagesResponse;
};

export const getChatsControllerReadChatMessagesMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerReadChatMessages>>,
		TError,
		{
			chatId: string;
			params?: ChatsControllerReadChatMessagesParams;
			session?: unknown;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerReadChatMessages>>,
	TError,
	{
		chatId: string;
		params?: ChatsControllerReadChatMessagesParams;
		session?: unknown;
	},
	TContext
> => {
	const mutationKey = ["chatsControllerReadChatMessages"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerReadChatMessages>>,
		{
			chatId: string;
			params?: ChatsControllerReadChatMessagesParams;
			session?: unknown;
		}
	> = (props) => {
		const { chatId, params, session } = props ?? {};

		return chatsControllerReadChatMessages(
			chatId,
			params,
			session,
			fetchOptions,
		);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerReadChatMessagesMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerReadChatMessages>>
>;

export type ChatsControllerReadChatMessagesMutationError = unknown;

/**
 * @summary Read unread messages in the chat
 */
export const useChatsControllerReadChatMessages = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerReadChatMessages>>,
			TError,
			{
				chatId: string;
				params?: ChatsControllerReadChatMessagesParams;
				session?: unknown;
			},
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerReadChatMessages>>,
	TError,
	{
		chatId: string;
		params?: ChatsControllerReadChatMessagesParams;
		session?: unknown;
	},
	TContext
> => {
	return useMutation(
		getChatsControllerReadChatMessagesMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Gets message by id
 */
export type chatsControllerGetChatMessageResponse200 = {
	data: WAMessage;
	status: 200;
};

export type chatsControllerGetChatMessageResponseSuccess =
	chatsControllerGetChatMessageResponse200 & {
		headers: Headers;
	};

export type chatsControllerGetChatMessageResponse =
	chatsControllerGetChatMessageResponseSuccess;

export const getChatsControllerGetChatMessageUrl = (
	chatId: string,
	messageId: string,
	params?: ChatsControllerGetChatMessageParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/${messageId}?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/${messageId}`;
};

export const chatsControllerGetChatMessage = async (
	chatId: string,
	messageId: string,
	params?: ChatsControllerGetChatMessageParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerGetChatMessageResponse> => {
	const res = await fetch(
		getChatsControllerGetChatMessageUrl(chatId, messageId, params, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerGetChatMessageResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerGetChatMessageResponse;
};

export const getChatsControllerGetChatMessageQueryKey = (
	chatId: string,
	messageId: string,
	params?: ChatsControllerGetChatMessageParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/${messageId}`,
		...(params ? [params] : []),
	] as const;
};

export const getChatsControllerGetChatMessageQueryOptions = <
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
	TError = unknown,
>(
	chatId: string,
	messageId: string,
	params?: ChatsControllerGetChatMessageParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChatsControllerGetChatMessageQueryKey(
			chatId,
			messageId,
			params,
			session,
		);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chatsControllerGetChatMessage>>
	> = ({ signal }) =>
		chatsControllerGetChatMessage(chatId, messageId, params, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && chatId && messageId),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChatsControllerGetChatMessageQueryResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerGetChatMessage>>
>;
export type ChatsControllerGetChatMessageQueryError = unknown;

export function useChatsControllerGetChatMessage<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
	TError = unknown,
>(
	chatId: string,
	messageId: string,
	params: undefined | ChatsControllerGetChatMessageParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChatMessage>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChatMessage<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
	TError = unknown,
>(
	chatId: string,
	messageId: string,
	params?: ChatsControllerGetChatMessageParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
					TError,
					Awaited<ReturnType<typeof chatsControllerGetChatMessage>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatsControllerGetChatMessage<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
	TError = unknown,
>(
	chatId: string,
	messageId: string,
	params?: ChatsControllerGetChatMessageParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets message by id
 */

export function useChatsControllerGetChatMessage<
	TData = Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
	TError = unknown,
>(
	chatId: string,
	messageId: string,
	params?: ChatsControllerGetChatMessageParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatsControllerGetChatMessage>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChatsControllerGetChatMessageQueryOptions(
		chatId,
		messageId,
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Deletes a message from the chat
 */
export type chatsControllerDeleteMessageResponse200 = {
	data: void;
	status: 200;
};

export type chatsControllerDeleteMessageResponseSuccess =
	chatsControllerDeleteMessageResponse200 & {
		headers: Headers;
	};

export type chatsControllerDeleteMessageResponse =
	chatsControllerDeleteMessageResponseSuccess;

export const getChatsControllerDeleteMessageUrl = (
	chatId: string,
	messageId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/${messageId}`;
};

export const chatsControllerDeleteMessage = async (
	chatId: string,
	messageId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerDeleteMessageResponse> => {
	const res = await fetch(
		getChatsControllerDeleteMessageUrl(chatId, messageId, session),
		{
			...options,
			method: "DELETE",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerDeleteMessageResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerDeleteMessageResponse;
};

export const getChatsControllerDeleteMessageMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerDeleteMessage>>,
		TError,
		{ chatId: string; messageId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerDeleteMessage>>,
	TError,
	{ chatId: string; messageId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["chatsControllerDeleteMessage"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerDeleteMessage>>,
		{ chatId: string; messageId: string; session?: unknown }
	> = (props) => {
		const { chatId, messageId, session } = props ?? {};

		return chatsControllerDeleteMessage(
			chatId,
			messageId,
			session,
			fetchOptions,
		);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerDeleteMessageMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerDeleteMessage>>
>;

export type ChatsControllerDeleteMessageMutationError = unknown;

/**
 * @summary Deletes a message from the chat
 */
export const useChatsControllerDeleteMessage = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerDeleteMessage>>,
			TError,
			{ chatId: string; messageId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerDeleteMessage>>,
	TError,
	{ chatId: string; messageId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getChatsControllerDeleteMessageMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Edits a message in the chat
 */
export type chatsControllerEditMessageResponse200 = {
	data: void;
	status: 200;
};

export type chatsControllerEditMessageResponseSuccess =
	chatsControllerEditMessageResponse200 & {
		headers: Headers;
	};

export type chatsControllerEditMessageResponse =
	chatsControllerEditMessageResponseSuccess;

export const getChatsControllerEditMessageUrl = (
	chatId: string,
	messageId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/${messageId}`;
};

export const chatsControllerEditMessage = async (
	chatId: string,
	messageId: string,
	editMessageRequest: EditMessageRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerEditMessageResponse> => {
	const res = await fetch(
		getChatsControllerEditMessageUrl(chatId, messageId, session),
		{
			...options,
			method: "PUT",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(editMessageRequest),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerEditMessageResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerEditMessageResponse;
};

export const getChatsControllerEditMessageMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerEditMessage>>,
		TError,
		{
			chatId: string;
			messageId: string;
			data: EditMessageRequest;
			session?: unknown;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerEditMessage>>,
	TError,
	{
		chatId: string;
		messageId: string;
		data: EditMessageRequest;
		session?: unknown;
	},
	TContext
> => {
	const mutationKey = ["chatsControllerEditMessage"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerEditMessage>>,
		{
			chatId: string;
			messageId: string;
			data: EditMessageRequest;
			session?: unknown;
		}
	> = (props) => {
		const { chatId, messageId, data, session } = props ?? {};

		return chatsControllerEditMessage(
			chatId,
			messageId,
			data,
			session,
			fetchOptions,
		);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerEditMessageMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerEditMessage>>
>;
export type ChatsControllerEditMessageMutationBody = EditMessageRequest;
export type ChatsControllerEditMessageMutationError = unknown;

/**
 * @summary Edits a message in the chat
 */
export const useChatsControllerEditMessage = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerEditMessage>>,
			TError,
			{
				chatId: string;
				messageId: string;
				data: EditMessageRequest;
				session?: unknown;
			},
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerEditMessage>>,
	TError,
	{
		chatId: string;
		messageId: string;
		data: EditMessageRequest;
		session?: unknown;
	},
	TContext
> => {
	return useMutation(
		getChatsControllerEditMessageMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Pins a message in the chat
 */
export type chatsControllerPinMessageResponse201 = {
	data: void;
	status: 201;
};

export type chatsControllerPinMessageResponseSuccess =
	chatsControllerPinMessageResponse201 & {
		headers: Headers;
	};

export type chatsControllerPinMessageResponse =
	chatsControllerPinMessageResponseSuccess;

export const getChatsControllerPinMessageUrl = (
	chatId: string,
	messageId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/${messageId}/pin`;
};

export const chatsControllerPinMessage = async (
	chatId: string,
	messageId: string,
	pinMessageRequest: PinMessageRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerPinMessageResponse> => {
	const res = await fetch(
		getChatsControllerPinMessageUrl(chatId, messageId, session),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(pinMessageRequest),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerPinMessageResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerPinMessageResponse;
};

export const getChatsControllerPinMessageMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerPinMessage>>,
		TError,
		{
			chatId: string;
			messageId: string;
			data: PinMessageRequest;
			session?: unknown;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerPinMessage>>,
	TError,
	{
		chatId: string;
		messageId: string;
		data: PinMessageRequest;
		session?: unknown;
	},
	TContext
> => {
	const mutationKey = ["chatsControllerPinMessage"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerPinMessage>>,
		{
			chatId: string;
			messageId: string;
			data: PinMessageRequest;
			session?: unknown;
		}
	> = (props) => {
		const { chatId, messageId, data, session } = props ?? {};

		return chatsControllerPinMessage(
			chatId,
			messageId,
			data,
			session,
			fetchOptions,
		);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerPinMessageMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerPinMessage>>
>;
export type ChatsControllerPinMessageMutationBody = PinMessageRequest;
export type ChatsControllerPinMessageMutationError = unknown;

/**
 * @summary Pins a message in the chat
 */
export const useChatsControllerPinMessage = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerPinMessage>>,
			TError,
			{
				chatId: string;
				messageId: string;
				data: PinMessageRequest;
				session?: unknown;
			},
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerPinMessage>>,
	TError,
	{
		chatId: string;
		messageId: string;
		data: PinMessageRequest;
		session?: unknown;
	},
	TContext
> => {
	return useMutation(
		getChatsControllerPinMessageMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Unpins a message in the chat
 */
export type chatsControllerUnpinMessageResponse201 = {
	data: void;
	status: 201;
};

export type chatsControllerUnpinMessageResponseSuccess =
	chatsControllerUnpinMessageResponse201 & {
		headers: Headers;
	};

export type chatsControllerUnpinMessageResponse =
	chatsControllerUnpinMessageResponseSuccess;

export const getChatsControllerUnpinMessageUrl = (
	chatId: string,
	messageId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/messages/${messageId}/unpin`;
};

export const chatsControllerUnpinMessage = async (
	chatId: string,
	messageId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerUnpinMessageResponse> => {
	const res = await fetch(
		getChatsControllerUnpinMessageUrl(chatId, messageId, session),
		{
			...options,
			method: "POST",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerUnpinMessageResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerUnpinMessageResponse;
};

export const getChatsControllerUnpinMessageMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerUnpinMessage>>,
		TError,
		{ chatId: string; messageId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerUnpinMessage>>,
	TError,
	{ chatId: string; messageId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["chatsControllerUnpinMessage"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerUnpinMessage>>,
		{ chatId: string; messageId: string; session?: unknown }
	> = (props) => {
		const { chatId, messageId, session } = props ?? {};

		return chatsControllerUnpinMessage(
			chatId,
			messageId,
			session,
			fetchOptions,
		);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerUnpinMessageMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerUnpinMessage>>
>;

export type ChatsControllerUnpinMessageMutationError = unknown;

/**
 * @summary Unpins a message in the chat
 */
export const useChatsControllerUnpinMessage = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerUnpinMessage>>,
			TError,
			{ chatId: string; messageId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerUnpinMessage>>,
	TError,
	{ chatId: string; messageId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getChatsControllerUnpinMessageMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Archive the chat
 */
export type chatsControllerArchiveChatResponse201 = {
	data: ChatsControllerArchiveChat201;
	status: 201;
};

export type chatsControllerArchiveChatResponseSuccess =
	chatsControllerArchiveChatResponse201 & {
		headers: Headers;
	};

export type chatsControllerArchiveChatResponse =
	chatsControllerArchiveChatResponseSuccess;

export const getChatsControllerArchiveChatUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/archive`;
};

export const chatsControllerArchiveChat = async (
	chatId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerArchiveChatResponse> => {
	const res = await fetch(getChatsControllerArchiveChatUrl(chatId, session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerArchiveChatResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerArchiveChatResponse;
};

export const getChatsControllerArchiveChatMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerArchiveChat>>,
		TError,
		{ chatId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerArchiveChat>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["chatsControllerArchiveChat"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerArchiveChat>>,
		{ chatId: string; session?: unknown }
	> = (props) => {
		const { chatId, session } = props ?? {};

		return chatsControllerArchiveChat(chatId, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerArchiveChatMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerArchiveChat>>
>;

export type ChatsControllerArchiveChatMutationError = unknown;

/**
 * @summary Archive the chat
 */
export const useChatsControllerArchiveChat = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerArchiveChat>>,
			TError,
			{ chatId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerArchiveChat>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getChatsControllerArchiveChatMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Unarchive the chat
 */
export type chatsControllerUnarchiveChatResponse201 = {
	data: ChatsControllerUnarchiveChat201;
	status: 201;
};

export type chatsControllerUnarchiveChatResponseSuccess =
	chatsControllerUnarchiveChatResponse201 & {
		headers: Headers;
	};

export type chatsControllerUnarchiveChatResponse =
	chatsControllerUnarchiveChatResponseSuccess;

export const getChatsControllerUnarchiveChatUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/unarchive`;
};

export const chatsControllerUnarchiveChat = async (
	chatId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerUnarchiveChatResponse> => {
	const res = await fetch(getChatsControllerUnarchiveChatUrl(chatId, session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerUnarchiveChatResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerUnarchiveChatResponse;
};

export const getChatsControllerUnarchiveChatMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerUnarchiveChat>>,
		TError,
		{ chatId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerUnarchiveChat>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["chatsControllerUnarchiveChat"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerUnarchiveChat>>,
		{ chatId: string; session?: unknown }
	> = (props) => {
		const { chatId, session } = props ?? {};

		return chatsControllerUnarchiveChat(chatId, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerUnarchiveChatMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerUnarchiveChat>>
>;

export type ChatsControllerUnarchiveChatMutationError = unknown;

/**
 * @summary Unarchive the chat
 */
export const useChatsControllerUnarchiveChat = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerUnarchiveChat>>,
			TError,
			{ chatId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerUnarchiveChat>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getChatsControllerUnarchiveChatMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Unread the chat
 */
export type chatsControllerUnreadChatResponse201 = {
	data: ChatsControllerUnreadChat201;
	status: 201;
};

export type chatsControllerUnreadChatResponseSuccess =
	chatsControllerUnreadChatResponse201 & {
		headers: Headers;
	};

export type chatsControllerUnreadChatResponse =
	chatsControllerUnreadChatResponseSuccess;

export const getChatsControllerUnreadChatUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/chats/${chatId}/unread`;
};

export const chatsControllerUnreadChat = async (
	chatId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<chatsControllerUnreadChatResponse> => {
	const res = await fetch(getChatsControllerUnreadChatUrl(chatId, session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatsControllerUnreadChatResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatsControllerUnreadChatResponse;
};

export const getChatsControllerUnreadChatMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof chatsControllerUnreadChat>>,
		TError,
		{ chatId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof chatsControllerUnreadChat>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["chatsControllerUnreadChat"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof chatsControllerUnreadChat>>,
		{ chatId: string; session?: unknown }
	> = (props) => {
		const { chatId, session } = props ?? {};

		return chatsControllerUnreadChat(chatId, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChatsControllerUnreadChatMutationResult = NonNullable<
	Awaited<ReturnType<typeof chatsControllerUnreadChat>>
>;

export type ChatsControllerUnreadChatMutationError = unknown;

/**
 * @summary Unread the chat
 */
export const useChatsControllerUnreadChat = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof chatsControllerUnreadChat>>,
			TError,
			{ chatId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof chatsControllerUnreadChat>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getChatsControllerUnreadChatMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Reject incoming call
 */
export type callsControllerRejectCallResponse201 = {
	data: void;
	status: 201;
};

export type callsControllerRejectCallResponseSuccess =
	callsControllerRejectCallResponse201 & {
		headers: Headers;
	};

export type callsControllerRejectCallResponse =
	callsControllerRejectCallResponseSuccess;

export const getCallsControllerRejectCallUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/calls/reject`;
};

export const callsControllerRejectCall = async (
	rejectCallRequest: RejectCallRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<callsControllerRejectCallResponse> => {
	const res = await fetch(getCallsControllerRejectCallUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(rejectCallRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: callsControllerRejectCallResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as callsControllerRejectCallResponse;
};

export const getCallsControllerRejectCallMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof callsControllerRejectCall>>,
		TError,
		{ data: RejectCallRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof callsControllerRejectCall>>,
	TError,
	{ data: RejectCallRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["callsControllerRejectCall"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof callsControllerRejectCall>>,
		{ data: RejectCallRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return callsControllerRejectCall(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CallsControllerRejectCallMutationResult = NonNullable<
	Awaited<ReturnType<typeof callsControllerRejectCall>>
>;
export type CallsControllerRejectCallMutationBody = RejectCallRequest;
export type CallsControllerRejectCallMutationError = unknown;

/**
 * @summary Reject incoming call
 */
export const useCallsControllerRejectCall = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof callsControllerRejectCall>>,
			TError,
			{ data: RejectCallRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof callsControllerRejectCall>>,
	TError,
	{ data: RejectCallRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getCallsControllerRejectCallMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get list of know channels
 */
export type channelsControllerListResponse200 = {
	data: Channel[];
	status: 200;
};

export type channelsControllerListResponseSuccess =
	channelsControllerListResponse200 & {
		headers: Headers;
	};

export type channelsControllerListResponse =
	channelsControllerListResponseSuccess;

export const getChannelsControllerListUrl = (
	params?: ChannelsControllerListParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/channels?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/channels`;
};

export const channelsControllerList = async (
	params?: ChannelsControllerListParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<channelsControllerListResponse> => {
	const res = await fetch(getChannelsControllerListUrl(params, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerListResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerListResponse;
};

export const getChannelsControllerListQueryKey = (
	params?: ChannelsControllerListParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/channels`,
		...(params ? [params] : []),
	] as const;
};

export const getChannelsControllerListQueryOptions = <
	TData = Awaited<ReturnType<typeof channelsControllerList>>,
	TError = unknown,
>(
	params?: ChannelsControllerListParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChannelsControllerListQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof channelsControllerList>>
	> = ({ signal }) =>
		channelsControllerList(params, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof channelsControllerList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChannelsControllerListQueryResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerList>>
>;
export type ChannelsControllerListQueryError = unknown;

export function useChannelsControllerList<
	TData = Awaited<ReturnType<typeof channelsControllerList>>,
	TError = unknown,
>(
	params: undefined | ChannelsControllerListParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerList>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerList>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerList<
	TData = Awaited<ReturnType<typeof channelsControllerList>>,
	TError = unknown,
>(
	params?: ChannelsControllerListParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerList>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerList>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerList<
	TData = Awaited<ReturnType<typeof channelsControllerList>>,
	TError = unknown,
>(
	params?: ChannelsControllerListParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of know channels
 */

export function useChannelsControllerList<
	TData = Awaited<ReturnType<typeof channelsControllerList>>,
	TError = unknown,
>(
	params?: ChannelsControllerListParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChannelsControllerListQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Create a new channel.
 */
export type channelsControllerCreateResponse201 = {
	data: Channel;
	status: 201;
};

export type channelsControllerCreateResponseSuccess =
	channelsControllerCreateResponse201 & {
		headers: Headers;
	};

export type channelsControllerCreateResponse =
	channelsControllerCreateResponseSuccess;

export const getChannelsControllerCreateUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels`;
};

export const channelsControllerCreate = async (
	createChannelRequest: CreateChannelRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<channelsControllerCreateResponse> => {
	const res = await fetch(getChannelsControllerCreateUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createChannelRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerCreateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerCreateResponse;
};

export const getChannelsControllerCreateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof channelsControllerCreate>>,
		TError,
		{ data: CreateChannelRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof channelsControllerCreate>>,
	TError,
	{ data: CreateChannelRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["channelsControllerCreate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof channelsControllerCreate>>,
		{ data: CreateChannelRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return channelsControllerCreate(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChannelsControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerCreate>>
>;
export type ChannelsControllerCreateMutationBody = CreateChannelRequest;
export type ChannelsControllerCreateMutationError = unknown;

/**
 * @summary Create a new channel.
 */
export const useChannelsControllerCreate = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof channelsControllerCreate>>,
			TError,
			{ data: CreateChannelRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof channelsControllerCreate>>,
	TError,
	{ data: CreateChannelRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getChannelsControllerCreateMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Delete the channel.
 */
export type channelsControllerDeleteResponse200 = {
	data: void;
	status: 200;
};

export type channelsControllerDeleteResponseSuccess =
	channelsControllerDeleteResponse200 & {
		headers: Headers;
	};

export type channelsControllerDeleteResponse =
	channelsControllerDeleteResponseSuccess;

export const getChannelsControllerDeleteUrl = (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/${id}`;
};

export const channelsControllerDelete = async (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
	options?: RequestInit,
): Promise<channelsControllerDeleteResponse> => {
	const res = await fetch(getChannelsControllerDeleteUrl(session, id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerDeleteResponse;
};

export const getChannelsControllerDeleteMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof channelsControllerDelete>>,
		TError,
		{ session?: unknown; id?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof channelsControllerDelete>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	const mutationKey = ["channelsControllerDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof channelsControllerDelete>>,
		{ session?: unknown; id?: unknown }
	> = (props) => {
		const { session, id } = props ?? {};

		return channelsControllerDelete(session, id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChannelsControllerDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerDelete>>
>;

export type ChannelsControllerDeleteMutationError = unknown;

/**
 * @summary Delete the channel.
 */
export const useChannelsControllerDelete = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof channelsControllerDelete>>,
			TError,
			{ session?: unknown; id?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof channelsControllerDelete>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	return useMutation(
		getChannelsControllerDeleteMutationOptions(options),
		queryClient,
	);
};

/**
 * You can use either id (123@newsletter) OR invite code (https://www.whatsapp.com/channel/123)
 * @summary Get the channel info
 */
export type channelsControllerGetResponse200 = {
	data: Channel;
	status: 200;
};

export type channelsControllerGetResponseSuccess =
	channelsControllerGetResponse200 & {
		headers: Headers;
	};

export type channelsControllerGetResponse =
	channelsControllerGetResponseSuccess;

export const getChannelsControllerGetUrl = (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/${id}`;
};

export const channelsControllerGet = async (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
	options?: RequestInit,
): Promise<channelsControllerGetResponse> => {
	const res = await fetch(getChannelsControllerGetUrl(session, id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerGetResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerGetResponse;
};

export const getChannelsControllerGetQueryKey = (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
) => {
	return [`https://waha.gnardawgs.surf/api/${session}/channels/${id}`] as const;
};

export const getChannelsControllerGetQueryOptions = <
	TData = Awaited<ReturnType<typeof channelsControllerGet>>,
	TError = unknown,
>(
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getChannelsControllerGetQueryKey(session, id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof channelsControllerGet>>
	> = ({ signal }) =>
		channelsControllerGet(session, id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof channelsControllerGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChannelsControllerGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerGet>>
>;
export type ChannelsControllerGetQueryError = unknown;

export function useChannelsControllerGet<
	TData = Awaited<ReturnType<typeof channelsControllerGet>>,
	TError = unknown,
>(
	session: undefined | unknown,
	id: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerGet>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerGet<
	TData = Awaited<ReturnType<typeof channelsControllerGet>>,
	TError = unknown,
>(
	session?: unknown,
	id?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerGet>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerGet<
	TData = Awaited<ReturnType<typeof channelsControllerGet>>,
	TError = unknown,
>(
	session?: unknown,
	id?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the channel info
 */

export function useChannelsControllerGet<
	TData = Awaited<ReturnType<typeof channelsControllerGet>>,
	TError = unknown,
>(
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChannelsControllerGetQueryOptions(
		session,
		id,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * You can use either invite code (https://www.whatsapp.com/channel/123) or (123)ORChannel ID (123@newsletter).
 * @summary Preview channel messages
 */
export type channelsControllerPreviewChannelMessagesResponse200 = {
	data: ChannelMessage[];
	status: 200;
};

export type channelsControllerPreviewChannelMessagesResponseSuccess =
	channelsControllerPreviewChannelMessagesResponse200 & {
		headers: Headers;
	};

export type channelsControllerPreviewChannelMessagesResponse =
	channelsControllerPreviewChannelMessagesResponseSuccess;

export const getChannelsControllerPreviewChannelMessagesUrl = (
	params: ChannelsControllerPreviewChannelMessagesParams,
	session: unknown = "default",
	id: unknown = "0029Va4K0PZ5a245NkngBA2M",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/channels/${id}/messages/preview?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/channels/${id}/messages/preview`;
};

export const channelsControllerPreviewChannelMessages = async (
	params: ChannelsControllerPreviewChannelMessagesParams,
	session: unknown = "default",
	id: unknown = "0029Va4K0PZ5a245NkngBA2M",
	options?: RequestInit,
): Promise<channelsControllerPreviewChannelMessagesResponse> => {
	const res = await fetch(
		getChannelsControllerPreviewChannelMessagesUrl(params, session, id),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerPreviewChannelMessagesResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerPreviewChannelMessagesResponse;
};

export const getChannelsControllerPreviewChannelMessagesQueryKey = (
	params?: ChannelsControllerPreviewChannelMessagesParams,
	session: unknown = "default",
	id: unknown = "0029Va4K0PZ5a245NkngBA2M",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/channels/${id}/messages/preview`,
		...(params ? [params] : []),
	] as const;
};

export const getChannelsControllerPreviewChannelMessagesQueryOptions = <
	TData = Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
	TError = unknown,
>(
	params: ChannelsControllerPreviewChannelMessagesParams,
	session: unknown = "default",
	id: unknown = "0029Va4K0PZ5a245NkngBA2M",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChannelsControllerPreviewChannelMessagesQueryKey(params, session, id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>
	> = ({ signal }) =>
		channelsControllerPreviewChannelMessages(params, session, id, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChannelsControllerPreviewChannelMessagesQueryResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>
>;
export type ChannelsControllerPreviewChannelMessagesQueryError = unknown;

export function useChannelsControllerPreviewChannelMessages<
	TData = Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
	TError = unknown,
>(
	params: ChannelsControllerPreviewChannelMessagesParams,
	session: undefined | unknown,
	id: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerPreviewChannelMessages<
	TData = Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
	TError = unknown,
>(
	params: ChannelsControllerPreviewChannelMessagesParams,
	session?: unknown,
	id?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerPreviewChannelMessages<
	TData = Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
	TError = unknown,
>(
	params: ChannelsControllerPreviewChannelMessagesParams,
	session?: unknown,
	id?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Preview channel messages
 */

export function useChannelsControllerPreviewChannelMessages<
	TData = Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
	TError = unknown,
>(
	params: ChannelsControllerPreviewChannelMessagesParams,
	session: unknown = "default",
	id: unknown = "0029Va4K0PZ5a245NkngBA2M",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerPreviewChannelMessages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChannelsControllerPreviewChannelMessagesQueryOptions(
		params,
		session,
		id,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Follow the channel.
 */
export type channelsControllerFollowResponse201 = {
	data: void;
	status: 201;
};

export type channelsControllerFollowResponseSuccess =
	channelsControllerFollowResponse201 & {
		headers: Headers;
	};

export type channelsControllerFollowResponse =
	channelsControllerFollowResponseSuccess;

export const getChannelsControllerFollowUrl = (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/${id}/follow`;
};

export const channelsControllerFollow = async (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
	options?: RequestInit,
): Promise<channelsControllerFollowResponse> => {
	const res = await fetch(getChannelsControllerFollowUrl(session, id), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerFollowResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerFollowResponse;
};

export const getChannelsControllerFollowMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof channelsControllerFollow>>,
		TError,
		{ session?: unknown; id?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof channelsControllerFollow>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	const mutationKey = ["channelsControllerFollow"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof channelsControllerFollow>>,
		{ session?: unknown; id?: unknown }
	> = (props) => {
		const { session, id } = props ?? {};

		return channelsControllerFollow(session, id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChannelsControllerFollowMutationResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerFollow>>
>;

export type ChannelsControllerFollowMutationError = unknown;

/**
 * @summary Follow the channel.
 */
export const useChannelsControllerFollow = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof channelsControllerFollow>>,
			TError,
			{ session?: unknown; id?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof channelsControllerFollow>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	return useMutation(
		getChannelsControllerFollowMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Unfollow the channel.
 */
export type channelsControllerUnfollowResponse201 = {
	data: void;
	status: 201;
};

export type channelsControllerUnfollowResponseSuccess =
	channelsControllerUnfollowResponse201 & {
		headers: Headers;
	};

export type channelsControllerUnfollowResponse =
	channelsControllerUnfollowResponseSuccess;

export const getChannelsControllerUnfollowUrl = (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/${id}/unfollow`;
};

export const channelsControllerUnfollow = async (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
	options?: RequestInit,
): Promise<channelsControllerUnfollowResponse> => {
	const res = await fetch(getChannelsControllerUnfollowUrl(session, id), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerUnfollowResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerUnfollowResponse;
};

export const getChannelsControllerUnfollowMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof channelsControllerUnfollow>>,
		TError,
		{ session?: unknown; id?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof channelsControllerUnfollow>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	const mutationKey = ["channelsControllerUnfollow"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof channelsControllerUnfollow>>,
		{ session?: unknown; id?: unknown }
	> = (props) => {
		const { session, id } = props ?? {};

		return channelsControllerUnfollow(session, id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChannelsControllerUnfollowMutationResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerUnfollow>>
>;

export type ChannelsControllerUnfollowMutationError = unknown;

/**
 * @summary Unfollow the channel.
 */
export const useChannelsControllerUnfollow = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof channelsControllerUnfollow>>,
			TError,
			{ session?: unknown; id?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof channelsControllerUnfollow>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	return useMutation(
		getChannelsControllerUnfollowMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Mute the channel.
 */
export type channelsControllerMuteResponse201 = {
	data: void;
	status: 201;
};

export type channelsControllerMuteResponseSuccess =
	channelsControllerMuteResponse201 & {
		headers: Headers;
	};

export type channelsControllerMuteResponse =
	channelsControllerMuteResponseSuccess;

export const getChannelsControllerMuteUrl = (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/${id}/mute`;
};

export const channelsControllerMute = async (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
	options?: RequestInit,
): Promise<channelsControllerMuteResponse> => {
	const res = await fetch(getChannelsControllerMuteUrl(session, id), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerMuteResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerMuteResponse;
};

export const getChannelsControllerMuteMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof channelsControllerMute>>,
		TError,
		{ session?: unknown; id?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof channelsControllerMute>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	const mutationKey = ["channelsControllerMute"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof channelsControllerMute>>,
		{ session?: unknown; id?: unknown }
	> = (props) => {
		const { session, id } = props ?? {};

		return channelsControllerMute(session, id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChannelsControllerMuteMutationResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerMute>>
>;

export type ChannelsControllerMuteMutationError = unknown;

/**
 * @summary Mute the channel.
 */
export const useChannelsControllerMute = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof channelsControllerMute>>,
			TError,
			{ session?: unknown; id?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof channelsControllerMute>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	return useMutation(
		getChannelsControllerMuteMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Unmute the channel.
 */
export type channelsControllerUnmuteResponse201 = {
	data: void;
	status: 201;
};

export type channelsControllerUnmuteResponseSuccess =
	channelsControllerUnmuteResponse201 & {
		headers: Headers;
	};

export type channelsControllerUnmuteResponse =
	channelsControllerUnmuteResponseSuccess;

export const getChannelsControllerUnmuteUrl = (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/${id}/unmute`;
};

export const channelsControllerUnmute = async (
	session: unknown = "default",
	id: unknown = "123123123@newsletter",
	options?: RequestInit,
): Promise<channelsControllerUnmuteResponse> => {
	const res = await fetch(getChannelsControllerUnmuteUrl(session, id), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerUnmuteResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerUnmuteResponse;
};

export const getChannelsControllerUnmuteMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof channelsControllerUnmute>>,
		TError,
		{ session?: unknown; id?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof channelsControllerUnmute>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	const mutationKey = ["channelsControllerUnmute"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof channelsControllerUnmute>>,
		{ session?: unknown; id?: unknown }
	> = (props) => {
		const { session, id } = props ?? {};

		return channelsControllerUnmute(session, id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChannelsControllerUnmuteMutationResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerUnmute>>
>;

export type ChannelsControllerUnmuteMutationError = unknown;

/**
 * @summary Unmute the channel.
 */
export const useChannelsControllerUnmute = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof channelsControllerUnmute>>,
			TError,
			{ session?: unknown; id?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof channelsControllerUnmute>>,
	TError,
	{ session?: unknown; id?: unknown },
	TContext
> => {
	return useMutation(
		getChannelsControllerUnmuteMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Search for channels (by view)
 */
export type channelsControllerSearchByViewResponse200 = {
	data: ChannelListResult;
	status: 200;
};

export type channelsControllerSearchByViewResponseSuccess =
	channelsControllerSearchByViewResponse200 & {
		headers: Headers;
	};

export type channelsControllerSearchByViewResponse =
	channelsControllerSearchByViewResponseSuccess;

export const getChannelsControllerSearchByViewUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/search/by-view`;
};

export const channelsControllerSearchByView = async (
	channelSearchByView: ChannelSearchByView,
	session: unknown = "default",
	options?: RequestInit,
): Promise<channelsControllerSearchByViewResponse> => {
	const res = await fetch(getChannelsControllerSearchByViewUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(channelSearchByView),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerSearchByViewResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerSearchByViewResponse;
};

export const getChannelsControllerSearchByViewMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof channelsControllerSearchByView>>,
		TError,
		{ data: ChannelSearchByView; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof channelsControllerSearchByView>>,
	TError,
	{ data: ChannelSearchByView; session?: unknown },
	TContext
> => {
	const mutationKey = ["channelsControllerSearchByView"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof channelsControllerSearchByView>>,
		{ data: ChannelSearchByView; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return channelsControllerSearchByView(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChannelsControllerSearchByViewMutationResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerSearchByView>>
>;
export type ChannelsControllerSearchByViewMutationBody = ChannelSearchByView;
export type ChannelsControllerSearchByViewMutationError = unknown;

/**
 * @summary Search for channels (by view)
 */
export const useChannelsControllerSearchByView = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof channelsControllerSearchByView>>,
			TError,
			{ data: ChannelSearchByView; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof channelsControllerSearchByView>>,
	TError,
	{ data: ChannelSearchByView; session?: unknown },
	TContext
> => {
	return useMutation(
		getChannelsControllerSearchByViewMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Search for channels (by text)
 */
export type channelsControllerSearchByTextResponse200 = {
	data: ChannelListResult;
	status: 200;
};

export type channelsControllerSearchByTextResponseSuccess =
	channelsControllerSearchByTextResponse200 & {
		headers: Headers;
	};

export type channelsControllerSearchByTextResponse =
	channelsControllerSearchByTextResponseSuccess;

export const getChannelsControllerSearchByTextUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/search/by-text`;
};

export const channelsControllerSearchByText = async (
	channelSearchByText: ChannelSearchByText,
	session: unknown = "default",
	options?: RequestInit,
): Promise<channelsControllerSearchByTextResponse> => {
	const res = await fetch(getChannelsControllerSearchByTextUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(channelSearchByText),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerSearchByTextResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerSearchByTextResponse;
};

export const getChannelsControllerSearchByTextMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof channelsControllerSearchByText>>,
		TError,
		{ data: ChannelSearchByText; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof channelsControllerSearchByText>>,
	TError,
	{ data: ChannelSearchByText; session?: unknown },
	TContext
> => {
	const mutationKey = ["channelsControllerSearchByText"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof channelsControllerSearchByText>>,
		{ data: ChannelSearchByText; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return channelsControllerSearchByText(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ChannelsControllerSearchByTextMutationResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerSearchByText>>
>;
export type ChannelsControllerSearchByTextMutationBody = ChannelSearchByText;
export type ChannelsControllerSearchByTextMutationError = unknown;

/**
 * @summary Search for channels (by text)
 */
export const useChannelsControllerSearchByText = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof channelsControllerSearchByText>>,
			TError,
			{ data: ChannelSearchByText; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof channelsControllerSearchByText>>,
	TError,
	{ data: ChannelSearchByText; session?: unknown },
	TContext
> => {
	return useMutation(
		getChannelsControllerSearchByTextMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get list of views for channel search
 */
export type channelsControllerGetSearchViewsResponse200 = {
	data: ChannelView[];
	status: 200;
};

export type channelsControllerGetSearchViewsResponseSuccess =
	channelsControllerGetSearchViewsResponse200 & {
		headers: Headers;
	};

export type channelsControllerGetSearchViewsResponse =
	channelsControllerGetSearchViewsResponseSuccess;

export const getChannelsControllerGetSearchViewsUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/search/views`;
};

export const channelsControllerGetSearchViews = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<channelsControllerGetSearchViewsResponse> => {
	const res = await fetch(getChannelsControllerGetSearchViewsUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerGetSearchViewsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerGetSearchViewsResponse;
};

export const getChannelsControllerGetSearchViewsQueryKey = (
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/channels/search/views`,
	] as const;
};

export const getChannelsControllerGetSearchViewsQueryOptions = <
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChannelsControllerGetSearchViewsQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof channelsControllerGetSearchViews>>
	> = ({ signal }) =>
		channelsControllerGetSearchViews(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChannelsControllerGetSearchViewsQueryResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerGetSearchViews>>
>;
export type ChannelsControllerGetSearchViewsQueryError = unknown;

export function useChannelsControllerGetSearchViews<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerGetSearchViews>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerGetSearchViews<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerGetSearchViews>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerGetSearchViews<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of views for channel search
 */

export function useChannelsControllerGetSearchViews<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchViews>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChannelsControllerGetSearchViewsQueryOptions(
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get list of countries for channel search
 */
export type channelsControllerGetSearchCountriesResponse200 = {
	data: ChannelCountry[];
	status: 200;
};

export type channelsControllerGetSearchCountriesResponseSuccess =
	channelsControllerGetSearchCountriesResponse200 & {
		headers: Headers;
	};

export type channelsControllerGetSearchCountriesResponse =
	channelsControllerGetSearchCountriesResponseSuccess;

export const getChannelsControllerGetSearchCountriesUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/search/countries`;
};

export const channelsControllerGetSearchCountries = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<channelsControllerGetSearchCountriesResponse> => {
	const res = await fetch(getChannelsControllerGetSearchCountriesUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerGetSearchCountriesResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerGetSearchCountriesResponse;
};

export const getChannelsControllerGetSearchCountriesQueryKey = (
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/channels/search/countries`,
	] as const;
};

export const getChannelsControllerGetSearchCountriesQueryOptions = <
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChannelsControllerGetSearchCountriesQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>
	> = ({ signal }) =>
		channelsControllerGetSearchCountries(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChannelsControllerGetSearchCountriesQueryResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>
>;
export type ChannelsControllerGetSearchCountriesQueryError = unknown;

export function useChannelsControllerGetSearchCountries<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerGetSearchCountries<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerGetSearchCountries<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of countries for channel search
 */

export function useChannelsControllerGetSearchCountries<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCountries>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChannelsControllerGetSearchCountriesQueryOptions(
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get list of categories for channel search
 */
export type channelsControllerGetSearchCategoriesResponse200 = {
	data: ChannelCategory[];
	status: 200;
};

export type channelsControllerGetSearchCategoriesResponseSuccess =
	channelsControllerGetSearchCategoriesResponse200 & {
		headers: Headers;
	};

export type channelsControllerGetSearchCategoriesResponse =
	channelsControllerGetSearchCategoriesResponseSuccess;

export const getChannelsControllerGetSearchCategoriesUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/channels/search/categories`;
};

export const channelsControllerGetSearchCategories = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<channelsControllerGetSearchCategoriesResponse> => {
	const res = await fetch(
		getChannelsControllerGetSearchCategoriesUrl(session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: channelsControllerGetSearchCategoriesResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as channelsControllerGetSearchCategoriesResponse;
};

export const getChannelsControllerGetSearchCategoriesQueryKey = (
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/channels/search/categories`,
	] as const;
};

export const getChannelsControllerGetSearchCategoriesQueryOptions = <
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChannelsControllerGetSearchCategoriesQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>
	> = ({ signal }) =>
		channelsControllerGetSearchCategories(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChannelsControllerGetSearchCategoriesQueryResult = NonNullable<
	Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>
>;
export type ChannelsControllerGetSearchCategoriesQueryError = unknown;

export function useChannelsControllerGetSearchCategories<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerGetSearchCategories<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
					TError,
					Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChannelsControllerGetSearchCategories<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get list of categories for channel search
 */

export function useChannelsControllerGetSearchCategories<
	TData = Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof channelsControllerGetSearchCategories>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getChannelsControllerGetSearchCategoriesQueryOptions(
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Send text status
 */
export type statusControllerSendTextStatusResponse201 = {
	data: void;
	status: 201;
};

export type statusControllerSendTextStatusResponseSuccess =
	statusControllerSendTextStatusResponse201 & {
		headers: Headers;
	};

export type statusControllerSendTextStatusResponse =
	statusControllerSendTextStatusResponseSuccess;

export const getStatusControllerSendTextStatusUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/status/text`;
};

export const statusControllerSendTextStatus = async (
	textStatus: TextStatus,
	session: unknown = "default",
	options?: RequestInit,
): Promise<statusControllerSendTextStatusResponse> => {
	const res = await fetch(getStatusControllerSendTextStatusUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(textStatus),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: statusControllerSendTextStatusResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as statusControllerSendTextStatusResponse;
};

export const getStatusControllerSendTextStatusMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof statusControllerSendTextStatus>>,
		TError,
		{ data: TextStatus; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof statusControllerSendTextStatus>>,
	TError,
	{ data: TextStatus; session?: unknown },
	TContext
> => {
	const mutationKey = ["statusControllerSendTextStatus"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof statusControllerSendTextStatus>>,
		{ data: TextStatus; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return statusControllerSendTextStatus(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type StatusControllerSendTextStatusMutationResult = NonNullable<
	Awaited<ReturnType<typeof statusControllerSendTextStatus>>
>;
export type StatusControllerSendTextStatusMutationBody = TextStatus;
export type StatusControllerSendTextStatusMutationError = unknown;

/**
 * @summary Send text status
 */
export const useStatusControllerSendTextStatus = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof statusControllerSendTextStatus>>,
			TError,
			{ data: TextStatus; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof statusControllerSendTextStatus>>,
	TError,
	{ data: TextStatus; session?: unknown },
	TContext
> => {
	return useMutation(
		getStatusControllerSendTextStatusMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Send image status
 */
export type statusControllerSendImageStatusResponse201 = {
	data: void;
	status: 201;
};

export type statusControllerSendImageStatusResponseSuccess =
	statusControllerSendImageStatusResponse201 & {
		headers: Headers;
	};

export type statusControllerSendImageStatusResponse =
	statusControllerSendImageStatusResponseSuccess;

export const getStatusControllerSendImageStatusUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/status/image`;
};

export const statusControllerSendImageStatus = async (
	imageStatus: ImageStatus,
	session: unknown = "default",
	options?: RequestInit,
): Promise<statusControllerSendImageStatusResponse> => {
	const res = await fetch(getStatusControllerSendImageStatusUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(imageStatus),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: statusControllerSendImageStatusResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as statusControllerSendImageStatusResponse;
};

export const getStatusControllerSendImageStatusMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof statusControllerSendImageStatus>>,
		TError,
		{ data: ImageStatus; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof statusControllerSendImageStatus>>,
	TError,
	{ data: ImageStatus; session?: unknown },
	TContext
> => {
	const mutationKey = ["statusControllerSendImageStatus"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof statusControllerSendImageStatus>>,
		{ data: ImageStatus; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return statusControllerSendImageStatus(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type StatusControllerSendImageStatusMutationResult = NonNullable<
	Awaited<ReturnType<typeof statusControllerSendImageStatus>>
>;
export type StatusControllerSendImageStatusMutationBody = ImageStatus;
export type StatusControllerSendImageStatusMutationError = unknown;

/**
 * @summary Send image status
 */
export const useStatusControllerSendImageStatus = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof statusControllerSendImageStatus>>,
			TError,
			{ data: ImageStatus; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof statusControllerSendImageStatus>>,
	TError,
	{ data: ImageStatus; session?: unknown },
	TContext
> => {
	return useMutation(
		getStatusControllerSendImageStatusMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Send voice status
 */
export type statusControllerSendVoiceStatusResponse201 = {
	data: void;
	status: 201;
};

export type statusControllerSendVoiceStatusResponseSuccess =
	statusControllerSendVoiceStatusResponse201 & {
		headers: Headers;
	};

export type statusControllerSendVoiceStatusResponse =
	statusControllerSendVoiceStatusResponseSuccess;

export const getStatusControllerSendVoiceStatusUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/status/voice`;
};

export const statusControllerSendVoiceStatus = async (
	voiceStatus: VoiceStatus,
	session: unknown = "default",
	options?: RequestInit,
): Promise<statusControllerSendVoiceStatusResponse> => {
	const res = await fetch(getStatusControllerSendVoiceStatusUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(voiceStatus),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: statusControllerSendVoiceStatusResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as statusControllerSendVoiceStatusResponse;
};

export const getStatusControllerSendVoiceStatusMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof statusControllerSendVoiceStatus>>,
		TError,
		{ data: VoiceStatus; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof statusControllerSendVoiceStatus>>,
	TError,
	{ data: VoiceStatus; session?: unknown },
	TContext
> => {
	const mutationKey = ["statusControllerSendVoiceStatus"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof statusControllerSendVoiceStatus>>,
		{ data: VoiceStatus; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return statusControllerSendVoiceStatus(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type StatusControllerSendVoiceStatusMutationResult = NonNullable<
	Awaited<ReturnType<typeof statusControllerSendVoiceStatus>>
>;
export type StatusControllerSendVoiceStatusMutationBody = VoiceStatus;
export type StatusControllerSendVoiceStatusMutationError = unknown;

/**
 * @summary Send voice status
 */
export const useStatusControllerSendVoiceStatus = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof statusControllerSendVoiceStatus>>,
			TError,
			{ data: VoiceStatus; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof statusControllerSendVoiceStatus>>,
	TError,
	{ data: VoiceStatus; session?: unknown },
	TContext
> => {
	return useMutation(
		getStatusControllerSendVoiceStatusMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Send video status
 */
export type statusControllerSendVideoStatusResponse201 = {
	data: void;
	status: 201;
};

export type statusControllerSendVideoStatusResponseSuccess =
	statusControllerSendVideoStatusResponse201 & {
		headers: Headers;
	};

export type statusControllerSendVideoStatusResponse =
	statusControllerSendVideoStatusResponseSuccess;

export const getStatusControllerSendVideoStatusUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/status/video`;
};

export const statusControllerSendVideoStatus = async (
	videoStatus: VideoStatus,
	session: unknown = "default",
	options?: RequestInit,
): Promise<statusControllerSendVideoStatusResponse> => {
	const res = await fetch(getStatusControllerSendVideoStatusUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(videoStatus),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: statusControllerSendVideoStatusResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as statusControllerSendVideoStatusResponse;
};

export const getStatusControllerSendVideoStatusMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof statusControllerSendVideoStatus>>,
		TError,
		{ data: VideoStatus; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof statusControllerSendVideoStatus>>,
	TError,
	{ data: VideoStatus; session?: unknown },
	TContext
> => {
	const mutationKey = ["statusControllerSendVideoStatus"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof statusControllerSendVideoStatus>>,
		{ data: VideoStatus; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return statusControllerSendVideoStatus(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type StatusControllerSendVideoStatusMutationResult = NonNullable<
	Awaited<ReturnType<typeof statusControllerSendVideoStatus>>
>;
export type StatusControllerSendVideoStatusMutationBody = VideoStatus;
export type StatusControllerSendVideoStatusMutationError = unknown;

/**
 * @summary Send video status
 */
export const useStatusControllerSendVideoStatus = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof statusControllerSendVideoStatus>>,
			TError,
			{ data: VideoStatus; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof statusControllerSendVideoStatus>>,
	TError,
	{ data: VideoStatus; session?: unknown },
	TContext
> => {
	return useMutation(
		getStatusControllerSendVideoStatusMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary DELETE sent status
 */
export type statusControllerDeleteStatusResponse201 = {
	data: void;
	status: 201;
};

export type statusControllerDeleteStatusResponseSuccess =
	statusControllerDeleteStatusResponse201 & {
		headers: Headers;
	};

export type statusControllerDeleteStatusResponse =
	statusControllerDeleteStatusResponseSuccess;

export const getStatusControllerDeleteStatusUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/status/delete`;
};

export const statusControllerDeleteStatus = async (
	deleteStatusRequest: DeleteStatusRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<statusControllerDeleteStatusResponse> => {
	const res = await fetch(getStatusControllerDeleteStatusUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(deleteStatusRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: statusControllerDeleteStatusResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as statusControllerDeleteStatusResponse;
};

export const getStatusControllerDeleteStatusMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof statusControllerDeleteStatus>>,
		TError,
		{ data: DeleteStatusRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof statusControllerDeleteStatus>>,
	TError,
	{ data: DeleteStatusRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["statusControllerDeleteStatus"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof statusControllerDeleteStatus>>,
		{ data: DeleteStatusRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return statusControllerDeleteStatus(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type StatusControllerDeleteStatusMutationResult = NonNullable<
	Awaited<ReturnType<typeof statusControllerDeleteStatus>>
>;
export type StatusControllerDeleteStatusMutationBody = DeleteStatusRequest;
export type StatusControllerDeleteStatusMutationError = unknown;

/**
 * @summary DELETE sent status
 */
export const useStatusControllerDeleteStatus = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof statusControllerDeleteStatus>>,
			TError,
			{ data: DeleteStatusRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof statusControllerDeleteStatus>>,
	TError,
	{ data: DeleteStatusRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getStatusControllerDeleteStatusMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Generate message ID you can use to batch contacts
 */
export type statusControllerGetNewMessageIdResponse200 = {
	data: NewMessageIDResponse;
	status: 200;
};

export type statusControllerGetNewMessageIdResponseSuccess =
	statusControllerGetNewMessageIdResponse200 & {
		headers: Headers;
	};

export type statusControllerGetNewMessageIdResponse =
	statusControllerGetNewMessageIdResponseSuccess;

export const getStatusControllerGetNewMessageIdUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/status/new-message-id`;
};

export const statusControllerGetNewMessageId = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<statusControllerGetNewMessageIdResponse> => {
	const res = await fetch(getStatusControllerGetNewMessageIdUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: statusControllerGetNewMessageIdResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as statusControllerGetNewMessageIdResponse;
};

export const getStatusControllerGetNewMessageIdQueryKey = (
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/status/new-message-id`,
	] as const;
};

export const getStatusControllerGetNewMessageIdQueryOptions = <
	TData = Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getStatusControllerGetNewMessageIdQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof statusControllerGetNewMessageId>>
	> = ({ signal }) =>
		statusControllerGetNewMessageId(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type StatusControllerGetNewMessageIdQueryResult = NonNullable<
	Awaited<ReturnType<typeof statusControllerGetNewMessageId>>
>;
export type StatusControllerGetNewMessageIdQueryError = unknown;

export function useStatusControllerGetNewMessageId<
	TData = Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
					TError,
					Awaited<ReturnType<typeof statusControllerGetNewMessageId>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatusControllerGetNewMessageId<
	TData = Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
					TError,
					Awaited<ReturnType<typeof statusControllerGetNewMessageId>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useStatusControllerGetNewMessageId<
	TData = Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Generate message ID you can use to batch contacts
 */

export function useStatusControllerGetNewMessageId<
	TData = Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof statusControllerGetNewMessageId>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getStatusControllerGetNewMessageIdQueryOptions(
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get all labels
 */
export type labelsControllerGetAllResponse200 = {
	data: Label[];
	status: 200;
};

export type labelsControllerGetAllResponseSuccess =
	labelsControllerGetAllResponse200 & {
		headers: Headers;
	};

export type labelsControllerGetAllResponse =
	labelsControllerGetAllResponseSuccess;

export const getLabelsControllerGetAllUrl = (session: unknown = "default") => {
	return `https://waha.gnardawgs.surf/api/${session}/labels`;
};

export const labelsControllerGetAll = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<labelsControllerGetAllResponse> => {
	const res = await fetch(getLabelsControllerGetAllUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: labelsControllerGetAllResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as labelsControllerGetAllResponse;
};

export const getLabelsControllerGetAllQueryKey = (
	session: unknown = "default",
) => {
	return [`https://waha.gnardawgs.surf/api/${session}/labels`] as const;
};

export const getLabelsControllerGetAllQueryOptions = <
	TData = Awaited<ReturnType<typeof labelsControllerGetAll>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getLabelsControllerGetAllQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof labelsControllerGetAll>>
	> = ({ signal }) =>
		labelsControllerGetAll(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof labelsControllerGetAll>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LabelsControllerGetAllQueryResult = NonNullable<
	Awaited<ReturnType<typeof labelsControllerGetAll>>
>;
export type LabelsControllerGetAllQueryError = unknown;

export function useLabelsControllerGetAll<
	TData = Awaited<ReturnType<typeof labelsControllerGetAll>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetAll>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof labelsControllerGetAll>>,
					TError,
					Awaited<ReturnType<typeof labelsControllerGetAll>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLabelsControllerGetAll<
	TData = Awaited<ReturnType<typeof labelsControllerGetAll>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetAll>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof labelsControllerGetAll>>,
					TError,
					Awaited<ReturnType<typeof labelsControllerGetAll>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLabelsControllerGetAll<
	TData = Awaited<ReturnType<typeof labelsControllerGetAll>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all labels
 */

export function useLabelsControllerGetAll<
	TData = Awaited<ReturnType<typeof labelsControllerGetAll>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getLabelsControllerGetAllQueryOptions(session, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Create a new label
 */
export type labelsControllerCreateResponse201 = {
	data: Label;
	status: 201;
};

export type labelsControllerCreateResponseSuccess =
	labelsControllerCreateResponse201 & {
		headers: Headers;
	};

export type labelsControllerCreateResponse =
	labelsControllerCreateResponseSuccess;

export const getLabelsControllerCreateUrl = (session: unknown = "default") => {
	return `https://waha.gnardawgs.surf/api/${session}/labels`;
};

export const labelsControllerCreate = async (
	labelBody: LabelBody,
	session: unknown = "default",
	options?: RequestInit,
): Promise<labelsControllerCreateResponse> => {
	const res = await fetch(getLabelsControllerCreateUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(labelBody),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: labelsControllerCreateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as labelsControllerCreateResponse;
};

export const getLabelsControllerCreateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof labelsControllerCreate>>,
		TError,
		{ data: LabelBody; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof labelsControllerCreate>>,
	TError,
	{ data: LabelBody; session?: unknown },
	TContext
> => {
	const mutationKey = ["labelsControllerCreate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof labelsControllerCreate>>,
		{ data: LabelBody; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return labelsControllerCreate(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LabelsControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof labelsControllerCreate>>
>;
export type LabelsControllerCreateMutationBody = LabelBody;
export type LabelsControllerCreateMutationError = unknown;

/**
 * @summary Create a new label
 */
export const useLabelsControllerCreate = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof labelsControllerCreate>>,
			TError,
			{ data: LabelBody; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof labelsControllerCreate>>,
	TError,
	{ data: LabelBody; session?: unknown },
	TContext
> => {
	return useMutation(
		getLabelsControllerCreateMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Update a label
 */
export type labelsControllerUpdateResponse200 = {
	data: Label;
	status: 200;
};

export type labelsControllerUpdateResponseSuccess =
	labelsControllerUpdateResponse200 & {
		headers: Headers;
	};

export type labelsControllerUpdateResponse =
	labelsControllerUpdateResponseSuccess;

export const getLabelsControllerUpdateUrl = (
	labelId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/labels/${labelId}`;
};

export const labelsControllerUpdate = async (
	labelId: string,
	labelBody: LabelBody,
	session: unknown = "default",
	options?: RequestInit,
): Promise<labelsControllerUpdateResponse> => {
	const res = await fetch(getLabelsControllerUpdateUrl(labelId, session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(labelBody),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: labelsControllerUpdateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as labelsControllerUpdateResponse;
};

export const getLabelsControllerUpdateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof labelsControllerUpdate>>,
		TError,
		{ labelId: string; data: LabelBody; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof labelsControllerUpdate>>,
	TError,
	{ labelId: string; data: LabelBody; session?: unknown },
	TContext
> => {
	const mutationKey = ["labelsControllerUpdate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof labelsControllerUpdate>>,
		{ labelId: string; data: LabelBody; session?: unknown }
	> = (props) => {
		const { labelId, data, session } = props ?? {};

		return labelsControllerUpdate(labelId, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LabelsControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof labelsControllerUpdate>>
>;
export type LabelsControllerUpdateMutationBody = LabelBody;
export type LabelsControllerUpdateMutationError = unknown;

/**
 * @summary Update a label
 */
export const useLabelsControllerUpdate = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof labelsControllerUpdate>>,
			TError,
			{ labelId: string; data: LabelBody; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof labelsControllerUpdate>>,
	TError,
	{ labelId: string; data: LabelBody; session?: unknown },
	TContext
> => {
	return useMutation(
		getLabelsControllerUpdateMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Delete a label
 */
export type labelsControllerDeleteResponse200 = {
	data: LabelsControllerDelete200;
	status: 200;
};

export type labelsControllerDeleteResponseSuccess =
	labelsControllerDeleteResponse200 & {
		headers: Headers;
	};

export type labelsControllerDeleteResponse =
	labelsControllerDeleteResponseSuccess;

export const getLabelsControllerDeleteUrl = (
	labelId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/labels/${labelId}`;
};

export const labelsControllerDelete = async (
	labelId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<labelsControllerDeleteResponse> => {
	const res = await fetch(getLabelsControllerDeleteUrl(labelId, session), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: labelsControllerDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as labelsControllerDeleteResponse;
};

export const getLabelsControllerDeleteMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof labelsControllerDelete>>,
		TError,
		{ labelId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof labelsControllerDelete>>,
	TError,
	{ labelId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["labelsControllerDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof labelsControllerDelete>>,
		{ labelId: string; session?: unknown }
	> = (props) => {
		const { labelId, session } = props ?? {};

		return labelsControllerDelete(labelId, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LabelsControllerDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof labelsControllerDelete>>
>;

export type LabelsControllerDeleteMutationError = unknown;

/**
 * @summary Delete a label
 */
export const useLabelsControllerDelete = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof labelsControllerDelete>>,
			TError,
			{ labelId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof labelsControllerDelete>>,
	TError,
	{ labelId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getLabelsControllerDeleteMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get labels for the chat
 */
export type labelsControllerGetChatLabelsResponse200 = {
	data: Label[];
	status: 200;
};

export type labelsControllerGetChatLabelsResponseSuccess =
	labelsControllerGetChatLabelsResponse200 & {
		headers: Headers;
	};

export type labelsControllerGetChatLabelsResponse =
	labelsControllerGetChatLabelsResponseSuccess;

export const getLabelsControllerGetChatLabelsUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/labels/chats/${chatId}`;
};

export const labelsControllerGetChatLabels = async (
	chatId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<labelsControllerGetChatLabelsResponse> => {
	const res = await fetch(
		getLabelsControllerGetChatLabelsUrl(chatId, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: labelsControllerGetChatLabelsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as labelsControllerGetChatLabelsResponse;
};

export const getLabelsControllerGetChatLabelsQueryKey = (
	chatId: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/labels/chats/${chatId}`,
	] as const;
};

export const getLabelsControllerGetChatLabelsQueryOptions = <
	TData = Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
	TError = unknown,
>(
	chatId: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getLabelsControllerGetChatLabelsQueryKey(chatId, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof labelsControllerGetChatLabels>>
	> = ({ signal }) =>
		labelsControllerGetChatLabels(chatId, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(session && chatId),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LabelsControllerGetChatLabelsQueryResult = NonNullable<
	Awaited<ReturnType<typeof labelsControllerGetChatLabels>>
>;
export type LabelsControllerGetChatLabelsQueryError = unknown;

export function useLabelsControllerGetChatLabels<
	TData = Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
	TError = unknown,
>(
	chatId: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
					TError,
					Awaited<ReturnType<typeof labelsControllerGetChatLabels>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLabelsControllerGetChatLabels<
	TData = Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
	TError = unknown,
>(
	chatId: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
					TError,
					Awaited<ReturnType<typeof labelsControllerGetChatLabels>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLabelsControllerGetChatLabels<
	TData = Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
	TError = unknown,
>(
	chatId: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get labels for the chat
 */

export function useLabelsControllerGetChatLabels<
	TData = Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
	TError = unknown,
>(
	chatId: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatLabels>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getLabelsControllerGetChatLabelsQueryOptions(
		chatId,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Save labels for the chat
 */
export type labelsControllerPutChatLabelsResponse200 = {
	data: void;
	status: 200;
};

export type labelsControllerPutChatLabelsResponseSuccess =
	labelsControllerPutChatLabelsResponse200 & {
		headers: Headers;
	};

export type labelsControllerPutChatLabelsResponse =
	labelsControllerPutChatLabelsResponseSuccess;

export const getLabelsControllerPutChatLabelsUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/labels/chats/${chatId}`;
};

export const labelsControllerPutChatLabels = async (
	chatId: string,
	setLabelsRequest: SetLabelsRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<labelsControllerPutChatLabelsResponse> => {
	const res = await fetch(
		getLabelsControllerPutChatLabelsUrl(chatId, session),
		{
			...options,
			method: "PUT",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(setLabelsRequest),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: labelsControllerPutChatLabelsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as labelsControllerPutChatLabelsResponse;
};

export const getLabelsControllerPutChatLabelsMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof labelsControllerPutChatLabels>>,
		TError,
		{ chatId: string; data: SetLabelsRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof labelsControllerPutChatLabels>>,
	TError,
	{ chatId: string; data: SetLabelsRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["labelsControllerPutChatLabels"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof labelsControllerPutChatLabels>>,
		{ chatId: string; data: SetLabelsRequest; session?: unknown }
	> = (props) => {
		const { chatId, data, session } = props ?? {};

		return labelsControllerPutChatLabels(chatId, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type LabelsControllerPutChatLabelsMutationResult = NonNullable<
	Awaited<ReturnType<typeof labelsControllerPutChatLabels>>
>;
export type LabelsControllerPutChatLabelsMutationBody = SetLabelsRequest;
export type LabelsControllerPutChatLabelsMutationError = unknown;

/**
 * @summary Save labels for the chat
 */
export const useLabelsControllerPutChatLabels = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof labelsControllerPutChatLabels>>,
			TError,
			{ chatId: string; data: SetLabelsRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof labelsControllerPutChatLabels>>,
	TError,
	{ chatId: string; data: SetLabelsRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getLabelsControllerPutChatLabelsMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get chats by label
 */
export type labelsControllerGetChatsByLabelResponse200 = {
	data: void;
	status: 200;
};

export type labelsControllerGetChatsByLabelResponseSuccess =
	labelsControllerGetChatsByLabelResponse200 & {
		headers: Headers;
	};

export type labelsControllerGetChatsByLabelResponse =
	labelsControllerGetChatsByLabelResponseSuccess;

export const getLabelsControllerGetChatsByLabelUrl = (
	labelId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/labels/${labelId}/chats`;
};

export const labelsControllerGetChatsByLabel = async (
	labelId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<labelsControllerGetChatsByLabelResponse> => {
	const res = await fetch(
		getLabelsControllerGetChatsByLabelUrl(labelId, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: labelsControllerGetChatsByLabelResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as labelsControllerGetChatsByLabelResponse;
};

export const getLabelsControllerGetChatsByLabelQueryKey = (
	labelId: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/labels/${labelId}/chats`,
	] as const;
};

export const getLabelsControllerGetChatsByLabelQueryOptions = <
	TData = Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
	TError = unknown,
>(
	labelId: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getLabelsControllerGetChatsByLabelQueryKey(labelId, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>
	> = ({ signal }) =>
		labelsControllerGetChatsByLabel(labelId, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && labelId),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LabelsControllerGetChatsByLabelQueryResult = NonNullable<
	Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>
>;
export type LabelsControllerGetChatsByLabelQueryError = unknown;

export function useLabelsControllerGetChatsByLabel<
	TData = Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
	TError = unknown,
>(
	labelId: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
					TError,
					Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLabelsControllerGetChatsByLabel<
	TData = Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
	TError = unknown,
>(
	labelId: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
					TError,
					Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLabelsControllerGetChatsByLabel<
	TData = Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
	TError = unknown,
>(
	labelId: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get chats by label
 */

export function useLabelsControllerGetChatsByLabel<
	TData = Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
	TError = unknown,
>(
	labelId: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof labelsControllerGetChatsByLabel>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getLabelsControllerGetChatsByLabelQueryOptions(
		labelId,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get all contacts
 */
export type contactsControllerGetAllResponse200 = {
	data: void;
	status: 200;
};

export type contactsControllerGetAllResponseSuccess =
	contactsControllerGetAllResponse200 & {
		headers: Headers;
	};

export type contactsControllerGetAllResponse =
	contactsControllerGetAllResponseSuccess;

export const getContactsControllerGetAllUrl = (
	params: ContactsControllerGetAllParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/contacts/all?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/contacts/all`;
};

export const contactsControllerGetAll = async (
	params: ContactsControllerGetAllParams,
	options?: RequestInit,
): Promise<contactsControllerGetAllResponse> => {
	const res = await fetch(getContactsControllerGetAllUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: contactsControllerGetAllResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as contactsControllerGetAllResponse;
};

export const getContactsControllerGetAllQueryKey = (
	params?: ContactsControllerGetAllParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/contacts/all`,
		...(params ? [params] : []),
	] as const;
};

export const getContactsControllerGetAllQueryOptions = <
	TData = Awaited<ReturnType<typeof contactsControllerGetAll>>,
	TError = unknown,
>(
	params: ContactsControllerGetAllParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getContactsControllerGetAllQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof contactsControllerGetAll>>
	> = ({ signal }) =>
		contactsControllerGetAll(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof contactsControllerGetAll>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContactsControllerGetAllQueryResult = NonNullable<
	Awaited<ReturnType<typeof contactsControllerGetAll>>
>;
export type ContactsControllerGetAllQueryError = unknown;

export function useContactsControllerGetAll<
	TData = Awaited<ReturnType<typeof contactsControllerGetAll>>,
	TError = unknown,
>(
	params: ContactsControllerGetAllParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAll>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerGetAll>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerGetAll>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerGetAll<
	TData = Awaited<ReturnType<typeof contactsControllerGetAll>>,
	TError = unknown,
>(
	params: ContactsControllerGetAllParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAll>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerGetAll>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerGetAll>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerGetAll<
	TData = Awaited<ReturnType<typeof contactsControllerGetAll>>,
	TError = unknown,
>(
	params: ContactsControllerGetAllParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all contacts
 */

export function useContactsControllerGetAll<
	TData = Awaited<ReturnType<typeof contactsControllerGetAll>>,
	TError = unknown,
>(
	params: ContactsControllerGetAllParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getContactsControllerGetAllQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * The method always return result, even if the phone number is not registered in WhatsApp. For that - use /contacts/check-exists endpoint below.
 * @summary Get contact basic info
 */
export type contactsControllerGetResponse200 = {
	data: void;
	status: 200;
};

export type contactsControllerGetResponseSuccess =
	contactsControllerGetResponse200 & {
		headers: Headers;
	};

export type contactsControllerGetResponse =
	contactsControllerGetResponseSuccess;

export const getContactsControllerGetUrl = (
	params: ContactsControllerGetParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/contacts?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/contacts`;
};

export const contactsControllerGet = async (
	params: ContactsControllerGetParams,
	options?: RequestInit,
): Promise<contactsControllerGetResponse> => {
	const res = await fetch(getContactsControllerGetUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: contactsControllerGetResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as contactsControllerGetResponse;
};

export const getContactsControllerGetQueryKey = (
	params?: ContactsControllerGetParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/contacts`,
		...(params ? [params] : []),
	] as const;
};

export const getContactsControllerGetQueryOptions = <
	TData = Awaited<ReturnType<typeof contactsControllerGet>>,
	TError = unknown,
>(
	params: ContactsControllerGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getContactsControllerGetQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof contactsControllerGet>>
	> = ({ signal }) =>
		contactsControllerGet(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof contactsControllerGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContactsControllerGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof contactsControllerGet>>
>;
export type ContactsControllerGetQueryError = unknown;

export function useContactsControllerGet<
	TData = Awaited<ReturnType<typeof contactsControllerGet>>,
	TError = unknown,
>(
	params: ContactsControllerGetParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerGet>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerGet<
	TData = Awaited<ReturnType<typeof contactsControllerGet>>,
	TError = unknown,
>(
	params: ContactsControllerGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerGet>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerGet<
	TData = Awaited<ReturnType<typeof contactsControllerGet>>,
	TError = unknown,
>(
	params: ContactsControllerGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get contact basic info
 */

export function useContactsControllerGet<
	TData = Awaited<ReturnType<typeof contactsControllerGet>>,
	TError = unknown,
>(
	params: ContactsControllerGetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getContactsControllerGetQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Check phone number is registered in WhatsApp.
 */
export type contactsControllerCheckExistsResponse200 = {
	data: WANumberExistResult;
	status: 200;
};

export type contactsControllerCheckExistsResponseSuccess =
	contactsControllerCheckExistsResponse200 & {
		headers: Headers;
	};

export type contactsControllerCheckExistsResponse =
	contactsControllerCheckExistsResponseSuccess;

export const getContactsControllerCheckExistsUrl = (
	params: ContactsControllerCheckExistsParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/contacts/check-exists?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/contacts/check-exists`;
};

export const contactsControllerCheckExists = async (
	params: ContactsControllerCheckExistsParams,
	options?: RequestInit,
): Promise<contactsControllerCheckExistsResponse> => {
	const res = await fetch(getContactsControllerCheckExistsUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: contactsControllerCheckExistsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as contactsControllerCheckExistsResponse;
};

export const getContactsControllerCheckExistsQueryKey = (
	params?: ContactsControllerCheckExistsParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/contacts/check-exists`,
		...(params ? [params] : []),
	] as const;
};

export const getContactsControllerCheckExistsQueryOptions = <
	TData = Awaited<ReturnType<typeof contactsControllerCheckExists>>,
	TError = unknown,
>(
	params: ContactsControllerCheckExistsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerCheckExists>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getContactsControllerCheckExistsQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof contactsControllerCheckExists>>
	> = ({ signal }) =>
		contactsControllerCheckExists(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof contactsControllerCheckExists>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContactsControllerCheckExistsQueryResult = NonNullable<
	Awaited<ReturnType<typeof contactsControllerCheckExists>>
>;
export type ContactsControllerCheckExistsQueryError = unknown;

export function useContactsControllerCheckExists<
	TData = Awaited<ReturnType<typeof contactsControllerCheckExists>>,
	TError = unknown,
>(
	params: ContactsControllerCheckExistsParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerCheckExists>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerCheckExists>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerCheckExists>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerCheckExists<
	TData = Awaited<ReturnType<typeof contactsControllerCheckExists>>,
	TError = unknown,
>(
	params: ContactsControllerCheckExistsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerCheckExists>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerCheckExists>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerCheckExists>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerCheckExists<
	TData = Awaited<ReturnType<typeof contactsControllerCheckExists>>,
	TError = unknown,
>(
	params: ContactsControllerCheckExistsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerCheckExists>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Check phone number is registered in WhatsApp.
 */

export function useContactsControllerCheckExists<
	TData = Awaited<ReturnType<typeof contactsControllerCheckExists>>,
	TError = unknown,
>(
	params: ContactsControllerCheckExistsParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerCheckExists>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getContactsControllerCheckExistsQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Returns null if you do not have permission to read their status.
 * @summary Gets the Contact's "about" info
 */
export type contactsControllerGetAboutResponse200 = {
	data: void;
	status: 200;
};

export type contactsControllerGetAboutResponseSuccess =
	contactsControllerGetAboutResponse200 & {
		headers: Headers;
	};

export type contactsControllerGetAboutResponse =
	contactsControllerGetAboutResponseSuccess;

export const getContactsControllerGetAboutUrl = (
	params: ContactsControllerGetAboutParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/contacts/about?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/contacts/about`;
};

export const contactsControllerGetAbout = async (
	params: ContactsControllerGetAboutParams,
	options?: RequestInit,
): Promise<contactsControllerGetAboutResponse> => {
	const res = await fetch(getContactsControllerGetAboutUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: contactsControllerGetAboutResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as contactsControllerGetAboutResponse;
};

export const getContactsControllerGetAboutQueryKey = (
	params?: ContactsControllerGetAboutParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/contacts/about`,
		...(params ? [params] : []),
	] as const;
};

export const getContactsControllerGetAboutQueryOptions = <
	TData = Awaited<ReturnType<typeof contactsControllerGetAbout>>,
	TError = unknown,
>(
	params: ContactsControllerGetAboutParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAbout>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getContactsControllerGetAboutQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof contactsControllerGetAbout>>
	> = ({ signal }) =>
		contactsControllerGetAbout(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof contactsControllerGetAbout>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContactsControllerGetAboutQueryResult = NonNullable<
	Awaited<ReturnType<typeof contactsControllerGetAbout>>
>;
export type ContactsControllerGetAboutQueryError = unknown;

export function useContactsControllerGetAbout<
	TData = Awaited<ReturnType<typeof contactsControllerGetAbout>>,
	TError = unknown,
>(
	params: ContactsControllerGetAboutParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAbout>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerGetAbout>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerGetAbout>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerGetAbout<
	TData = Awaited<ReturnType<typeof contactsControllerGetAbout>>,
	TError = unknown,
>(
	params: ContactsControllerGetAboutParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAbout>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerGetAbout>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerGetAbout>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerGetAbout<
	TData = Awaited<ReturnType<typeof contactsControllerGetAbout>>,
	TError = unknown,
>(
	params: ContactsControllerGetAboutParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAbout>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets the Contact's "about" info
 */

export function useContactsControllerGetAbout<
	TData = Awaited<ReturnType<typeof contactsControllerGetAbout>>,
	TError = unknown,
>(
	params: ContactsControllerGetAboutParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetAbout>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getContactsControllerGetAboutQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * If privacy settings do not allow to get the picture, the method will return null.
 * @summary Get contact's profile picture URL
 */
export type contactsControllerGetProfilePictureResponse200 = {
	data: void;
	status: 200;
};

export type contactsControllerGetProfilePictureResponseSuccess =
	contactsControllerGetProfilePictureResponse200 & {
		headers: Headers;
	};

export type contactsControllerGetProfilePictureResponse =
	contactsControllerGetProfilePictureResponseSuccess;

export const getContactsControllerGetProfilePictureUrl = (
	params: ContactsControllerGetProfilePictureParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/contacts/profile-picture?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/contacts/profile-picture`;
};

export const contactsControllerGetProfilePicture = async (
	params: ContactsControllerGetProfilePictureParams,
	options?: RequestInit,
): Promise<contactsControllerGetProfilePictureResponse> => {
	const res = await fetch(getContactsControllerGetProfilePictureUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: contactsControllerGetProfilePictureResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as contactsControllerGetProfilePictureResponse;
};

export const getContactsControllerGetProfilePictureQueryKey = (
	params?: ContactsControllerGetProfilePictureParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/contacts/profile-picture`,
		...(params ? [params] : []),
	] as const;
};

export const getContactsControllerGetProfilePictureQueryOptions = <
	TData = Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
	TError = unknown,
>(
	params: ContactsControllerGetProfilePictureParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getContactsControllerGetProfilePictureQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>
	> = ({ signal }) =>
		contactsControllerGetProfilePicture(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ContactsControllerGetProfilePictureQueryResult = NonNullable<
	Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>
>;
export type ContactsControllerGetProfilePictureQueryError = unknown;

export function useContactsControllerGetProfilePicture<
	TData = Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
	TError = unknown,
>(
	params: ContactsControllerGetProfilePictureParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerGetProfilePicture<
	TData = Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
	TError = unknown,
>(
	params: ContactsControllerGetProfilePictureParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
					TError,
					Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useContactsControllerGetProfilePicture<
	TData = Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
	TError = unknown,
>(
	params: ContactsControllerGetProfilePictureParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get contact's profile picture URL
 */

export function useContactsControllerGetProfilePicture<
	TData = Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
	TError = unknown,
>(
	params: ContactsControllerGetProfilePictureParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof contactsControllerGetProfilePicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getContactsControllerGetProfilePictureQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Block contact
 */
export type contactsControllerBlockResponse201 = {
	data: void;
	status: 201;
};

export type contactsControllerBlockResponseSuccess =
	contactsControllerBlockResponse201 & {
		headers: Headers;
	};

export type contactsControllerBlockResponse =
	contactsControllerBlockResponseSuccess;

export const getContactsControllerBlockUrl = () => {
	return `https://waha.gnardawgs.surf/api/contacts/block`;
};

export const contactsControllerBlock = async (
	contactRequest: ContactRequest,
	options?: RequestInit,
): Promise<contactsControllerBlockResponse> => {
	const res = await fetch(getContactsControllerBlockUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(contactRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: contactsControllerBlockResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as contactsControllerBlockResponse;
};

export const getContactsControllerBlockMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof contactsControllerBlock>>,
		TError,
		{ data: ContactRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof contactsControllerBlock>>,
	TError,
	{ data: ContactRequest },
	TContext
> => {
	const mutationKey = ["contactsControllerBlock"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof contactsControllerBlock>>,
		{ data: ContactRequest }
	> = (props) => {
		const { data } = props ?? {};

		return contactsControllerBlock(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ContactsControllerBlockMutationResult = NonNullable<
	Awaited<ReturnType<typeof contactsControllerBlock>>
>;
export type ContactsControllerBlockMutationBody = ContactRequest;
export type ContactsControllerBlockMutationError = unknown;

/**
 * @summary Block contact
 */
export const useContactsControllerBlock = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof contactsControllerBlock>>,
			TError,
			{ data: ContactRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof contactsControllerBlock>>,
	TError,
	{ data: ContactRequest },
	TContext
> => {
	return useMutation(
		getContactsControllerBlockMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Unblock contact
 */
export type contactsControllerUnblockResponse201 = {
	data: void;
	status: 201;
};

export type contactsControllerUnblockResponseSuccess =
	contactsControllerUnblockResponse201 & {
		headers: Headers;
	};

export type contactsControllerUnblockResponse =
	contactsControllerUnblockResponseSuccess;

export const getContactsControllerUnblockUrl = () => {
	return `https://waha.gnardawgs.surf/api/contacts/unblock`;
};

export const contactsControllerUnblock = async (
	contactRequest: ContactRequest,
	options?: RequestInit,
): Promise<contactsControllerUnblockResponse> => {
	const res = await fetch(getContactsControllerUnblockUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(contactRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: contactsControllerUnblockResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as contactsControllerUnblockResponse;
};

export const getContactsControllerUnblockMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof contactsControllerUnblock>>,
		TError,
		{ data: ContactRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof contactsControllerUnblock>>,
	TError,
	{ data: ContactRequest },
	TContext
> => {
	const mutationKey = ["contactsControllerUnblock"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof contactsControllerUnblock>>,
		{ data: ContactRequest }
	> = (props) => {
		const { data } = props ?? {};

		return contactsControllerUnblock(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ContactsControllerUnblockMutationResult = NonNullable<
	Awaited<ReturnType<typeof contactsControllerUnblock>>
>;
export type ContactsControllerUnblockMutationBody = ContactRequest;
export type ContactsControllerUnblockMutationError = unknown;

/**
 * @summary Unblock contact
 */
export const useContactsControllerUnblock = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof contactsControllerUnblock>>,
			TError,
			{ data: ContactRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof contactsControllerUnblock>>,
	TError,
	{ data: ContactRequest },
	TContext
> => {
	return useMutation(
		getContactsControllerUnblockMutationOptions(options),
		queryClient,
	);
};

/**
 * Create or update contact on the phone address book. May not work if you have installed many WhatsApp apps on the same phone
 * @summary Create or update contact
 */
export type contactsSessionControllerPutResponse200 = {
	data: Result;
	status: 200;
};

export type contactsSessionControllerPutResponseSuccess =
	contactsSessionControllerPutResponse200 & {
		headers: Headers;
	};

export type contactsSessionControllerPutResponse =
	contactsSessionControllerPutResponseSuccess;

export const getContactsSessionControllerPutUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/contacts/${chatId}`;
};

export const contactsSessionControllerPut = async (
	chatId: string,
	contactUpdateBody: ContactUpdateBody,
	session: unknown = "default",
	options?: RequestInit,
): Promise<contactsSessionControllerPutResponse> => {
	const res = await fetch(getContactsSessionControllerPutUrl(chatId, session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(contactUpdateBody),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: contactsSessionControllerPutResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as contactsSessionControllerPutResponse;
};

export const getContactsSessionControllerPutMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof contactsSessionControllerPut>>,
		TError,
		{ chatId: string; data: ContactUpdateBody; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof contactsSessionControllerPut>>,
	TError,
	{ chatId: string; data: ContactUpdateBody; session?: unknown },
	TContext
> => {
	const mutationKey = ["contactsSessionControllerPut"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof contactsSessionControllerPut>>,
		{ chatId: string; data: ContactUpdateBody; session?: unknown }
	> = (props) => {
		const { chatId, data, session } = props ?? {};

		return contactsSessionControllerPut(chatId, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ContactsSessionControllerPutMutationResult = NonNullable<
	Awaited<ReturnType<typeof contactsSessionControllerPut>>
>;
export type ContactsSessionControllerPutMutationBody = ContactUpdateBody;
export type ContactsSessionControllerPutMutationError = unknown;

/**
 * @summary Create or update contact
 */
export const useContactsSessionControllerPut = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof contactsSessionControllerPut>>,
			TError,
			{ chatId: string; data: ContactUpdateBody; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof contactsSessionControllerPut>>,
	TError,
	{ chatId: string; data: ContactUpdateBody; session?: unknown },
	TContext
> => {
	return useMutation(
		getContactsSessionControllerPutMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get all known lids to phone number mapping
 */
export type lidsControllerGetAllResponse200 = {
	data: LidToPhoneNumber[];
	status: 200;
};

export type lidsControllerGetAllResponseSuccess =
	lidsControllerGetAllResponse200 & {
		headers: Headers;
	};

export type lidsControllerGetAllResponse = lidsControllerGetAllResponseSuccess;

export const getLidsControllerGetAllUrl = (
	params?: LidsControllerGetAllParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/lids?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/lids`;
};

export const lidsControllerGetAll = async (
	params?: LidsControllerGetAllParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<lidsControllerGetAllResponse> => {
	const res = await fetch(getLidsControllerGetAllUrl(params, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: lidsControllerGetAllResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as lidsControllerGetAllResponse;
};

export const getLidsControllerGetAllQueryKey = (
	params?: LidsControllerGetAllParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/lids`,
		...(params ? [params] : []),
	] as const;
};

export const getLidsControllerGetAllQueryOptions = <
	TData = Awaited<ReturnType<typeof lidsControllerGetAll>>,
	TError = unknown,
>(
	params?: LidsControllerGetAllParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getLidsControllerGetAllQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof lidsControllerGetAll>>
	> = ({ signal }) =>
		lidsControllerGetAll(params, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof lidsControllerGetAll>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LidsControllerGetAllQueryResult = NonNullable<
	Awaited<ReturnType<typeof lidsControllerGetAll>>
>;
export type LidsControllerGetAllQueryError = unknown;

export function useLidsControllerGetAll<
	TData = Awaited<ReturnType<typeof lidsControllerGetAll>>,
	TError = unknown,
>(
	params: undefined | LidsControllerGetAllParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetAll>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof lidsControllerGetAll>>,
					TError,
					Awaited<ReturnType<typeof lidsControllerGetAll>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLidsControllerGetAll<
	TData = Awaited<ReturnType<typeof lidsControllerGetAll>>,
	TError = unknown,
>(
	params?: LidsControllerGetAllParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetAll>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof lidsControllerGetAll>>,
					TError,
					Awaited<ReturnType<typeof lidsControllerGetAll>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLidsControllerGetAll<
	TData = Awaited<ReturnType<typeof lidsControllerGetAll>>,
	TError = unknown,
>(
	params?: LidsControllerGetAllParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all known lids to phone number mapping
 */

export function useLidsControllerGetAll<
	TData = Awaited<ReturnType<typeof lidsControllerGetAll>>,
	TError = unknown,
>(
	params?: LidsControllerGetAllParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getLidsControllerGetAllQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get the number of known lids
 */
export type lidsControllerGetLidsCountResponse200 = {
	data: CountResponse;
	status: 200;
};

export type lidsControllerGetLidsCountResponseSuccess =
	lidsControllerGetLidsCountResponse200 & {
		headers: Headers;
	};

export type lidsControllerGetLidsCountResponse =
	lidsControllerGetLidsCountResponseSuccess;

export const getLidsControllerGetLidsCountUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/lids/count`;
};

export const lidsControllerGetLidsCount = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<lidsControllerGetLidsCountResponse> => {
	const res = await fetch(getLidsControllerGetLidsCountUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: lidsControllerGetLidsCountResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as lidsControllerGetLidsCountResponse;
};

export const getLidsControllerGetLidsCountQueryKey = (
	session: unknown = "default",
) => {
	return [`https://waha.gnardawgs.surf/api/${session}/lids/count`] as const;
};

export const getLidsControllerGetLidsCountQueryOptions = <
	TData = Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getLidsControllerGetLidsCountQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof lidsControllerGetLidsCount>>
	> = ({ signal }) =>
		lidsControllerGetLidsCount(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LidsControllerGetLidsCountQueryResult = NonNullable<
	Awaited<ReturnType<typeof lidsControllerGetLidsCount>>
>;
export type LidsControllerGetLidsCountQueryError = unknown;

export function useLidsControllerGetLidsCount<
	TData = Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
					TError,
					Awaited<ReturnType<typeof lidsControllerGetLidsCount>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLidsControllerGetLidsCount<
	TData = Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
					TError,
					Awaited<ReturnType<typeof lidsControllerGetLidsCount>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLidsControllerGetLidsCount<
	TData = Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the number of known lids
 */

export function useLidsControllerGetLidsCount<
	TData = Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerGetLidsCount>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getLidsControllerGetLidsCountQueryOptions(
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get phone number by lid
 */
export type lidsControllerFindPNByLidResponse200 = {
	data: LidToPhoneNumber;
	status: 200;
};

export type lidsControllerFindPNByLidResponseSuccess =
	lidsControllerFindPNByLidResponse200 & {
		headers: Headers;
	};

export type lidsControllerFindPNByLidResponse =
	lidsControllerFindPNByLidResponseSuccess;

export const getLidsControllerFindPNByLidUrl = (
	lid: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/lids/${lid}`;
};

export const lidsControllerFindPNByLid = async (
	lid: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<lidsControllerFindPNByLidResponse> => {
	const res = await fetch(getLidsControllerFindPNByLidUrl(lid, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: lidsControllerFindPNByLidResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as lidsControllerFindPNByLidResponse;
};

export const getLidsControllerFindPNByLidQueryKey = (
	lid: string,
	session: unknown = "default",
) => {
	return [`https://waha.gnardawgs.surf/api/${session}/lids/${lid}`] as const;
};

export const getLidsControllerFindPNByLidQueryOptions = <
	TData = Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
	TError = unknown,
>(
	lid: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getLidsControllerFindPNByLidQueryKey(lid, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof lidsControllerFindPNByLid>>
	> = ({ signal }) =>
		lidsControllerFindPNByLid(lid, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(session && lid),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LidsControllerFindPNByLidQueryResult = NonNullable<
	Awaited<ReturnType<typeof lidsControllerFindPNByLid>>
>;
export type LidsControllerFindPNByLidQueryError = unknown;

export function useLidsControllerFindPNByLid<
	TData = Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
	TError = unknown,
>(
	lid: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
					TError,
					Awaited<ReturnType<typeof lidsControllerFindPNByLid>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLidsControllerFindPNByLid<
	TData = Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
	TError = unknown,
>(
	lid: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
					TError,
					Awaited<ReturnType<typeof lidsControllerFindPNByLid>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLidsControllerFindPNByLid<
	TData = Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
	TError = unknown,
>(
	lid: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get phone number by lid
 */

export function useLidsControllerFindPNByLid<
	TData = Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
	TError = unknown,
>(
	lid: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindPNByLid>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getLidsControllerFindPNByLidQueryOptions(
		lid,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get lid by phone number (chat id)
 */
export type lidsControllerFindLIDByPhoneNumberResponse200 = {
	data: LidToPhoneNumber;
	status: 200;
};

export type lidsControllerFindLIDByPhoneNumberResponseSuccess =
	lidsControllerFindLIDByPhoneNumberResponse200 & {
		headers: Headers;
	};

export type lidsControllerFindLIDByPhoneNumberResponse =
	lidsControllerFindLIDByPhoneNumberResponseSuccess;

export const getLidsControllerFindLIDByPhoneNumberUrl = (
	phoneNumber: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/lids/pn/${phoneNumber}`;
};

export const lidsControllerFindLIDByPhoneNumber = async (
	phoneNumber: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<lidsControllerFindLIDByPhoneNumberResponse> => {
	const res = await fetch(
		getLidsControllerFindLIDByPhoneNumberUrl(phoneNumber, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: lidsControllerFindLIDByPhoneNumberResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as lidsControllerFindLIDByPhoneNumberResponse;
};

export const getLidsControllerFindLIDByPhoneNumberQueryKey = (
	phoneNumber: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/lids/pn/${phoneNumber}`,
	] as const;
};

export const getLidsControllerFindLIDByPhoneNumberQueryOptions = <
	TData = Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
	TError = unknown,
>(
	phoneNumber: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getLidsControllerFindLIDByPhoneNumberQueryKey(phoneNumber, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>
	> = ({ signal }) =>
		lidsControllerFindLIDByPhoneNumber(phoneNumber, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && phoneNumber),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type LidsControllerFindLIDByPhoneNumberQueryResult = NonNullable<
	Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>
>;
export type LidsControllerFindLIDByPhoneNumberQueryError = unknown;

export function useLidsControllerFindLIDByPhoneNumber<
	TData = Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
	TError = unknown,
>(
	phoneNumber: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
					TError,
					Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLidsControllerFindLIDByPhoneNumber<
	TData = Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
	TError = unknown,
>(
	phoneNumber: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
					TError,
					Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useLidsControllerFindLIDByPhoneNumber<
	TData = Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
	TError = unknown,
>(
	phoneNumber: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get lid by phone number (chat id)
 */

export function useLidsControllerFindLIDByPhoneNumber<
	TData = Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
	TError = unknown,
>(
	phoneNumber: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof lidsControllerFindLIDByPhoneNumber>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getLidsControllerFindLIDByPhoneNumberQueryOptions(
		phoneNumber,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Create a new group.
 */
export type groupsControllerCreateGroupResponse201 = {
	data: void;
	status: 201;
};

export type groupsControllerCreateGroupResponseSuccess =
	groupsControllerCreateGroupResponse201 & {
		headers: Headers;
	};

export type groupsControllerCreateGroupResponse =
	groupsControllerCreateGroupResponseSuccess;

export const getGroupsControllerCreateGroupUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups`;
};

export const groupsControllerCreateGroup = async (
	createGroupRequest: CreateGroupRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerCreateGroupResponse> => {
	const res = await fetch(getGroupsControllerCreateGroupUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(createGroupRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerCreateGroupResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerCreateGroupResponse;
};

export const getGroupsControllerCreateGroupMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerCreateGroup>>,
		TError,
		{ data: CreateGroupRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerCreateGroup>>,
	TError,
	{ data: CreateGroupRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerCreateGroup"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerCreateGroup>>,
		{ data: CreateGroupRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return groupsControllerCreateGroup(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerCreateGroupMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerCreateGroup>>
>;
export type GroupsControllerCreateGroupMutationBody = CreateGroupRequest;
export type GroupsControllerCreateGroupMutationError = unknown;

/**
 * @summary Create a new group.
 */
export const useGroupsControllerCreateGroup = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerCreateGroup>>,
			TError,
			{ data: CreateGroupRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerCreateGroup>>,
	TError,
	{ data: CreateGroupRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerCreateGroupMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get all groups.
 */
export type groupsControllerGetGroupsResponse200 = {
	data: GroupsControllerGetGroups200;
	status: 200;
};

export type groupsControllerGetGroupsResponseSuccess =
	groupsControllerGetGroupsResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetGroupsResponse =
	groupsControllerGetGroupsResponseSuccess;

export const getGroupsControllerGetGroupsUrl = (
	params?: GroupsControllerGetGroupsParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/groups?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/groups`;
};

export const groupsControllerGetGroups = async (
	params?: GroupsControllerGetGroupsParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetGroupsResponse> => {
	const res = await fetch(getGroupsControllerGetGroupsUrl(params, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetGroupsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetGroupsResponse;
};

export const getGroupsControllerGetGroupsQueryKey = (
	params?: GroupsControllerGetGroupsParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/groups`,
		...(params ? [params] : []),
	] as const;
};

export const getGroupsControllerGetGroupsQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetGroups>>,
	TError = unknown,
>(
	params?: GroupsControllerGetGroupsParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroups>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerGetGroupsQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetGroups>>
	> = ({ signal }) =>
		groupsControllerGetGroups(params, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetGroups>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetGroupsQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetGroups>>
>;
export type GroupsControllerGetGroupsQueryError = unknown;

export function useGroupsControllerGetGroups<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroups>>,
	TError = unknown,
>(
	params: undefined | GroupsControllerGetGroupsParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroups>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetGroups>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetGroups>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetGroups<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroups>>,
	TError = unknown,
>(
	params?: GroupsControllerGetGroupsParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroups>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetGroups>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetGroups>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetGroups<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroups>>,
	TError = unknown,
>(
	params?: GroupsControllerGetGroupsParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroups>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all groups.
 */

export function useGroupsControllerGetGroups<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroups>>,
	TError = unknown,
>(
	params?: GroupsControllerGetGroupsParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroups>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetGroupsQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get info about the group before joining.
 */
export type groupsControllerJoinInfoGroupResponse200 = {
	data: GroupsControllerJoinInfoGroup200;
	status: 200;
};

export type groupsControllerJoinInfoGroupResponseSuccess =
	groupsControllerJoinInfoGroupResponse200 & {
		headers: Headers;
	};

export type groupsControllerJoinInfoGroupResponse =
	groupsControllerJoinInfoGroupResponseSuccess;

export const getGroupsControllerJoinInfoGroupUrl = (
	params: GroupsControllerJoinInfoGroupParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/groups/join-info?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/groups/join-info`;
};

export const groupsControllerJoinInfoGroup = async (
	params: GroupsControllerJoinInfoGroupParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerJoinInfoGroupResponse> => {
	const res = await fetch(
		getGroupsControllerJoinInfoGroupUrl(params, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerJoinInfoGroupResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerJoinInfoGroupResponse;
};

export const getGroupsControllerJoinInfoGroupQueryKey = (
	params?: GroupsControllerJoinInfoGroupParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/groups/join-info`,
		...(params ? [params] : []),
	] as const;
};

export const getGroupsControllerJoinInfoGroupQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
	TError = unknown,
>(
	params: GroupsControllerJoinInfoGroupParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerJoinInfoGroupQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>
	> = ({ signal }) =>
		groupsControllerJoinInfoGroup(params, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerJoinInfoGroupQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>
>;
export type GroupsControllerJoinInfoGroupQueryError = unknown;

export function useGroupsControllerJoinInfoGroup<
	TData = Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
	TError = unknown,
>(
	params: GroupsControllerJoinInfoGroupParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerJoinInfoGroup<
	TData = Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
	TError = unknown,
>(
	params: GroupsControllerJoinInfoGroupParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerJoinInfoGroup<
	TData = Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
	TError = unknown,
>(
	params: GroupsControllerJoinInfoGroupParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get info about the group before joining.
 */

export function useGroupsControllerJoinInfoGroup<
	TData = Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
	TError = unknown,
>(
	params: GroupsControllerJoinInfoGroupParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerJoinInfoGroup>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerJoinInfoGroupQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Join group via code
 */
export type groupsControllerJoinGroupResponse200 = {
	data: JoinGroupResponse;
	status: 200;
};

export type groupsControllerJoinGroupResponseSuccess =
	groupsControllerJoinGroupResponse200 & {
		headers: Headers;
	};

export type groupsControllerJoinGroupResponse =
	groupsControllerJoinGroupResponseSuccess;

export const getGroupsControllerJoinGroupUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/join`;
};

export const groupsControllerJoinGroup = async (
	joinGroupRequest: JoinGroupRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerJoinGroupResponse> => {
	const res = await fetch(getGroupsControllerJoinGroupUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(joinGroupRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerJoinGroupResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerJoinGroupResponse;
};

export const getGroupsControllerJoinGroupMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerJoinGroup>>,
		TError,
		{ data: JoinGroupRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerJoinGroup>>,
	TError,
	{ data: JoinGroupRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerJoinGroup"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerJoinGroup>>,
		{ data: JoinGroupRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return groupsControllerJoinGroup(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerJoinGroupMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerJoinGroup>>
>;
export type GroupsControllerJoinGroupMutationBody = JoinGroupRequest;
export type GroupsControllerJoinGroupMutationError = unknown;

/**
 * @summary Join group via code
 */
export const useGroupsControllerJoinGroup = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerJoinGroup>>,
			TError,
			{ data: JoinGroupRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerJoinGroup>>,
	TError,
	{ data: JoinGroupRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerJoinGroupMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get the number of groups.
 */
export type groupsControllerGetGroupsCountResponse200 = {
	data: CountResponse;
	status: 200;
};

export type groupsControllerGetGroupsCountResponseSuccess =
	groupsControllerGetGroupsCountResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetGroupsCountResponse =
	groupsControllerGetGroupsCountResponseSuccess;

export const getGroupsControllerGetGroupsCountUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/count`;
};

export const groupsControllerGetGroupsCount = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetGroupsCountResponse> => {
	const res = await fetch(getGroupsControllerGetGroupsCountUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetGroupsCountResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetGroupsCountResponse;
};

export const getGroupsControllerGetGroupsCountQueryKey = (
	session: unknown = "default",
) => {
	return [`https://waha.gnardawgs.surf/api/${session}/groups/count`] as const;
};

export const getGroupsControllerGetGroupsCountQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerGetGroupsCountQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>
	> = ({ signal }) =>
		groupsControllerGetGroupsCount(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetGroupsCountQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>
>;
export type GroupsControllerGetGroupsCountQueryError = unknown;

export function useGroupsControllerGetGroupsCount<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetGroupsCount<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetGroupsCount<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the number of groups.
 */

export function useGroupsControllerGetGroupsCount<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupsCount>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetGroupsCountQueryOptions(
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Refresh groups from the server.
 */
export type groupsControllerRefreshGroupsResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerRefreshGroupsResponseSuccess =
	groupsControllerRefreshGroupsResponse200 & {
		headers: Headers;
	};

export type groupsControllerRefreshGroupsResponse =
	groupsControllerRefreshGroupsResponseSuccess;

export const getGroupsControllerRefreshGroupsUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/refresh`;
};

export const groupsControllerRefreshGroups = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerRefreshGroupsResponse> => {
	const res = await fetch(getGroupsControllerRefreshGroupsUrl(session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerRefreshGroupsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerRefreshGroupsResponse;
};

export const getGroupsControllerRefreshGroupsMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerRefreshGroups>>,
		TError,
		{ session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerRefreshGroups>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerRefreshGroups"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerRefreshGroups>>,
		{ session?: unknown }
	> = (props) => {
		const { session } = props ?? {};

		return groupsControllerRefreshGroups(session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerRefreshGroupsMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerRefreshGroups>>
>;

export type GroupsControllerRefreshGroupsMutationError = unknown;

/**
 * @summary Refresh groups from the server.
 */
export const useGroupsControllerRefreshGroups = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerRefreshGroups>>,
			TError,
			{ session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerRefreshGroups>>,
	TError,
	{ session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerRefreshGroupsMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get the group.
 */
export type groupsControllerGetGroupResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerGetGroupResponseSuccess =
	groupsControllerGetGroupResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetGroupResponse =
	groupsControllerGetGroupResponseSuccess;

export const getGroupsControllerGetGroupUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}`;
};

export const groupsControllerGetGroup = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetGroupResponse> => {
	const res = await fetch(getGroupsControllerGetGroupUrl(id, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetGroupResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetGroupResponse;
};

export const getGroupsControllerGetGroupQueryKey = (
	id: string,
	session: unknown = "default",
) => {
	return [`https://waha.gnardawgs.surf/api/${session}/groups/${id}`] as const;
};

export const getGroupsControllerGetGroupQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetGroup>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroup>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getGroupsControllerGetGroupQueryKey(id, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetGroup>>
	> = ({ signal }) =>
		groupsControllerGetGroup(id, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetGroup>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetGroupQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetGroup>>
>;
export type GroupsControllerGetGroupQueryError = unknown;

export function useGroupsControllerGetGroup<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroup>>,
	TError = unknown,
>(
	id: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroup>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetGroup>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetGroup>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetGroup<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroup>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroup>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetGroup>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetGroup>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetGroup<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroup>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroup>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the group.
 */

export function useGroupsControllerGetGroup<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroup>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroup>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetGroupQueryOptions(
		id,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Delete the group.
 */
export type groupsControllerDeleteGroupResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerDeleteGroupResponseSuccess =
	groupsControllerDeleteGroupResponse200 & {
		headers: Headers;
	};

export type groupsControllerDeleteGroupResponse =
	groupsControllerDeleteGroupResponseSuccess;

export const getGroupsControllerDeleteGroupUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}`;
};

export const groupsControllerDeleteGroup = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerDeleteGroupResponse> => {
	const res = await fetch(getGroupsControllerDeleteGroupUrl(id, session), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerDeleteGroupResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerDeleteGroupResponse;
};

export const getGroupsControllerDeleteGroupMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerDeleteGroup>>,
		TError,
		{ id: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerDeleteGroup>>,
	TError,
	{ id: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerDeleteGroup"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerDeleteGroup>>,
		{ id: string; session?: unknown }
	> = (props) => {
		const { id, session } = props ?? {};

		return groupsControllerDeleteGroup(id, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerDeleteGroupMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerDeleteGroup>>
>;

export type GroupsControllerDeleteGroupMutationError = unknown;

/**
 * @summary Delete the group.
 */
export const useGroupsControllerDeleteGroup = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerDeleteGroup>>,
			TError,
			{ id: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerDeleteGroup>>,
	TError,
	{ id: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerDeleteGroupMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Leave the group.
 */
export type groupsControllerLeaveGroupResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerLeaveGroupResponseSuccess =
	groupsControllerLeaveGroupResponse200 & {
		headers: Headers;
	};

export type groupsControllerLeaveGroupResponse =
	groupsControllerLeaveGroupResponseSuccess;

export const getGroupsControllerLeaveGroupUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/leave`;
};

export const groupsControllerLeaveGroup = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerLeaveGroupResponse> => {
	const res = await fetch(getGroupsControllerLeaveGroupUrl(id, session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerLeaveGroupResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerLeaveGroupResponse;
};

export const getGroupsControllerLeaveGroupMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerLeaveGroup>>,
		TError,
		{ id: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerLeaveGroup>>,
	TError,
	{ id: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerLeaveGroup"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerLeaveGroup>>,
		{ id: string; session?: unknown }
	> = (props) => {
		const { id, session } = props ?? {};

		return groupsControllerLeaveGroup(id, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerLeaveGroupMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerLeaveGroup>>
>;

export type GroupsControllerLeaveGroupMutationError = unknown;

/**
 * @summary Leave the group.
 */
export const useGroupsControllerLeaveGroup = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerLeaveGroup>>,
			TError,
			{ id: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerLeaveGroup>>,
	TError,
	{ id: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerLeaveGroupMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get group picture
 */
export type groupsControllerGetChatPictureResponse200 = {
	data: ChatPictureResponse;
	status: 200;
};

export type groupsControllerGetChatPictureResponseSuccess =
	groupsControllerGetChatPictureResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetChatPictureResponse =
	groupsControllerGetChatPictureResponseSuccess;

export const getGroupsControllerGetChatPictureUrl = (
	id: string,
	params?: GroupsControllerGetChatPictureParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/${session}/groups/${id}/picture?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/${session}/groups/${id}/picture`;
};

export const groupsControllerGetChatPicture = async (
	id: string,
	params?: GroupsControllerGetChatPictureParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetChatPictureResponse> => {
	const res = await fetch(
		getGroupsControllerGetChatPictureUrl(id, params, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetChatPictureResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetChatPictureResponse;
};

export const getGroupsControllerGetChatPictureQueryKey = (
	id: string,
	params?: GroupsControllerGetChatPictureParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/groups/${id}/picture`,
		...(params ? [params] : []),
	] as const;
};

export const getGroupsControllerGetChatPictureQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
	TError = unknown,
>(
	id: string,
	params?: GroupsControllerGetChatPictureParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerGetChatPictureQueryKey(id, params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetChatPicture>>
	> = ({ signal }) =>
		groupsControllerGetChatPicture(id, params, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetChatPictureQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetChatPicture>>
>;
export type GroupsControllerGetChatPictureQueryError = unknown;

export function useGroupsControllerGetChatPicture<
	TData = Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
	TError = unknown,
>(
	id: string,
	params: undefined | GroupsControllerGetChatPictureParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetChatPicture>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetChatPicture<
	TData = Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
	TError = unknown,
>(
	id: string,
	params?: GroupsControllerGetChatPictureParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetChatPicture>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetChatPicture<
	TData = Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
	TError = unknown,
>(
	id: string,
	params?: GroupsControllerGetChatPictureParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get group picture
 */

export function useGroupsControllerGetChatPicture<
	TData = Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
	TError = unknown,
>(
	id: string,
	params?: GroupsControllerGetChatPictureParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetChatPicture>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetChatPictureQueryOptions(
		id,
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Set group picture
 */
export type groupsControllerSetPictureResponse200 = {
	data: Result;
	status: 200;
};

export type groupsControllerSetPictureResponseSuccess =
	groupsControllerSetPictureResponse200 & {
		headers: Headers;
	};

export type groupsControllerSetPictureResponse =
	groupsControllerSetPictureResponseSuccess;

export const getGroupsControllerSetPictureUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/picture`;
};

export const groupsControllerSetPicture = async (
	id: string,
	profilePictureRequest: ProfilePictureRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerSetPictureResponse> => {
	const res = await fetch(getGroupsControllerSetPictureUrl(id, session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(profilePictureRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerSetPictureResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerSetPictureResponse;
};

export const getGroupsControllerSetPictureMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerSetPicture>>,
		TError,
		{ id: string; data: ProfilePictureRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerSetPicture>>,
	TError,
	{ id: string; data: ProfilePictureRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerSetPicture"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerSetPicture>>,
		{ id: string; data: ProfilePictureRequest; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerSetPicture(id, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerSetPictureMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerSetPicture>>
>;
export type GroupsControllerSetPictureMutationBody = ProfilePictureRequest;
export type GroupsControllerSetPictureMutationError = unknown;

/**
 * @summary Set group picture
 */
export const useGroupsControllerSetPicture = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerSetPicture>>,
			TError,
			{ id: string; data: ProfilePictureRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerSetPicture>>,
	TError,
	{ id: string; data: ProfilePictureRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerSetPictureMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Delete group picture
 */
export type groupsControllerDeletePictureResponse200 = {
	data: Result;
	status: 200;
};

export type groupsControllerDeletePictureResponseSuccess =
	groupsControllerDeletePictureResponse200 & {
		headers: Headers;
	};

export type groupsControllerDeletePictureResponse =
	groupsControllerDeletePictureResponseSuccess;

export const getGroupsControllerDeletePictureUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/picture`;
};

export const groupsControllerDeletePicture = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerDeletePictureResponse> => {
	const res = await fetch(getGroupsControllerDeletePictureUrl(id, session), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerDeletePictureResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerDeletePictureResponse;
};

export const getGroupsControllerDeletePictureMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerDeletePicture>>,
		TError,
		{ id: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerDeletePicture>>,
	TError,
	{ id: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerDeletePicture"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerDeletePicture>>,
		{ id: string; session?: unknown }
	> = (props) => {
		const { id, session } = props ?? {};

		return groupsControllerDeletePicture(id, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerDeletePictureMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerDeletePicture>>
>;

export type GroupsControllerDeletePictureMutationError = unknown;

/**
 * @summary Delete group picture
 */
export const useGroupsControllerDeletePicture = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerDeletePicture>>,
			TError,
			{ id: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerDeletePicture>>,
	TError,
	{ id: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerDeletePictureMutationOptions(options),
		queryClient,
	);
};

/**
 * Returns "true" if the subject was properly updated. This can return "false" if the user does not have the necessary permissions.
 * @summary Updates the group description.
 */
export type groupsControllerSetDescriptionResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerSetDescriptionResponseSuccess =
	groupsControllerSetDescriptionResponse200 & {
		headers: Headers;
	};

export type groupsControllerSetDescriptionResponse =
	groupsControllerSetDescriptionResponseSuccess;

export const getGroupsControllerSetDescriptionUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/description`;
};

export const groupsControllerSetDescription = async (
	id: string,
	descriptionRequest: DescriptionRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerSetDescriptionResponse> => {
	const res = await fetch(getGroupsControllerSetDescriptionUrl(id, session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(descriptionRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerSetDescriptionResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerSetDescriptionResponse;
};

export const getGroupsControllerSetDescriptionMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerSetDescription>>,
		TError,
		{ id: string; data: DescriptionRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerSetDescription>>,
	TError,
	{ id: string; data: DescriptionRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerSetDescription"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerSetDescription>>,
		{ id: string; data: DescriptionRequest; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerSetDescription(id, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerSetDescriptionMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerSetDescription>>
>;
export type GroupsControllerSetDescriptionMutationBody = DescriptionRequest;
export type GroupsControllerSetDescriptionMutationError = unknown;

/**
 * @summary Updates the group description.
 */
export const useGroupsControllerSetDescription = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerSetDescription>>,
			TError,
			{ id: string; data: DescriptionRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerSetDescription>>,
	TError,
	{ id: string; data: DescriptionRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerSetDescriptionMutationOptions(options),
		queryClient,
	);
};

/**
 * Returns "true" if the subject was properly updated. This can return "false" if the user does not have the necessary permissions.
 * @summary Updates the group subject
 */
export type groupsControllerSetSubjectResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerSetSubjectResponseSuccess =
	groupsControllerSetSubjectResponse200 & {
		headers: Headers;
	};

export type groupsControllerSetSubjectResponse =
	groupsControllerSetSubjectResponseSuccess;

export const getGroupsControllerSetSubjectUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/subject`;
};

export const groupsControllerSetSubject = async (
	id: string,
	subjectRequest: SubjectRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerSetSubjectResponse> => {
	const res = await fetch(getGroupsControllerSetSubjectUrl(id, session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(subjectRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerSetSubjectResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerSetSubjectResponse;
};

export const getGroupsControllerSetSubjectMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerSetSubject>>,
		TError,
		{ id: string; data: SubjectRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerSetSubject>>,
	TError,
	{ id: string; data: SubjectRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerSetSubject"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerSetSubject>>,
		{ id: string; data: SubjectRequest; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerSetSubject(id, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerSetSubjectMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerSetSubject>>
>;
export type GroupsControllerSetSubjectMutationBody = SubjectRequest;
export type GroupsControllerSetSubjectMutationError = unknown;

/**
 * @summary Updates the group subject
 */
export const useGroupsControllerSetSubject = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerSetSubject>>,
			TError,
			{ id: string; data: SubjectRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerSetSubject>>,
	TError,
	{ id: string; data: SubjectRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerSetSubjectMutationOptions(options),
		queryClient,
	);
};

/**
 * You can allow only admins to edit group info (title, description, photo).
 * @summary Updates the group "info admin only" settings.
 */
export type groupsControllerSetInfoAdminOnlyResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerSetInfoAdminOnlyResponseSuccess =
	groupsControllerSetInfoAdminOnlyResponse200 & {
		headers: Headers;
	};

export type groupsControllerSetInfoAdminOnlyResponse =
	groupsControllerSetInfoAdminOnlyResponseSuccess;

export const getGroupsControllerSetInfoAdminOnlyUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/settings/security/info-admin-only`;
};

export const groupsControllerSetInfoAdminOnly = async (
	id: string,
	settingsSecurityChangeInfo: SettingsSecurityChangeInfo,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerSetInfoAdminOnlyResponse> => {
	const res = await fetch(getGroupsControllerSetInfoAdminOnlyUrl(id, session), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(settingsSecurityChangeInfo),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerSetInfoAdminOnlyResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerSetInfoAdminOnlyResponse;
};

export const getGroupsControllerSetInfoAdminOnlyMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerSetInfoAdminOnly>>,
		TError,
		{ id: string; data: SettingsSecurityChangeInfo; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerSetInfoAdminOnly>>,
	TError,
	{ id: string; data: SettingsSecurityChangeInfo; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerSetInfoAdminOnly"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerSetInfoAdminOnly>>,
		{ id: string; data: SettingsSecurityChangeInfo; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerSetInfoAdminOnly(id, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerSetInfoAdminOnlyMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerSetInfoAdminOnly>>
>;
export type GroupsControllerSetInfoAdminOnlyMutationBody =
	SettingsSecurityChangeInfo;
export type GroupsControllerSetInfoAdminOnlyMutationError = unknown;

/**
 * @summary Updates the group "info admin only" settings.
 */
export const useGroupsControllerSetInfoAdminOnly = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerSetInfoAdminOnly>>,
			TError,
			{ id: string; data: SettingsSecurityChangeInfo; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerSetInfoAdminOnly>>,
	TError,
	{ id: string; data: SettingsSecurityChangeInfo; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerSetInfoAdminOnlyMutationOptions(options),
		queryClient,
	);
};

/**
 * You can allow only admins to edit group info (title, description, photo).
 * @summary Get the group's 'info admin only' settings.
 */
export type groupsControllerGetInfoAdminOnlyResponse200 = {
	data: SettingsSecurityChangeInfo;
	status: 200;
};

export type groupsControllerGetInfoAdminOnlyResponseSuccess =
	groupsControllerGetInfoAdminOnlyResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetInfoAdminOnlyResponse =
	groupsControllerGetInfoAdminOnlyResponseSuccess;

export const getGroupsControllerGetInfoAdminOnlyUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/settings/security/info-admin-only`;
};

export const groupsControllerGetInfoAdminOnly = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetInfoAdminOnlyResponse> => {
	const res = await fetch(getGroupsControllerGetInfoAdminOnlyUrl(id, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetInfoAdminOnlyResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetInfoAdminOnlyResponse;
};

export const getGroupsControllerGetInfoAdminOnlyQueryKey = (
	id: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/groups/${id}/settings/security/info-admin-only`,
	] as const;
};

export const getGroupsControllerGetInfoAdminOnlyQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerGetInfoAdminOnlyQueryKey(id, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>
	> = ({ signal }) =>
		groupsControllerGetInfoAdminOnly(id, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetInfoAdminOnlyQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>
>;
export type GroupsControllerGetInfoAdminOnlyQueryError = unknown;

export function useGroupsControllerGetInfoAdminOnly<
	TData = Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetInfoAdminOnly<
	TData = Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetInfoAdminOnly<
	TData = Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the group's 'info admin only' settings.
 */

export function useGroupsControllerGetInfoAdminOnly<
	TData = Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInfoAdminOnly>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetInfoAdminOnlyQueryOptions(
		id,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Updates the group settings to only allow admins to send messages.
 * @summary Update settings - who can send messages
 */
export type groupsControllerSetMessagesAdminOnlyResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerSetMessagesAdminOnlyResponseSuccess =
	groupsControllerSetMessagesAdminOnlyResponse200 & {
		headers: Headers;
	};

export type groupsControllerSetMessagesAdminOnlyResponse =
	groupsControllerSetMessagesAdminOnlyResponseSuccess;

export const getGroupsControllerSetMessagesAdminOnlyUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/settings/security/messages-admin-only`;
};

export const groupsControllerSetMessagesAdminOnly = async (
	id: string,
	settingsSecurityChangeInfo: SettingsSecurityChangeInfo,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerSetMessagesAdminOnlyResponse> => {
	const res = await fetch(
		getGroupsControllerSetMessagesAdminOnlyUrl(id, session),
		{
			...options,
			method: "PUT",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(settingsSecurityChangeInfo),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerSetMessagesAdminOnlyResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerSetMessagesAdminOnlyResponse;
};

export const getGroupsControllerSetMessagesAdminOnlyMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerSetMessagesAdminOnly>>,
		TError,
		{ id: string; data: SettingsSecurityChangeInfo; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerSetMessagesAdminOnly>>,
	TError,
	{ id: string; data: SettingsSecurityChangeInfo; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerSetMessagesAdminOnly"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerSetMessagesAdminOnly>>,
		{ id: string; data: SettingsSecurityChangeInfo; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerSetMessagesAdminOnly(
			id,
			data,
			session,
			fetchOptions,
		);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerSetMessagesAdminOnlyMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerSetMessagesAdminOnly>>
>;
export type GroupsControllerSetMessagesAdminOnlyMutationBody =
	SettingsSecurityChangeInfo;
export type GroupsControllerSetMessagesAdminOnlyMutationError = unknown;

/**
 * @summary Update settings - who can send messages
 */
export const useGroupsControllerSetMessagesAdminOnly = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerSetMessagesAdminOnly>>,
			TError,
			{ id: string; data: SettingsSecurityChangeInfo; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerSetMessagesAdminOnly>>,
	TError,
	{ id: string; data: SettingsSecurityChangeInfo; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerSetMessagesAdminOnlyMutationOptions(options),
		queryClient,
	);
};

/**
 * The group settings to only allow admins to send messages.
 * @summary Get settings - who can send messages
 */
export type groupsControllerGetMessagesAdminOnlyResponse200 = {
	data: SettingsSecurityChangeInfo;
	status: 200;
};

export type groupsControllerGetMessagesAdminOnlyResponseSuccess =
	groupsControllerGetMessagesAdminOnlyResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetMessagesAdminOnlyResponse =
	groupsControllerGetMessagesAdminOnlyResponseSuccess;

export const getGroupsControllerGetMessagesAdminOnlyUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/settings/security/messages-admin-only`;
};

export const groupsControllerGetMessagesAdminOnly = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetMessagesAdminOnlyResponse> => {
	const res = await fetch(
		getGroupsControllerGetMessagesAdminOnlyUrl(id, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetMessagesAdminOnlyResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetMessagesAdminOnlyResponse;
};

export const getGroupsControllerGetMessagesAdminOnlyQueryKey = (
	id: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/groups/${id}/settings/security/messages-admin-only`,
	] as const;
};

export const getGroupsControllerGetMessagesAdminOnlyQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerGetMessagesAdminOnlyQueryKey(id, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>
	> = ({ signal }) =>
		groupsControllerGetMessagesAdminOnly(id, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetMessagesAdminOnlyQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>
>;
export type GroupsControllerGetMessagesAdminOnlyQueryError = unknown;

export function useGroupsControllerGetMessagesAdminOnly<
	TData = Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetMessagesAdminOnly<
	TData = Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetMessagesAdminOnly<
	TData = Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get settings - who can send messages
 */

export function useGroupsControllerGetMessagesAdminOnly<
	TData = Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetMessagesAdminOnly>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetMessagesAdminOnlyQueryOptions(
		id,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Gets the invite code for the group.
 */
export type groupsControllerGetInviteCodeResponse200 = {
	data: string;
	status: 200;
};

export type groupsControllerGetInviteCodeResponseSuccess =
	groupsControllerGetInviteCodeResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetInviteCodeResponse =
	groupsControllerGetInviteCodeResponseSuccess;

export const getGroupsControllerGetInviteCodeUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/invite-code`;
};

export const groupsControllerGetInviteCode = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetInviteCodeResponse> => {
	const res = await fetch(getGroupsControllerGetInviteCodeUrl(id, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetInviteCodeResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetInviteCodeResponse;
};

export const getGroupsControllerGetInviteCodeQueryKey = (
	id: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/groups/${id}/invite-code`,
	] as const;
};

export const getGroupsControllerGetInviteCodeQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerGetInviteCodeQueryKey(id, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetInviteCode>>
	> = ({ signal }) =>
		groupsControllerGetInviteCode(id, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetInviteCodeQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetInviteCode>>
>;
export type GroupsControllerGetInviteCodeQueryError = unknown;

export function useGroupsControllerGetInviteCode<
	TData = Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
	TError = unknown,
>(
	id: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetInviteCode>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetInviteCode<
	TData = Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetInviteCode>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetInviteCode<
	TData = Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Gets the invite code for the group.
 */

export function useGroupsControllerGetInviteCode<
	TData = Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetInviteCode>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetInviteCodeQueryOptions(
		id,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Invalidates the current group invite code and generates a new one.
 */
export type groupsControllerRevokeInviteCodeResponse200 = {
	data: string;
	status: 200;
};

export type groupsControllerRevokeInviteCodeResponseSuccess =
	groupsControllerRevokeInviteCodeResponse200 & {
		headers: Headers;
	};

export type groupsControllerRevokeInviteCodeResponse =
	groupsControllerRevokeInviteCodeResponseSuccess;

export const getGroupsControllerRevokeInviteCodeUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/invite-code/revoke`;
};

export const groupsControllerRevokeInviteCode = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerRevokeInviteCodeResponse> => {
	const res = await fetch(getGroupsControllerRevokeInviteCodeUrl(id, session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerRevokeInviteCodeResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerRevokeInviteCodeResponse;
};

export const getGroupsControllerRevokeInviteCodeMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerRevokeInviteCode>>,
		TError,
		{ id: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerRevokeInviteCode>>,
	TError,
	{ id: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerRevokeInviteCode"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerRevokeInviteCode>>,
		{ id: string; session?: unknown }
	> = (props) => {
		const { id, session } = props ?? {};

		return groupsControllerRevokeInviteCode(id, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerRevokeInviteCodeMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerRevokeInviteCode>>
>;

export type GroupsControllerRevokeInviteCodeMutationError = unknown;

/**
 * @summary Invalidates the current group invite code and generates a new one.
 */
export const useGroupsControllerRevokeInviteCode = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerRevokeInviteCode>>,
			TError,
			{ id: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerRevokeInviteCode>>,
	TError,
	{ id: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerRevokeInviteCodeMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get participants
 */
export type groupsControllerGetParticipantsResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerGetParticipantsResponseSuccess =
	groupsControllerGetParticipantsResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetParticipantsResponse =
	groupsControllerGetParticipantsResponseSuccess;

export const getGroupsControllerGetParticipantsUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/participants`;
};

export const groupsControllerGetParticipants = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetParticipantsResponse> => {
	const res = await fetch(getGroupsControllerGetParticipantsUrl(id, session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetParticipantsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetParticipantsResponse;
};

export const getGroupsControllerGetParticipantsQueryKey = (
	id: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/groups/${id}/participants`,
	] as const;
};

export const getGroupsControllerGetParticipantsQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerGetParticipantsQueryKey(id, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetParticipants>>
	> = ({ signal }) =>
		groupsControllerGetParticipants(id, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetParticipantsQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetParticipants>>
>;
export type GroupsControllerGetParticipantsQueryError = unknown;

export function useGroupsControllerGetParticipants<
	TData = Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
	TError = unknown,
>(
	id: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetParticipants>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetParticipants<
	TData = Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetParticipants>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetParticipants<
	TData = Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get participants
 */

export function useGroupsControllerGetParticipants<
	TData = Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetParticipants>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetParticipantsQueryOptions(
		id,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get group participants.
 */
export type groupsControllerGetGroupParticipantsResponse200 = {
	data: GroupParticipant[];
	status: 200;
};

export type groupsControllerGetGroupParticipantsResponseSuccess =
	groupsControllerGetGroupParticipantsResponse200 & {
		headers: Headers;
	};

export type groupsControllerGetGroupParticipantsResponse =
	groupsControllerGetGroupParticipantsResponseSuccess;

export const getGroupsControllerGetGroupParticipantsUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/participants/v2`;
};

export const groupsControllerGetGroupParticipants = async (
	id: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerGetGroupParticipantsResponse> => {
	const res = await fetch(
		getGroupsControllerGetGroupParticipantsUrl(id, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerGetGroupParticipantsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerGetGroupParticipantsResponse;
};

export const getGroupsControllerGetGroupParticipantsQueryKey = (
	id: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/groups/${id}/participants/v2`,
	] as const;
};

export const getGroupsControllerGetGroupParticipantsQueryOptions = <
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getGroupsControllerGetGroupParticipantsQueryKey(id, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>
	> = ({ signal }) =>
		groupsControllerGetGroupParticipants(id, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(session && id),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GroupsControllerGetGroupParticipantsQueryResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>
>;
export type GroupsControllerGetGroupParticipantsQueryError = unknown;

export function useGroupsControllerGetGroupParticipants<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
	TError = unknown,
>(
	id: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetGroupParticipants<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
					TError,
					Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useGroupsControllerGetGroupParticipants<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
	TError = unknown,
>(
	id: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get group participants.
 */

export function useGroupsControllerGetGroupParticipants<
	TData = Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
	TError = unknown,
>(
	id: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof groupsControllerGetGroupParticipants>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getGroupsControllerGetGroupParticipantsQueryOptions(
		id,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Add participants
 */
export type groupsControllerAddParticipantsResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerAddParticipantsResponseSuccess =
	groupsControllerAddParticipantsResponse200 & {
		headers: Headers;
	};

export type groupsControllerAddParticipantsResponse =
	groupsControllerAddParticipantsResponseSuccess;

export const getGroupsControllerAddParticipantsUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/participants/add`;
};

export const groupsControllerAddParticipants = async (
	id: string,
	participantsRequest: ParticipantsRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerAddParticipantsResponse> => {
	const res = await fetch(getGroupsControllerAddParticipantsUrl(id, session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(participantsRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerAddParticipantsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerAddParticipantsResponse;
};

export const getGroupsControllerAddParticipantsMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerAddParticipants>>,
		TError,
		{ id: string; data: ParticipantsRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerAddParticipants>>,
	TError,
	{ id: string; data: ParticipantsRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerAddParticipants"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerAddParticipants>>,
		{ id: string; data: ParticipantsRequest; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerAddParticipants(id, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerAddParticipantsMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerAddParticipants>>
>;
export type GroupsControllerAddParticipantsMutationBody = ParticipantsRequest;
export type GroupsControllerAddParticipantsMutationError = unknown;

/**
 * @summary Add participants
 */
export const useGroupsControllerAddParticipants = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerAddParticipants>>,
			TError,
			{ id: string; data: ParticipantsRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerAddParticipants>>,
	TError,
	{ id: string; data: ParticipantsRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerAddParticipantsMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Remove participants
 */
export type groupsControllerRemoveParticipantsResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerRemoveParticipantsResponseSuccess =
	groupsControllerRemoveParticipantsResponse200 & {
		headers: Headers;
	};

export type groupsControllerRemoveParticipantsResponse =
	groupsControllerRemoveParticipantsResponseSuccess;

export const getGroupsControllerRemoveParticipantsUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/participants/remove`;
};

export const groupsControllerRemoveParticipants = async (
	id: string,
	participantsRequest: ParticipantsRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerRemoveParticipantsResponse> => {
	const res = await fetch(
		getGroupsControllerRemoveParticipantsUrl(id, session),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(participantsRequest),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerRemoveParticipantsResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerRemoveParticipantsResponse;
};

export const getGroupsControllerRemoveParticipantsMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerRemoveParticipants>>,
		TError,
		{ id: string; data: ParticipantsRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerRemoveParticipants>>,
	TError,
	{ id: string; data: ParticipantsRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerRemoveParticipants"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerRemoveParticipants>>,
		{ id: string; data: ParticipantsRequest; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerRemoveParticipants(id, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerRemoveParticipantsMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerRemoveParticipants>>
>;
export type GroupsControllerRemoveParticipantsMutationBody =
	ParticipantsRequest;
export type GroupsControllerRemoveParticipantsMutationError = unknown;

/**
 * @summary Remove participants
 */
export const useGroupsControllerRemoveParticipants = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerRemoveParticipants>>,
			TError,
			{ id: string; data: ParticipantsRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerRemoveParticipants>>,
	TError,
	{ id: string; data: ParticipantsRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerRemoveParticipantsMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Promote participants to admin users.
 */
export type groupsControllerPromoteToAdminResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerPromoteToAdminResponseSuccess =
	groupsControllerPromoteToAdminResponse200 & {
		headers: Headers;
	};

export type groupsControllerPromoteToAdminResponse =
	groupsControllerPromoteToAdminResponseSuccess;

export const getGroupsControllerPromoteToAdminUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/admin/promote`;
};

export const groupsControllerPromoteToAdmin = async (
	id: string,
	participantsRequest: ParticipantsRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerPromoteToAdminResponse> => {
	const res = await fetch(getGroupsControllerPromoteToAdminUrl(id, session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(participantsRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerPromoteToAdminResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerPromoteToAdminResponse;
};

export const getGroupsControllerPromoteToAdminMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerPromoteToAdmin>>,
		TError,
		{ id: string; data: ParticipantsRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerPromoteToAdmin>>,
	TError,
	{ id: string; data: ParticipantsRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerPromoteToAdmin"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerPromoteToAdmin>>,
		{ id: string; data: ParticipantsRequest; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerPromoteToAdmin(id, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerPromoteToAdminMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerPromoteToAdmin>>
>;
export type GroupsControllerPromoteToAdminMutationBody = ParticipantsRequest;
export type GroupsControllerPromoteToAdminMutationError = unknown;

/**
 * @summary Promote participants to admin users.
 */
export const useGroupsControllerPromoteToAdmin = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerPromoteToAdmin>>,
			TError,
			{ id: string; data: ParticipantsRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerPromoteToAdmin>>,
	TError,
	{ id: string; data: ParticipantsRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerPromoteToAdminMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Demotes participants to regular users.
 */
export type groupsControllerDemoteToAdminResponse200 = {
	data: void;
	status: 200;
};

export type groupsControllerDemoteToAdminResponseSuccess =
	groupsControllerDemoteToAdminResponse200 & {
		headers: Headers;
	};

export type groupsControllerDemoteToAdminResponse =
	groupsControllerDemoteToAdminResponseSuccess;

export const getGroupsControllerDemoteToAdminUrl = (
	id: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/groups/${id}/admin/demote`;
};

export const groupsControllerDemoteToAdmin = async (
	id: string,
	participantsRequest: ParticipantsRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<groupsControllerDemoteToAdminResponse> => {
	const res = await fetch(getGroupsControllerDemoteToAdminUrl(id, session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(participantsRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: groupsControllerDemoteToAdminResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as groupsControllerDemoteToAdminResponse;
};

export const getGroupsControllerDemoteToAdminMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof groupsControllerDemoteToAdmin>>,
		TError,
		{ id: string; data: ParticipantsRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof groupsControllerDemoteToAdmin>>,
	TError,
	{ id: string; data: ParticipantsRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["groupsControllerDemoteToAdmin"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof groupsControllerDemoteToAdmin>>,
		{ id: string; data: ParticipantsRequest; session?: unknown }
	> = (props) => {
		const { id, data, session } = props ?? {};

		return groupsControllerDemoteToAdmin(id, data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type GroupsControllerDemoteToAdminMutationResult = NonNullable<
	Awaited<ReturnType<typeof groupsControllerDemoteToAdmin>>
>;
export type GroupsControllerDemoteToAdminMutationBody = ParticipantsRequest;
export type GroupsControllerDemoteToAdminMutationError = unknown;

/**
 * @summary Demotes participants to regular users.
 */
export const useGroupsControllerDemoteToAdmin = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof groupsControllerDemoteToAdmin>>,
			TError,
			{ id: string; data: ParticipantsRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof groupsControllerDemoteToAdmin>>,
	TError,
	{ id: string; data: ParticipantsRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getGroupsControllerDemoteToAdminMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Set session presence
 */
export type presenceControllerSetPresenceResponse201 = {
	data: void;
	status: 201;
};

export type presenceControllerSetPresenceResponseSuccess =
	presenceControllerSetPresenceResponse201 & {
		headers: Headers;
	};

export type presenceControllerSetPresenceResponse =
	presenceControllerSetPresenceResponseSuccess;

export const getPresenceControllerSetPresenceUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/presence`;
};

export const presenceControllerSetPresence = async (
	wAHASessionPresence: WAHASessionPresence,
	session: unknown = "default",
	options?: RequestInit,
): Promise<presenceControllerSetPresenceResponse> => {
	const res = await fetch(getPresenceControllerSetPresenceUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(wAHASessionPresence),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: presenceControllerSetPresenceResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as presenceControllerSetPresenceResponse;
};

export const getPresenceControllerSetPresenceMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof presenceControllerSetPresence>>,
		TError,
		{ data: WAHASessionPresence; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof presenceControllerSetPresence>>,
	TError,
	{ data: WAHASessionPresence; session?: unknown },
	TContext
> => {
	const mutationKey = ["presenceControllerSetPresence"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof presenceControllerSetPresence>>,
		{ data: WAHASessionPresence; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return presenceControllerSetPresence(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PresenceControllerSetPresenceMutationResult = NonNullable<
	Awaited<ReturnType<typeof presenceControllerSetPresence>>
>;
export type PresenceControllerSetPresenceMutationBody = WAHASessionPresence;
export type PresenceControllerSetPresenceMutationError = unknown;

/**
 * @summary Set session presence
 */
export const usePresenceControllerSetPresence = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof presenceControllerSetPresence>>,
			TError,
			{ data: WAHASessionPresence; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof presenceControllerSetPresence>>,
	TError,
	{ data: WAHASessionPresence; session?: unknown },
	TContext
> => {
	return useMutation(
		getPresenceControllerSetPresenceMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get all subscribed presence information.
 */
export type presenceControllerGetPresenceAllResponse200 = {
	data: WAHAChatPresences[];
	status: 200;
};

export type presenceControllerGetPresenceAllResponseSuccess =
	presenceControllerGetPresenceAllResponse200 & {
		headers: Headers;
	};

export type presenceControllerGetPresenceAllResponse =
	presenceControllerGetPresenceAllResponseSuccess;

export const getPresenceControllerGetPresenceAllUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/presence`;
};

export const presenceControllerGetPresenceAll = async (
	session: unknown = "default",
	options?: RequestInit,
): Promise<presenceControllerGetPresenceAllResponse> => {
	const res = await fetch(getPresenceControllerGetPresenceAllUrl(session), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: presenceControllerGetPresenceAllResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as presenceControllerGetPresenceAllResponse;
};

export const getPresenceControllerGetPresenceAllQueryKey = (
	session: unknown = "default",
) => {
	return [`https://waha.gnardawgs.surf/api/${session}/presence`] as const;
};

export const getPresenceControllerGetPresenceAllQueryOptions = <
	TData = Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getPresenceControllerGetPresenceAllQueryKey(session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>
	> = ({ signal }) =>
		presenceControllerGetPresenceAll(session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PresenceControllerGetPresenceAllQueryResult = NonNullable<
	Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>
>;
export type PresenceControllerGetPresenceAllQueryError = unknown;

export function usePresenceControllerGetPresenceAll<
	TData = Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
	TError = unknown,
>(
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
					TError,
					Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePresenceControllerGetPresenceAll<
	TData = Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
					TError,
					Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePresenceControllerGetPresenceAll<
	TData = Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
	TError = unknown,
>(
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get all subscribed presence information.
 */

export function usePresenceControllerGetPresenceAll<
	TData = Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
	TError = unknown,
>(
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresenceAll>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getPresenceControllerGetPresenceAllQueryOptions(
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get the presence for the chat id. If it hasn't been subscribed - it also subscribes to it.
 */
export type presenceControllerGetPresenceResponse200 = {
	data: WAHAChatPresences;
	status: 200;
};

export type presenceControllerGetPresenceResponseSuccess =
	presenceControllerGetPresenceResponse200 & {
		headers: Headers;
	};

export type presenceControllerGetPresenceResponse =
	presenceControllerGetPresenceResponseSuccess;

export const getPresenceControllerGetPresenceUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/presence/${chatId}`;
};

export const presenceControllerGetPresence = async (
	chatId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<presenceControllerGetPresenceResponse> => {
	const res = await fetch(
		getPresenceControllerGetPresenceUrl(chatId, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: presenceControllerGetPresenceResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as presenceControllerGetPresenceResponse;
};

export const getPresenceControllerGetPresenceQueryKey = (
	chatId: string,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/${session}/presence/${chatId}`,
	] as const;
};

export const getPresenceControllerGetPresenceQueryOptions = <
	TData = Awaited<ReturnType<typeof presenceControllerGetPresence>>,
	TError = unknown,
>(
	chatId: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresence>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getPresenceControllerGetPresenceQueryKey(chatId, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof presenceControllerGetPresence>>
	> = ({ signal }) =>
		presenceControllerGetPresence(chatId, session, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(session && chatId),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof presenceControllerGetPresence>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PresenceControllerGetPresenceQueryResult = NonNullable<
	Awaited<ReturnType<typeof presenceControllerGetPresence>>
>;
export type PresenceControllerGetPresenceQueryError = unknown;

export function usePresenceControllerGetPresence<
	TData = Awaited<ReturnType<typeof presenceControllerGetPresence>>,
	TError = unknown,
>(
	chatId: string,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresence>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof presenceControllerGetPresence>>,
					TError,
					Awaited<ReturnType<typeof presenceControllerGetPresence>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePresenceControllerGetPresence<
	TData = Awaited<ReturnType<typeof presenceControllerGetPresence>>,
	TError = unknown,
>(
	chatId: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresence>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof presenceControllerGetPresence>>,
					TError,
					Awaited<ReturnType<typeof presenceControllerGetPresence>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePresenceControllerGetPresence<
	TData = Awaited<ReturnType<typeof presenceControllerGetPresence>>,
	TError = unknown,
>(
	chatId: string,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresence>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the presence for the chat id. If it hasn't been subscribed - it also subscribes to it.
 */

export function usePresenceControllerGetPresence<
	TData = Awaited<ReturnType<typeof presenceControllerGetPresence>>,
	TError = unknown,
>(
	chatId: string,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof presenceControllerGetPresence>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getPresenceControllerGetPresenceQueryOptions(
		chatId,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Subscribe to presence events for the chat.
 */
export type presenceControllerSubscribeResponse201 = {
	data: void;
	status: 201;
};

export type presenceControllerSubscribeResponseSuccess =
	presenceControllerSubscribeResponse201 & {
		headers: Headers;
	};

export type presenceControllerSubscribeResponse =
	presenceControllerSubscribeResponseSuccess;

export const getPresenceControllerSubscribeUrl = (
	chatId: string,
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/presence/${chatId}/subscribe`;
};

export const presenceControllerSubscribe = async (
	chatId: string,
	session: unknown = "default",
	options?: RequestInit,
): Promise<presenceControllerSubscribeResponse> => {
	const res = await fetch(getPresenceControllerSubscribeUrl(chatId, session), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: presenceControllerSubscribeResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as presenceControllerSubscribeResponse;
};

export const getPresenceControllerSubscribeMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof presenceControllerSubscribe>>,
		TError,
		{ chatId: string; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof presenceControllerSubscribe>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	const mutationKey = ["presenceControllerSubscribe"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof presenceControllerSubscribe>>,
		{ chatId: string; session?: unknown }
	> = (props) => {
		const { chatId, session } = props ?? {};

		return presenceControllerSubscribe(chatId, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PresenceControllerSubscribeMutationResult = NonNullable<
	Awaited<ReturnType<typeof presenceControllerSubscribe>>
>;

export type PresenceControllerSubscribeMutationError = unknown;

/**
 * @summary Subscribe to presence events for the chat.
 */
export const usePresenceControllerSubscribe = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof presenceControllerSubscribe>>,
			TError,
			{ chatId: string; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof presenceControllerSubscribe>>,
	TError,
	{ chatId: string; session?: unknown },
	TContext
> => {
	return useMutation(
		getPresenceControllerSubscribeMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get a screenshot of the current WhatsApp session (**WEBJS** only)
 */
export type screenshotControllerScreenshotResponse200ImageJpeg = {
	data: Blob;
	status: 200;
};

export type screenshotControllerScreenshotResponse200ApplicationJson = {
	data: Base64File;
	status: 200;
};

export type screenshotControllerScreenshotResponseSuccess = (
	| screenshotControllerScreenshotResponse200ImageJpeg
	| screenshotControllerScreenshotResponse200ApplicationJson
) & {
	headers: Headers;
};

export type screenshotControllerScreenshotResponse =
	screenshotControllerScreenshotResponseSuccess;

export const getScreenshotControllerScreenshotUrl = (
	params: ScreenshotControllerScreenshotParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/screenshot?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/screenshot`;
};

export const screenshotControllerScreenshot = async (
	params: ScreenshotControllerScreenshotParams,
	options?: RequestInit,
): Promise<screenshotControllerScreenshotResponse> => {
	const res = await fetch(getScreenshotControllerScreenshotUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: screenshotControllerScreenshotResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as screenshotControllerScreenshotResponse;
};

export const getScreenshotControllerScreenshotQueryKey = (
	params?: ScreenshotControllerScreenshotParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/screenshot`,
		...(params ? [params] : []),
	] as const;
};

export const getScreenshotControllerScreenshotQueryOptions = <
	TData = Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
	TError = unknown,
>(
	params: ScreenshotControllerScreenshotParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getScreenshotControllerScreenshotQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof screenshotControllerScreenshot>>
	> = ({ signal }) =>
		screenshotControllerScreenshot(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ScreenshotControllerScreenshotQueryResult = NonNullable<
	Awaited<ReturnType<typeof screenshotControllerScreenshot>>
>;
export type ScreenshotControllerScreenshotQueryError = unknown;

export function useScreenshotControllerScreenshot<
	TData = Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
	TError = unknown,
>(
	params: ScreenshotControllerScreenshotParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
					TError,
					Awaited<ReturnType<typeof screenshotControllerScreenshot>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useScreenshotControllerScreenshot<
	TData = Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
	TError = unknown,
>(
	params: ScreenshotControllerScreenshotParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
					TError,
					Awaited<ReturnType<typeof screenshotControllerScreenshot>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useScreenshotControllerScreenshot<
	TData = Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
	TError = unknown,
>(
	params: ScreenshotControllerScreenshotParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get a screenshot of the current WhatsApp session (**WEBJS** only)
 */

export function useScreenshotControllerScreenshot<
	TData = Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
	TError = unknown,
>(
	params: ScreenshotControllerScreenshotParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof screenshotControllerScreenshot>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getScreenshotControllerScreenshotQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Send an event message
 */
export type eventsControllerSendEventResponse201 = {
	data: WAMessage;
	status: 201;
};

export type eventsControllerSendEventResponseSuccess =
	eventsControllerSendEventResponse201 & {
		headers: Headers;
	};

export type eventsControllerSendEventResponse =
	eventsControllerSendEventResponseSuccess;

export const getEventsControllerSendEventUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/events`;
};

export const eventsControllerSendEvent = async (
	eventMessageRequest: EventMessageRequest,
	session: unknown = "default",
	options?: RequestInit,
): Promise<eventsControllerSendEventResponse> => {
	const res = await fetch(getEventsControllerSendEventUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(eventMessageRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: eventsControllerSendEventResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as eventsControllerSendEventResponse;
};

export const getEventsControllerSendEventMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof eventsControllerSendEvent>>,
		TError,
		{ data: EventMessageRequest; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof eventsControllerSendEvent>>,
	TError,
	{ data: EventMessageRequest; session?: unknown },
	TContext
> => {
	const mutationKey = ["eventsControllerSendEvent"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof eventsControllerSendEvent>>,
		{ data: EventMessageRequest; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return eventsControllerSendEvent(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type EventsControllerSendEventMutationResult = NonNullable<
	Awaited<ReturnType<typeof eventsControllerSendEvent>>
>;
export type EventsControllerSendEventMutationBody = EventMessageRequest;
export type EventsControllerSendEventMutationError = unknown;

/**
 * @summary Send an event message
 */
export const useEventsControllerSendEvent = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof eventsControllerSendEvent>>,
			TError,
			{ data: EventMessageRequest; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof eventsControllerSendEvent>>,
	TError,
	{ data: EventMessageRequest; session?: unknown },
	TContext
> => {
	return useMutation(
		getEventsControllerSendEventMutationOptions(options),
		queryClient,
	);
};

/**
 * Check if the server is alive and responding to requests.
 * @summary Ping the server
 */
export type pingControllerPingResponse200 = {
	data: PingResponse;
	status: 200;
};

export type pingControllerPingResponseSuccess =
	pingControllerPingResponse200 & {
		headers: Headers;
	};

export type pingControllerPingResponse = pingControllerPingResponseSuccess;

export const getPingControllerPingUrl = () => {
	return `https://waha.gnardawgs.surf/ping`;
};

export const pingControllerPing = async (
	options?: RequestInit,
): Promise<pingControllerPingResponse> => {
	const res = await fetch(getPingControllerPingUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: pingControllerPingResponse["data"] = body ? JSON.parse(body) : {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as pingControllerPingResponse;
};

export const getPingControllerPingQueryKey = () => {
	return [`https://waha.gnardawgs.surf/ping`] as const;
};

export const getPingControllerPingQueryOptions = <
	TData = Awaited<ReturnType<typeof pingControllerPing>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof pingControllerPing>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getPingControllerPingQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof pingControllerPing>>
	> = ({ signal }) => pingControllerPing({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof pingControllerPing>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PingControllerPingQueryResult = NonNullable<
	Awaited<ReturnType<typeof pingControllerPing>>
>;
export type PingControllerPingQueryError = unknown;

export function usePingControllerPing<
	TData = Awaited<ReturnType<typeof pingControllerPing>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof pingControllerPing>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof pingControllerPing>>,
					TError,
					Awaited<ReturnType<typeof pingControllerPing>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePingControllerPing<
	TData = Awaited<ReturnType<typeof pingControllerPing>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof pingControllerPing>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof pingControllerPing>>,
					TError,
					Awaited<ReturnType<typeof pingControllerPing>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePingControllerPing<
	TData = Awaited<ReturnType<typeof pingControllerPing>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof pingControllerPing>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Ping the server
 */

export function usePingControllerPing<
	TData = Awaited<ReturnType<typeof pingControllerPing>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof pingControllerPing>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getPingControllerPingQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Perform all health checks and return the server's health status.
 * @summary Check the health of the server
 */
export type healthControllerCheckResponse200 = {
	data: HealthControllerCheck200;
	status: 200;
};

export type healthControllerCheckResponse503 = {
	data: HealthControllerCheck503;
	status: 503;
};

export type healthControllerCheckResponseSuccess =
	healthControllerCheckResponse200 & {
		headers: Headers;
	};
export type healthControllerCheckResponseError =
	healthControllerCheckResponse503 & {
		headers: Headers;
	};

export type healthControllerCheckResponse =
	| healthControllerCheckResponseSuccess
	| healthControllerCheckResponseError;

export const getHealthControllerCheckUrl = () => {
	return `https://waha.gnardawgs.surf/health`;
};

export const healthControllerCheck = async (
	options?: RequestInit,
): Promise<healthControllerCheckResponse> => {
	const res = await fetch(getHealthControllerCheckUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: healthControllerCheckResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as healthControllerCheckResponse;
};

export const getHealthControllerCheckQueryKey = () => {
	return [`https://waha.gnardawgs.surf/health`] as const;
};

export const getHealthControllerCheckQueryOptions = <
	TData = Awaited<ReturnType<typeof healthControllerCheck>>,
	TError = HealthControllerCheck503,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof healthControllerCheck>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getHealthControllerCheckQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof healthControllerCheck>>
	> = ({ signal }) => healthControllerCheck({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof healthControllerCheck>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthControllerCheckQueryResult = NonNullable<
	Awaited<ReturnType<typeof healthControllerCheck>>
>;
export type HealthControllerCheckQueryError = HealthControllerCheck503;

export function useHealthControllerCheck<
	TData = Awaited<ReturnType<typeof healthControllerCheck>>,
	TError = HealthControllerCheck503,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof healthControllerCheck>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof healthControllerCheck>>,
					TError,
					Awaited<ReturnType<typeof healthControllerCheck>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthControllerCheck<
	TData = Awaited<ReturnType<typeof healthControllerCheck>>,
	TError = HealthControllerCheck503,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof healthControllerCheck>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof healthControllerCheck>>,
					TError,
					Awaited<ReturnType<typeof healthControllerCheck>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthControllerCheck<
	TData = Awaited<ReturnType<typeof healthControllerCheck>>,
	TError = HealthControllerCheck503,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof healthControllerCheck>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Check the health of the server
 */

export function useHealthControllerCheck<
	TData = Awaited<ReturnType<typeof healthControllerCheck>>,
	TError = HealthControllerCheck503,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof healthControllerCheck>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getHealthControllerCheckQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get the version of the server
 */
export type serverControllerGetResponse200 = {
	data: WAHAEnvironment;
	status: 200;
};

export type serverControllerGetResponseSuccess =
	serverControllerGetResponse200 & {
		headers: Headers;
	};

export type serverControllerGetResponse = serverControllerGetResponseSuccess;

export const getServerControllerGetUrl = () => {
	return `https://waha.gnardawgs.surf/api/server/version`;
};

export const serverControllerGet = async (
	options?: RequestInit,
): Promise<serverControllerGetResponse> => {
	const res = await fetch(getServerControllerGetUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: serverControllerGetResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as serverControllerGetResponse;
};

export const getServerControllerGetQueryKey = () => {
	return [`https://waha.gnardawgs.surf/api/server/version`] as const;
};

export const getServerControllerGetQueryOptions = <
	TData = Awaited<ReturnType<typeof serverControllerGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof serverControllerGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getServerControllerGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof serverControllerGet>>
	> = ({ signal }) => serverControllerGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof serverControllerGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ServerControllerGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof serverControllerGet>>
>;
export type ServerControllerGetQueryError = unknown;

export function useServerControllerGet<
	TData = Awaited<ReturnType<typeof serverControllerGet>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverControllerGet>>,
					TError,
					Awaited<ReturnType<typeof serverControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerControllerGet<
	TData = Awaited<ReturnType<typeof serverControllerGet>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverControllerGet>>,
					TError,
					Awaited<ReturnType<typeof serverControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerControllerGet<
	TData = Awaited<ReturnType<typeof serverControllerGet>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the version of the server
 */

export function useServerControllerGet<
	TData = Awaited<ReturnType<typeof serverControllerGet>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getServerControllerGetQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get the server environment
 */
export type serverControllerEnvironmentResponse200 = {
	data: ServerControllerEnvironment200;
	status: 200;
};

export type serverControllerEnvironmentResponseSuccess =
	serverControllerEnvironmentResponse200 & {
		headers: Headers;
	};

export type serverControllerEnvironmentResponse =
	serverControllerEnvironmentResponseSuccess;

export const getServerControllerEnvironmentUrl = (
	params?: ServerControllerEnvironmentParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/server/environment?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/server/environment`;
};

export const serverControllerEnvironment = async (
	params?: ServerControllerEnvironmentParams,
	options?: RequestInit,
): Promise<serverControllerEnvironmentResponse> => {
	const res = await fetch(getServerControllerEnvironmentUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: serverControllerEnvironmentResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as serverControllerEnvironmentResponse;
};

export const getServerControllerEnvironmentQueryKey = (
	params?: ServerControllerEnvironmentParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/server/environment`,
		...(params ? [params] : []),
	] as const;
};

export const getServerControllerEnvironmentQueryOptions = <
	TData = Awaited<ReturnType<typeof serverControllerEnvironment>>,
	TError = unknown,
>(
	params?: ServerControllerEnvironmentParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerEnvironment>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getServerControllerEnvironmentQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof serverControllerEnvironment>>
	> = ({ signal }) =>
		serverControllerEnvironment(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof serverControllerEnvironment>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ServerControllerEnvironmentQueryResult = NonNullable<
	Awaited<ReturnType<typeof serverControllerEnvironment>>
>;
export type ServerControllerEnvironmentQueryError = unknown;

export function useServerControllerEnvironment<
	TData = Awaited<ReturnType<typeof serverControllerEnvironment>>,
	TError = unknown,
>(
	params: undefined | ServerControllerEnvironmentParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerEnvironment>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverControllerEnvironment>>,
					TError,
					Awaited<ReturnType<typeof serverControllerEnvironment>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerControllerEnvironment<
	TData = Awaited<ReturnType<typeof serverControllerEnvironment>>,
	TError = unknown,
>(
	params?: ServerControllerEnvironmentParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerEnvironment>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverControllerEnvironment>>,
					TError,
					Awaited<ReturnType<typeof serverControllerEnvironment>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerControllerEnvironment<
	TData = Awaited<ReturnType<typeof serverControllerEnvironment>>,
	TError = unknown,
>(
	params?: ServerControllerEnvironmentParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerEnvironment>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the server environment
 */

export function useServerControllerEnvironment<
	TData = Awaited<ReturnType<typeof serverControllerEnvironment>>,
	TError = unknown,
>(
	params?: ServerControllerEnvironmentParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerEnvironment>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getServerControllerEnvironmentQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Get the server status
 */
export type serverControllerStatusResponse200 = {
	data: ServerStatusResponse;
	status: 200;
};

export type serverControllerStatusResponseSuccess =
	serverControllerStatusResponse200 & {
		headers: Headers;
	};

export type serverControllerStatusResponse =
	serverControllerStatusResponseSuccess;

export const getServerControllerStatusUrl = () => {
	return `https://waha.gnardawgs.surf/api/server/status`;
};

export const serverControllerStatus = async (
	options?: RequestInit,
): Promise<serverControllerStatusResponse> => {
	const res = await fetch(getServerControllerStatusUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: serverControllerStatusResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as serverControllerStatusResponse;
};

export const getServerControllerStatusQueryKey = () => {
	return [`https://waha.gnardawgs.surf/api/server/status`] as const;
};

export const getServerControllerStatusQueryOptions = <
	TData = Awaited<ReturnType<typeof serverControllerStatus>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof serverControllerStatus>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getServerControllerStatusQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof serverControllerStatus>>
	> = ({ signal }) => serverControllerStatus({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof serverControllerStatus>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ServerControllerStatusQueryResult = NonNullable<
	Awaited<ReturnType<typeof serverControllerStatus>>
>;
export type ServerControllerStatusQueryError = unknown;

export function useServerControllerStatus<
	TData = Awaited<ReturnType<typeof serverControllerStatus>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerStatus>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverControllerStatus>>,
					TError,
					Awaited<ReturnType<typeof serverControllerStatus>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerControllerStatus<
	TData = Awaited<ReturnType<typeof serverControllerStatus>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerStatus>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverControllerStatus>>,
					TError,
					Awaited<ReturnType<typeof serverControllerStatus>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerControllerStatus<
	TData = Awaited<ReturnType<typeof serverControllerStatus>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerStatus>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get the server status
 */

export function useServerControllerStatus<
	TData = Awaited<ReturnType<typeof serverControllerStatus>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverControllerStatus>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getServerControllerStatusQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * If you're using docker, after calling this endpoint Docker will start a new container, so you can use this endpoint to restart the server
 * @summary Stop (and restart) the server
 */
export type serverControllerStopResponse201 = {
	data: StopResponse;
	status: 201;
};

export type serverControllerStopResponseSuccess =
	serverControllerStopResponse201 & {
		headers: Headers;
	};

export type serverControllerStopResponse = serverControllerStopResponseSuccess;

export const getServerControllerStopUrl = () => {
	return `https://waha.gnardawgs.surf/api/server/stop`;
};

export const serverControllerStop = async (
	stopRequest: StopRequest,
	options?: RequestInit,
): Promise<serverControllerStopResponse> => {
	const res = await fetch(getServerControllerStopUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(stopRequest),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: serverControllerStopResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as serverControllerStopResponse;
};

export const getServerControllerStopMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof serverControllerStop>>,
		TError,
		{ data: StopRequest },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof serverControllerStop>>,
	TError,
	{ data: StopRequest },
	TContext
> => {
	const mutationKey = ["serverControllerStop"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof serverControllerStop>>,
		{ data: StopRequest }
	> = (props) => {
		const { data } = props ?? {};

		return serverControllerStop(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ServerControllerStopMutationResult = NonNullable<
	Awaited<ReturnType<typeof serverControllerStop>>
>;
export type ServerControllerStopMutationBody = StopRequest;
export type ServerControllerStopMutationError = unknown;

/**
 * @summary Stop (and restart) the server
 */
export const useServerControllerStop = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof serverControllerStop>>,
			TError,
			{ data: StopRequest },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof serverControllerStop>>,
	TError,
	{ data: StopRequest },
	TContext
> => {
	return useMutation(
		getServerControllerStopMutationOptions(options),
		queryClient,
	);
};

/**
 * Uses the Node.js inspector profiler to capture a .cpuprofile
 * @summary Collect and return a CPU profile for the current nodejs process
 */
export type serverDebugControllerCpuProfileResponse200 = {
	data: void;
	status: 200;
};

export type serverDebugControllerCpuProfileResponseSuccess =
	serverDebugControllerCpuProfileResponse200 & {
		headers: Headers;
	};

export type serverDebugControllerCpuProfileResponse =
	serverDebugControllerCpuProfileResponseSuccess;

export const getServerDebugControllerCpuProfileUrl = (
	params?: ServerDebugControllerCpuProfileParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/server/debug/cpu?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/server/debug/cpu`;
};

export const serverDebugControllerCpuProfile = async (
	params?: ServerDebugControllerCpuProfileParams,
	options?: RequestInit,
): Promise<serverDebugControllerCpuProfileResponse> => {
	const res = await fetch(getServerDebugControllerCpuProfileUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: serverDebugControllerCpuProfileResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as serverDebugControllerCpuProfileResponse;
};

export const getServerDebugControllerCpuProfileQueryKey = (
	params?: ServerDebugControllerCpuProfileParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/server/debug/cpu`,
		...(params ? [params] : []),
	] as const;
};

export const getServerDebugControllerCpuProfileQueryOptions = <
	TData = Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
	TError = unknown,
>(
	params?: ServerDebugControllerCpuProfileParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getServerDebugControllerCpuProfileQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>
	> = ({ signal }) =>
		serverDebugControllerCpuProfile(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ServerDebugControllerCpuProfileQueryResult = NonNullable<
	Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>
>;
export type ServerDebugControllerCpuProfileQueryError = unknown;

export function useServerDebugControllerCpuProfile<
	TData = Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
	TError = unknown,
>(
	params: undefined | ServerDebugControllerCpuProfileParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
					TError,
					Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerDebugControllerCpuProfile<
	TData = Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
	TError = unknown,
>(
	params?: ServerDebugControllerCpuProfileParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
					TError,
					Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerDebugControllerCpuProfile<
	TData = Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
	TError = unknown,
>(
	params?: ServerDebugControllerCpuProfileParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Collect and return a CPU profile for the current nodejs process
 */

export function useServerDebugControllerCpuProfile<
	TData = Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
	TError = unknown,
>(
	params?: ServerDebugControllerCpuProfileParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerCpuProfile>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getServerDebugControllerCpuProfileQueryOptions(
		params,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Return a heapsnapshot of the server's memory
 * @summary Return a heapsnapshot for the current nodejs process
 */
export type serverDebugControllerHeapsnapshotResponse200 = {
	data: void;
	status: 200;
};

export type serverDebugControllerHeapsnapshotResponseSuccess =
	serverDebugControllerHeapsnapshotResponse200 & {
		headers: Headers;
	};

export type serverDebugControllerHeapsnapshotResponse =
	serverDebugControllerHeapsnapshotResponseSuccess;

export const getServerDebugControllerHeapsnapshotUrl = () => {
	return `https://waha.gnardawgs.surf/api/server/debug/heapsnapshot`;
};

export const serverDebugControllerHeapsnapshot = async (
	options?: RequestInit,
): Promise<serverDebugControllerHeapsnapshotResponse> => {
	const res = await fetch(getServerDebugControllerHeapsnapshotUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: serverDebugControllerHeapsnapshotResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as serverDebugControllerHeapsnapshotResponse;
};

export const getServerDebugControllerHeapsnapshotQueryKey = () => {
	return [`https://waha.gnardawgs.surf/api/server/debug/heapsnapshot`] as const;
};

export const getServerDebugControllerHeapsnapshotQueryOptions = <
	TData = Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getServerDebugControllerHeapsnapshotQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>
	> = ({ signal }) =>
		serverDebugControllerHeapsnapshot({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ServerDebugControllerHeapsnapshotQueryResult = NonNullable<
	Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>
>;
export type ServerDebugControllerHeapsnapshotQueryError = unknown;

export function useServerDebugControllerHeapsnapshot<
	TData = Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
					TError,
					Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerDebugControllerHeapsnapshot<
	TData = Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
					TError,
					Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerDebugControllerHeapsnapshot<
	TData = Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Return a heapsnapshot for the current nodejs process
 */

export function useServerDebugControllerHeapsnapshot<
	TData = Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerHeapsnapshot>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getServerDebugControllerHeapsnapshotQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Uses https://pptr.dev/api/puppeteer.tracing
 * @summary Collect and get a trace.json for Chrome DevTools
 */
export type serverDebugControllerBrowserTraceResponse200 = {
	data: void;
	status: 200;
};

export type serverDebugControllerBrowserTraceResponseSuccess =
	serverDebugControllerBrowserTraceResponse200 & {
		headers: Headers;
	};

export type serverDebugControllerBrowserTraceResponse =
	serverDebugControllerBrowserTraceResponseSuccess;

export const getServerDebugControllerBrowserTraceUrl = (
	params: ServerDebugControllerBrowserTraceParams,
	session: unknown = "default",
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/server/debug/browser/trace/${session}?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/server/debug/browser/trace/${session}`;
};

export const serverDebugControllerBrowserTrace = async (
	params: ServerDebugControllerBrowserTraceParams,
	session: unknown = "default",
	options?: RequestInit,
): Promise<serverDebugControllerBrowserTraceResponse> => {
	const res = await fetch(
		getServerDebugControllerBrowserTraceUrl(params, session),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: serverDebugControllerBrowserTraceResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as serverDebugControllerBrowserTraceResponse;
};

export const getServerDebugControllerBrowserTraceQueryKey = (
	params?: ServerDebugControllerBrowserTraceParams,
	session: unknown = "default",
) => {
	return [
		`https://waha.gnardawgs.surf/api/server/debug/browser/trace/${session}`,
		...(params ? [params] : []),
	] as const;
};

export const getServerDebugControllerBrowserTraceQueryOptions = <
	TData = Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
	TError = unknown,
>(
	params: ServerDebugControllerBrowserTraceParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getServerDebugControllerBrowserTraceQueryKey(params, session);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>
	> = ({ signal }) =>
		serverDebugControllerBrowserTrace(params, session, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!session,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ServerDebugControllerBrowserTraceQueryResult = NonNullable<
	Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>
>;
export type ServerDebugControllerBrowserTraceQueryError = unknown;

export function useServerDebugControllerBrowserTrace<
	TData = Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
	TError = unknown,
>(
	params: ServerDebugControllerBrowserTraceParams,
	session: undefined | unknown,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
					TError,
					Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerDebugControllerBrowserTrace<
	TData = Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
	TError = unknown,
>(
	params: ServerDebugControllerBrowserTraceParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
					TError,
					Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerDebugControllerBrowserTrace<
	TData = Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
	TError = unknown,
>(
	params: ServerDebugControllerBrowserTraceParams,
	session?: unknown,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Collect and get a trace.json for Chrome DevTools
 */

export function useServerDebugControllerBrowserTrace<
	TData = Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
	TError = unknown,
>(
	params: ServerDebugControllerBrowserTraceParams,
	session: unknown = "default",
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof serverDebugControllerBrowserTrace>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getServerDebugControllerBrowserTraceQueryOptions(
		params,
		session,
		options,
	);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Use 'GET /api/server/version' instead
 * @deprecated
 * @summary Get the server version
 */
export type versionControllerGetResponse200 = {
	data: WAHAEnvironment;
	status: 200;
};

export type versionControllerGetResponseSuccess =
	versionControllerGetResponse200 & {
		headers: Headers;
	};

export type versionControllerGetResponse = versionControllerGetResponseSuccess;

export const getVersionControllerGetUrl = () => {
	return `https://waha.gnardawgs.surf/api/version`;
};

export const versionControllerGet = async (
	options?: RequestInit,
): Promise<versionControllerGetResponse> => {
	const res = await fetch(getVersionControllerGetUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: versionControllerGetResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as versionControllerGetResponse;
};

export const getVersionControllerGetQueryKey = () => {
	return [`https://waha.gnardawgs.surf/api/version`] as const;
};

export const getVersionControllerGetQueryOptions = <
	TData = Awaited<ReturnType<typeof versionControllerGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof versionControllerGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getVersionControllerGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof versionControllerGet>>
	> = ({ signal }) => versionControllerGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof versionControllerGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type VersionControllerGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof versionControllerGet>>
>;
export type VersionControllerGetQueryError = unknown;

export function useVersionControllerGet<
	TData = Awaited<ReturnType<typeof versionControllerGet>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof versionControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof versionControllerGet>>,
					TError,
					Awaited<ReturnType<typeof versionControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionControllerGet<
	TData = Awaited<ReturnType<typeof versionControllerGet>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof versionControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof versionControllerGet>>,
					TError,
					Awaited<ReturnType<typeof versionControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useVersionControllerGet<
	TData = Awaited<ReturnType<typeof versionControllerGet>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof versionControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @deprecated
 * @summary Get the server version
 */

export function useVersionControllerGet<
	TData = Awaited<ReturnType<typeof versionControllerGet>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof versionControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getVersionControllerGetQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Convert voice to WhatsApp format (opus)
 */
export type mediaControllerConvertVoiceResponse200AudioOggCodecsOpus = {
	data: Blob;
	status: 200;
};

export type mediaControllerConvertVoiceResponse200ApplicationJson = {
	data: Base64File;
	status: 200;
};

export type mediaControllerConvertVoiceResponse201 = {
	data: void;
	status: 201;
};

export type mediaControllerConvertVoiceResponseSuccess = (
	| mediaControllerConvertVoiceResponse200AudioOggCodecsOpus
	| mediaControllerConvertVoiceResponse200ApplicationJson
	| mediaControllerConvertVoiceResponse201
) & {
	headers: Headers;
};

export type mediaControllerConvertVoiceResponse =
	mediaControllerConvertVoiceResponseSuccess;

export const getMediaControllerConvertVoiceUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/media/convert/voice`;
};

export const mediaControllerConvertVoice = async (
	voiceFileDTO: VoiceFileDTO,
	session: unknown = "default",
	options?: RequestInit,
): Promise<mediaControllerConvertVoiceResponse> => {
	const res = await fetch(getMediaControllerConvertVoiceUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(voiceFileDTO),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: mediaControllerConvertVoiceResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as mediaControllerConvertVoiceResponse;
};

export const getMediaControllerConvertVoiceMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof mediaControllerConvertVoice>>,
		TError,
		{ data: VoiceFileDTO; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof mediaControllerConvertVoice>>,
	TError,
	{ data: VoiceFileDTO; session?: unknown },
	TContext
> => {
	const mutationKey = ["mediaControllerConvertVoice"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof mediaControllerConvertVoice>>,
		{ data: VoiceFileDTO; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return mediaControllerConvertVoice(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type MediaControllerConvertVoiceMutationResult = NonNullable<
	Awaited<ReturnType<typeof mediaControllerConvertVoice>>
>;
export type MediaControllerConvertVoiceMutationBody = VoiceFileDTO;
export type MediaControllerConvertVoiceMutationError = unknown;

/**
 * @summary Convert voice to WhatsApp format (opus)
 */
export const useMediaControllerConvertVoice = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof mediaControllerConvertVoice>>,
			TError,
			{ data: VoiceFileDTO; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof mediaControllerConvertVoice>>,
	TError,
	{ data: VoiceFileDTO; session?: unknown },
	TContext
> => {
	return useMutation(
		getMediaControllerConvertVoiceMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Convert video to WhatsApp format (mp4)
 */
export type mediaControllerConvertVideoResponse200VideoMp4 = {
	data: Blob;
	status: 200;
};

export type mediaControllerConvertVideoResponse200ApplicationJson = {
	data: Base64File;
	status: 200;
};

export type mediaControllerConvertVideoResponse201 = {
	data: void;
	status: 201;
};

export type mediaControllerConvertVideoResponseSuccess = (
	| mediaControllerConvertVideoResponse200VideoMp4
	| mediaControllerConvertVideoResponse200ApplicationJson
	| mediaControllerConvertVideoResponse201
) & {
	headers: Headers;
};

export type mediaControllerConvertVideoResponse =
	mediaControllerConvertVideoResponseSuccess;

export const getMediaControllerConvertVideoUrl = (
	session: unknown = "default",
) => {
	return `https://waha.gnardawgs.surf/api/${session}/media/convert/video`;
};

export const mediaControllerConvertVideo = async (
	videoFileDTO: VideoFileDTO,
	session: unknown = "default",
	options?: RequestInit,
): Promise<mediaControllerConvertVideoResponse> => {
	const res = await fetch(getMediaControllerConvertVideoUrl(session), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(videoFileDTO),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: mediaControllerConvertVideoResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as mediaControllerConvertVideoResponse;
};

export const getMediaControllerConvertVideoMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof mediaControllerConvertVideo>>,
		TError,
		{ data: VideoFileDTO; session?: unknown },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof mediaControllerConvertVideo>>,
	TError,
	{ data: VideoFileDTO; session?: unknown },
	TContext
> => {
	const mutationKey = ["mediaControllerConvertVideo"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof mediaControllerConvertVideo>>,
		{ data: VideoFileDTO; session?: unknown }
	> = (props) => {
		const { data, session } = props ?? {};

		return mediaControllerConvertVideo(data, session, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type MediaControllerConvertVideoMutationResult = NonNullable<
	Awaited<ReturnType<typeof mediaControllerConvertVideo>>
>;
export type MediaControllerConvertVideoMutationBody = VideoFileDTO;
export type MediaControllerConvertVideoMutationError = unknown;

/**
 * @summary Convert video to WhatsApp format (mp4)
 */
export const useMediaControllerConvertVideo = <
	TError = unknown,
	TContext = unknown,
>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof mediaControllerConvertVideo>>,
			TError,
			{ data: VideoFileDTO; session?: unknown },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof mediaControllerConvertVideo>>,
	TError,
	{ data: VideoFileDTO; session?: unknown },
	TContext
> => {
	return useMutation(
		getMediaControllerConvertVideoMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary List all apps for a session
 */
export type appsControllerListResponse200 = {
	data: void;
	status: 200;
};

export type appsControllerListResponseSuccess =
	appsControllerListResponse200 & {
		headers: Headers;
	};

export type appsControllerListResponse = appsControllerListResponseSuccess;

export const getAppsControllerListUrl = (params: AppsControllerListParams) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	const stringifiedParams = normalizedParams.toString();

	return stringifiedParams.length > 0
		? `https://waha.gnardawgs.surf/api/apps?${stringifiedParams}`
		: `https://waha.gnardawgs.surf/api/apps`;
};

export const appsControllerList = async (
	params: AppsControllerListParams,
	options?: RequestInit,
): Promise<appsControllerListResponse> => {
	const res = await fetch(getAppsControllerListUrl(params), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: appsControllerListResponse["data"] = body ? JSON.parse(body) : {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as appsControllerListResponse;
};

export const getAppsControllerListQueryKey = (
	params?: AppsControllerListParams,
) => {
	return [
		`https://waha.gnardawgs.surf/api/apps`,
		...(params ? [params] : []),
	] as const;
};

export const getAppsControllerListQueryOptions = <
	TData = Awaited<ReturnType<typeof appsControllerList>>,
	TError = unknown,
>(
	params: AppsControllerListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getAppsControllerListQueryKey(params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof appsControllerList>>
	> = ({ signal }) => appsControllerList(params, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof appsControllerList>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AppsControllerListQueryResult = NonNullable<
	Awaited<ReturnType<typeof appsControllerList>>
>;
export type AppsControllerListQueryError = unknown;

export function useAppsControllerList<
	TData = Awaited<ReturnType<typeof appsControllerList>>,
	TError = unknown,
>(
	params: AppsControllerListParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerList>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof appsControllerList>>,
					TError,
					Awaited<ReturnType<typeof appsControllerList>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAppsControllerList<
	TData = Awaited<ReturnType<typeof appsControllerList>>,
	TError = unknown,
>(
	params: AppsControllerListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerList>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof appsControllerList>>,
					TError,
					Awaited<ReturnType<typeof appsControllerList>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAppsControllerList<
	TData = Awaited<ReturnType<typeof appsControllerList>>,
	TError = unknown,
>(
	params: AppsControllerListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary List all apps for a session
 */

export function useAppsControllerList<
	TData = Awaited<ReturnType<typeof appsControllerList>>,
	TError = unknown,
>(
	params: AppsControllerListParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerList>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getAppsControllerListQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Create a new app
 */
export type appsControllerCreateResponse201 = {
	data: void;
	status: 201;
};

export type appsControllerCreateResponseSuccess =
	appsControllerCreateResponse201 & {
		headers: Headers;
	};

export type appsControllerCreateResponse = appsControllerCreateResponseSuccess;

export const getAppsControllerCreateUrl = () => {
	return `https://waha.gnardawgs.surf/api/apps`;
};

export const appsControllerCreate = async (
	app: App,
	options?: RequestInit,
): Promise<appsControllerCreateResponse> => {
	const res = await fetch(getAppsControllerCreateUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(app),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: appsControllerCreateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as appsControllerCreateResponse;
};

export const getAppsControllerCreateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof appsControllerCreate>>,
		TError,
		{ data: App },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof appsControllerCreate>>,
	TError,
	{ data: App },
	TContext
> => {
	const mutationKey = ["appsControllerCreate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof appsControllerCreate>>,
		{ data: App }
	> = (props) => {
		const { data } = props ?? {};

		return appsControllerCreate(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AppsControllerCreateMutationResult = NonNullable<
	Awaited<ReturnType<typeof appsControllerCreate>>
>;
export type AppsControllerCreateMutationBody = App;
export type AppsControllerCreateMutationError = unknown;

/**
 * @summary Create a new app
 */
export const useAppsControllerCreate = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof appsControllerCreate>>,
			TError,
			{ data: App },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof appsControllerCreate>>,
	TError,
	{ data: App },
	TContext
> => {
	return useMutation(
		getAppsControllerCreateMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Get app by ID
 */
export type appsControllerGetResponse200 = {
	data: void;
	status: 200;
};

export type appsControllerGetResponseSuccess = appsControllerGetResponse200 & {
	headers: Headers;
};

export type appsControllerGetResponse = appsControllerGetResponseSuccess;

export const getAppsControllerGetUrl = (id: string) => {
	return `https://waha.gnardawgs.surf/api/apps/${id}`;
};

export const appsControllerGet = async (
	id: string,
	options?: RequestInit,
): Promise<appsControllerGetResponse> => {
	const res = await fetch(getAppsControllerGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: appsControllerGetResponse["data"] = body ? JSON.parse(body) : {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as appsControllerGetResponse;
};

export const getAppsControllerGetQueryKey = (id: string) => {
	return [`https://waha.gnardawgs.surf/api/apps/${id}`] as const;
};

export const getAppsControllerGetQueryOptions = <
	TData = Awaited<ReturnType<typeof appsControllerGet>>,
	TError = unknown,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getAppsControllerGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof appsControllerGet>>
	> = ({ signal }) => appsControllerGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof appsControllerGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type AppsControllerGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof appsControllerGet>>
>;
export type AppsControllerGetQueryError = unknown;

export function useAppsControllerGet<
	TData = Awaited<ReturnType<typeof appsControllerGet>>,
	TError = unknown,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof appsControllerGet>>,
					TError,
					Awaited<ReturnType<typeof appsControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAppsControllerGet<
	TData = Awaited<ReturnType<typeof appsControllerGet>>,
	TError = unknown,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof appsControllerGet>>,
					TError,
					Awaited<ReturnType<typeof appsControllerGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useAppsControllerGet<
	TData = Awaited<ReturnType<typeof appsControllerGet>>,
	TError = unknown,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get app by ID
 */

export function useAppsControllerGet<
	TData = Awaited<ReturnType<typeof appsControllerGet>>,
	TError = unknown,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof appsControllerGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getAppsControllerGetQueryOptions(id, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * @summary Update an existing app
 */
export type appsControllerUpdateResponse200 = {
	data: void;
	status: 200;
};

export type appsControllerUpdateResponseSuccess =
	appsControllerUpdateResponse200 & {
		headers: Headers;
	};

export type appsControllerUpdateResponse = appsControllerUpdateResponseSuccess;

export const getAppsControllerUpdateUrl = (id: string) => {
	return `https://waha.gnardawgs.surf/api/apps/${id}`;
};

export const appsControllerUpdate = async (
	id: string,
	app: App,
	options?: RequestInit,
): Promise<appsControllerUpdateResponse> => {
	const res = await fetch(getAppsControllerUpdateUrl(id), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(app),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: appsControllerUpdateResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as appsControllerUpdateResponse;
};

export const getAppsControllerUpdateMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof appsControllerUpdate>>,
		TError,
		{ id: string; data: App },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof appsControllerUpdate>>,
	TError,
	{ id: string; data: App },
	TContext
> => {
	const mutationKey = ["appsControllerUpdate"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof appsControllerUpdate>>,
		{ id: string; data: App }
	> = (props) => {
		const { id, data } = props ?? {};

		return appsControllerUpdate(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AppsControllerUpdateMutationResult = NonNullable<
	Awaited<ReturnType<typeof appsControllerUpdate>>
>;
export type AppsControllerUpdateMutationBody = App;
export type AppsControllerUpdateMutationError = unknown;

/**
 * @summary Update an existing app
 */
export const useAppsControllerUpdate = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof appsControllerUpdate>>,
			TError,
			{ id: string; data: App },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof appsControllerUpdate>>,
	TError,
	{ id: string; data: App },
	TContext
> => {
	return useMutation(
		getAppsControllerUpdateMutationOptions(options),
		queryClient,
	);
};

/**
 * @summary Delete an app
 */
export type appsControllerDeleteResponse200 = {
	data: void;
	status: 200;
};

export type appsControllerDeleteResponseSuccess =
	appsControllerDeleteResponse200 & {
		headers: Headers;
	};

export type appsControllerDeleteResponse = appsControllerDeleteResponseSuccess;

export const getAppsControllerDeleteUrl = (id: string) => {
	return `https://waha.gnardawgs.surf/api/apps/${id}`;
};

export const appsControllerDelete = async (
	id: string,
	options?: RequestInit,
): Promise<appsControllerDeleteResponse> => {
	const res = await fetch(getAppsControllerDeleteUrl(id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: appsControllerDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as appsControllerDeleteResponse;
};

export const getAppsControllerDeleteMutationOptions = <
	TError = unknown,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof appsControllerDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof appsControllerDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["appsControllerDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof appsControllerDelete>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return appsControllerDelete(id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AppsControllerDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof appsControllerDelete>>
>;

export type AppsControllerDeleteMutationError = unknown;

/**
 * @summary Delete an app
 */
export const useAppsControllerDelete = <TError = unknown, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<typeof appsControllerDelete>>,
			TError,
			{ id: string },
			TContext
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseMutationResult<
	Awaited<ReturnType<typeof appsControllerDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	return useMutation(
		getAppsControllerDeleteMutationOptions(options),
		queryClient,
	);
};

/**
 * Get available languages for Chatwoot app
 * @summary Get available languages for Chatwoot app
 */
export type chatwootLocalesControllerGetLanguagesResponse200 = {
	data: ChatwootLocalesControllerGetLanguages200Item[];
	status: 200;
};

export type chatwootLocalesControllerGetLanguagesResponseSuccess =
	chatwootLocalesControllerGetLanguagesResponse200 & {
		headers: Headers;
	};

export type chatwootLocalesControllerGetLanguagesResponse =
	chatwootLocalesControllerGetLanguagesResponseSuccess;

export const getChatwootLocalesControllerGetLanguagesUrl = () => {
	return `https://waha.gnardawgs.surf/api/apps/chatwoot/locales`;
};

export const chatwootLocalesControllerGetLanguages = async (
	options?: RequestInit,
): Promise<chatwootLocalesControllerGetLanguagesResponse> => {
	const res = await fetch(getChatwootLocalesControllerGetLanguagesUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();

	const data: chatwootLocalesControllerGetLanguagesResponse["data"] = body
		? JSON.parse(body)
		: {};
	return {
		data,
		status: res.status,
		headers: res.headers,
	} as chatwootLocalesControllerGetLanguagesResponse;
};

export const getChatwootLocalesControllerGetLanguagesQueryKey = () => {
	return [`https://waha.gnardawgs.surf/api/apps/chatwoot/locales`] as const;
};

export const getChatwootLocalesControllerGetLanguagesQueryOptions = <
	TData = Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getChatwootLocalesControllerGetLanguagesQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>
	> = ({ signal }) =>
		chatwootLocalesControllerGetLanguages({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ChatwootLocalesControllerGetLanguagesQueryResult = NonNullable<
	Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>
>;
export type ChatwootLocalesControllerGetLanguagesQueryError = unknown;

export function useChatwootLocalesControllerGetLanguages<
	TData = Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
	TError = unknown,
>(
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
					TError,
					Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatwootLocalesControllerGetLanguages<
	TData = Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
					TError,
					Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useChatwootLocalesControllerGetLanguages<
	TData = Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Get available languages for Chatwoot app
 */

export function useChatwootLocalesControllerGetLanguages<
	TData = Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
	TError = unknown,
>(
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof chatwootLocalesControllerGetLanguages>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
	queryClient?: QueryClient,
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getChatwootLocalesControllerGetLanguagesQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}
