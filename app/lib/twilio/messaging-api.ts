/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Twilio - Messaging
 * This is the public Twilio REST API.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateAlphaSenderBody,
  CreateBrandRegistrationsBody,
  CreateBrandVettingBody,
  CreateChannelSenderBody,
  CreateDestinationAlphaSenderBody,
  CreateExternalCampaignBody,
  CreatePhoneNumberBody,
  CreateServiceBody,
  CreateShortCodeBody,
  CreateTollfreeVerificationBody,
  CreateUsAppToPersonBody,
  FetchDeactivationParams,
  FetchUsAppToPersonUsecaseParams,
  ListAlphaSender200,
  ListAlphaSenderParams,
  ListBrandRegistrations200,
  ListBrandRegistrationsParams,
  ListBrandVetting200,
  ListBrandVettingParams,
  ListChannelSender200,
  ListChannelSenderParams,
  ListDestinationAlphaSender200,
  ListDestinationAlphaSenderParams,
  ListPhoneNumber200,
  ListPhoneNumberParams,
  ListService200,
  ListServiceParams,
  ListShortCode200,
  ListShortCodeParams,
  ListTollfreeVerification200,
  ListTollfreeVerificationParams,
  ListUsAppToPerson200,
  ListUsAppToPersonParams,
  MessagingV1BrandRegistrations,
  MessagingV1BrandRegistrationsBrandRegistrationOtp,
  MessagingV1BrandRegistrationsBrandVetting,
  MessagingV1Deactivation,
  MessagingV1DomainCertV4,
  MessagingV1DomainConfig,
  MessagingV1DomainConfigMessagingService,
  MessagingV1DomainDnsValidation,
  MessagingV1ExternalCampaign,
  MessagingV1LinkshorteningMessagingService,
  MessagingV1LinkshorteningMessagingServiceDomainAssociation,
  MessagingV1RequestManagedCert,
  MessagingV1Service,
  MessagingV1ServiceAlphaSender,
  MessagingV1ServiceChannelSender,
  MessagingV1ServiceDestinationAlphaSender,
  MessagingV1ServicePhoneNumber,
  MessagingV1ServiceShortCode,
  MessagingV1ServiceUsAppToPerson,
  MessagingV1ServiceUsAppToPersonUsecase,
  MessagingV1TollfreeVerification,
  MessagingV1Usecase,
  UpdateDomainCertV4Body,
  UpdateDomainConfigBody,
  UpdateServiceBody,
  UpdateTollfreeVerificationBody,
  UpdateUsAppToPersonBody
} from './models';

export type createAlphaSenderResponse201 = {
  data: MessagingV1ServiceAlphaSender
  status: 201
}
    
export type createAlphaSenderResponseSuccess = (createAlphaSenderResponse201) & {
  headers: Headers;
};
;

export type createAlphaSenderResponse = (createAlphaSenderResponseSuccess)

export const getCreateAlphaSenderUrl = (serviceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/AlphaSenders`
}

export const createAlphaSender = async (serviceSid: string,
    createAlphaSenderBody: CreateAlphaSenderBody, options?: RequestInit): Promise<createAlphaSenderResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`AlphaSender`, createAlphaSenderBody.AlphaSender)

  const res = await fetch(getCreateAlphaSenderUrl(serviceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createAlphaSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createAlphaSenderResponse
}




export const getCreateAlphaSenderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAlphaSender>>, TError,{serviceSid: string;data: CreateAlphaSenderBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createAlphaSender>>, TError,{serviceSid: string;data: CreateAlphaSenderBody}, TContext> => {

const mutationKey = ['createAlphaSender'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createAlphaSender>>, {serviceSid: string;data: CreateAlphaSenderBody}> = (props) => {
          const {serviceSid,data} = props ?? {};

          return  createAlphaSender(serviceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateAlphaSenderMutationResult = NonNullable<Awaited<ReturnType<typeof createAlphaSender>>>
    export type CreateAlphaSenderMutationBody = CreateAlphaSenderBody
    export type CreateAlphaSenderMutationError = unknown

    export const useCreateAlphaSender = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createAlphaSender>>, TError,{serviceSid: string;data: CreateAlphaSenderBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createAlphaSender>>,
        TError,
        {serviceSid: string;data: CreateAlphaSenderBody},
        TContext
      > => {

      const mutationOptions = getCreateAlphaSenderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type listAlphaSenderResponse200 = {
  data: ListAlphaSender200
  status: 200
}
    
export type listAlphaSenderResponseSuccess = (listAlphaSenderResponse200) & {
  headers: Headers;
};
;

export type listAlphaSenderResponse = (listAlphaSenderResponseSuccess)

export const getListAlphaSenderUrl = (serviceSid: string,
    params?: ListAlphaSenderParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Services/${serviceSid}/AlphaSenders?${stringifiedParams}` : `https://messaging.twilio.com/v1/Services/${serviceSid}/AlphaSenders`
}

export const listAlphaSender = async (serviceSid: string,
    params?: ListAlphaSenderParams, options?: RequestInit): Promise<listAlphaSenderResponse> => {
  
  const res = await fetch(getListAlphaSenderUrl(serviceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listAlphaSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listAlphaSenderResponse
}





export const getListAlphaSenderQueryKey = (serviceSid?: string,
    params?: ListAlphaSenderParams,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${serviceSid}/AlphaSenders`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListAlphaSenderQueryOptions = <TData = Awaited<ReturnType<typeof listAlphaSender>>, TError = unknown>(serviceSid: string,
    params?: ListAlphaSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAlphaSender>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListAlphaSenderQueryKey(serviceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listAlphaSender>>> = ({ signal }) => listAlphaSender(serviceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(serviceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listAlphaSender>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListAlphaSenderQueryResult = NonNullable<Awaited<ReturnType<typeof listAlphaSender>>>
export type ListAlphaSenderQueryError = unknown


export function useListAlphaSender<TData = Awaited<ReturnType<typeof listAlphaSender>>, TError = unknown>(
 serviceSid: string,
    params: undefined |  ListAlphaSenderParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAlphaSender>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAlphaSender>>,
          TError,
          Awaited<ReturnType<typeof listAlphaSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAlphaSender<TData = Awaited<ReturnType<typeof listAlphaSender>>, TError = unknown>(
 serviceSid: string,
    params?: ListAlphaSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAlphaSender>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listAlphaSender>>,
          TError,
          Awaited<ReturnType<typeof listAlphaSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListAlphaSender<TData = Awaited<ReturnType<typeof listAlphaSender>>, TError = unknown>(
 serviceSid: string,
    params?: ListAlphaSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAlphaSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListAlphaSender<TData = Awaited<ReturnType<typeof listAlphaSender>>, TError = unknown>(
 serviceSid: string,
    params?: ListAlphaSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listAlphaSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListAlphaSenderQueryOptions(serviceSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type fetchAlphaSenderResponse200 = {
  data: MessagingV1ServiceAlphaSender
  status: 200
}
    
export type fetchAlphaSenderResponseSuccess = (fetchAlphaSenderResponse200) & {
  headers: Headers;
};
;

export type fetchAlphaSenderResponse = (fetchAlphaSenderResponseSuccess)

export const getFetchAlphaSenderUrl = (serviceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/AlphaSenders/${sid}`
}

export const fetchAlphaSender = async (serviceSid: string,
    sid: string, options?: RequestInit): Promise<fetchAlphaSenderResponse> => {
  
  const res = await fetch(getFetchAlphaSenderUrl(serviceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchAlphaSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchAlphaSenderResponse
}





export const getFetchAlphaSenderQueryKey = (serviceSid?: string,
    sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${serviceSid}/AlphaSenders/${sid}`
    ] as const;
    }

    
export const getFetchAlphaSenderQueryOptions = <TData = Awaited<ReturnType<typeof fetchAlphaSender>>, TError = unknown>(serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchAlphaSender>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchAlphaSenderQueryKey(serviceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchAlphaSender>>> = ({ signal }) => fetchAlphaSender(serviceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(serviceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchAlphaSender>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchAlphaSenderQueryResult = NonNullable<Awaited<ReturnType<typeof fetchAlphaSender>>>
export type FetchAlphaSenderQueryError = unknown


export function useFetchAlphaSender<TData = Awaited<ReturnType<typeof fetchAlphaSender>>, TError = unknown>(
 serviceSid: string,
    sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchAlphaSender>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchAlphaSender>>,
          TError,
          Awaited<ReturnType<typeof fetchAlphaSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchAlphaSender<TData = Awaited<ReturnType<typeof fetchAlphaSender>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchAlphaSender>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchAlphaSender>>,
          TError,
          Awaited<ReturnType<typeof fetchAlphaSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchAlphaSender<TData = Awaited<ReturnType<typeof fetchAlphaSender>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchAlphaSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchAlphaSender<TData = Awaited<ReturnType<typeof fetchAlphaSender>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchAlphaSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchAlphaSenderQueryOptions(serviceSid,sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type deleteAlphaSenderResponse204 = {
  data: void
  status: 204
}
    
export type deleteAlphaSenderResponseSuccess = (deleteAlphaSenderResponse204) & {
  headers: Headers;
};
;

export type deleteAlphaSenderResponse = (deleteAlphaSenderResponseSuccess)

export const getDeleteAlphaSenderUrl = (serviceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/AlphaSenders/${sid}`
}

export const deleteAlphaSender = async (serviceSid: string,
    sid: string, options?: RequestInit): Promise<deleteAlphaSenderResponse> => {
  
  const res = await fetch(getDeleteAlphaSenderUrl(serviceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteAlphaSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteAlphaSenderResponse
}




export const getDeleteAlphaSenderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAlphaSender>>, TError,{serviceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteAlphaSender>>, TError,{serviceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteAlphaSender'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteAlphaSender>>, {serviceSid: string;sid: string}> = (props) => {
          const {serviceSid,sid} = props ?? {};

          return  deleteAlphaSender(serviceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteAlphaSenderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteAlphaSender>>>
    
    export type DeleteAlphaSenderMutationError = unknown

    export const useDeleteAlphaSender = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteAlphaSender>>, TError,{serviceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteAlphaSender>>,
        TError,
        {serviceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteAlphaSenderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createBrandRegistrationOtpResponse201 = {
  data: MessagingV1BrandRegistrationsBrandRegistrationOtp
  status: 201
}
    
export type createBrandRegistrationOtpResponseSuccess = (createBrandRegistrationOtpResponse201) & {
  headers: Headers;
};
;

export type createBrandRegistrationOtpResponse = (createBrandRegistrationOtpResponseSuccess)

export const getCreateBrandRegistrationOtpUrl = (brandRegistrationSid: string,) => {


  

  return `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${brandRegistrationSid}/SmsOtp`
}

export const createBrandRegistrationOtp = async (brandRegistrationSid: string, options?: RequestInit): Promise<createBrandRegistrationOtpResponse> => {
  
  const res = await fetch(getCreateBrandRegistrationOtpUrl(brandRegistrationSid),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createBrandRegistrationOtpResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createBrandRegistrationOtpResponse
}




export const getCreateBrandRegistrationOtpMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrandRegistrationOtp>>, TError,{brandRegistrationSid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createBrandRegistrationOtp>>, TError,{brandRegistrationSid: string}, TContext> => {

const mutationKey = ['createBrandRegistrationOtp'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBrandRegistrationOtp>>, {brandRegistrationSid: string}> = (props) => {
          const {brandRegistrationSid} = props ?? {};

          return  createBrandRegistrationOtp(brandRegistrationSid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBrandRegistrationOtpMutationResult = NonNullable<Awaited<ReturnType<typeof createBrandRegistrationOtp>>>
    
    export type CreateBrandRegistrationOtpMutationError = unknown

    export const useCreateBrandRegistrationOtp = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrandRegistrationOtp>>, TError,{brandRegistrationSid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBrandRegistrationOtp>>,
        TError,
        {brandRegistrationSid: string},
        TContext
      > => {

      const mutationOptions = getCreateBrandRegistrationOtpMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchBrandRegistrationsResponse200 = {
  data: MessagingV1BrandRegistrations
  status: 200
}
    
export type fetchBrandRegistrationsResponseSuccess = (fetchBrandRegistrationsResponse200) & {
  headers: Headers;
};
;

export type fetchBrandRegistrationsResponse = (fetchBrandRegistrationsResponseSuccess)

export const getFetchBrandRegistrationsUrl = (sid: string,) => {


  

  return `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${sid}`
}

export const fetchBrandRegistrations = async (sid: string, options?: RequestInit): Promise<fetchBrandRegistrationsResponse> => {
  
  const res = await fetch(getFetchBrandRegistrationsUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchBrandRegistrationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchBrandRegistrationsResponse
}





export const getFetchBrandRegistrationsQueryKey = (sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${sid}`
    ] as const;
    }

    
export const getFetchBrandRegistrationsQueryOptions = <TData = Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError = unknown>(sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchBrandRegistrationsQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchBrandRegistrations>>> = ({ signal }) => fetchBrandRegistrations(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchBrandRegistrationsQueryResult = NonNullable<Awaited<ReturnType<typeof fetchBrandRegistrations>>>
export type FetchBrandRegistrationsQueryError = unknown


export function useFetchBrandRegistrations<TData = Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError = unknown>(
 sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchBrandRegistrations>>,
          TError,
          Awaited<ReturnType<typeof fetchBrandRegistrations>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchBrandRegistrations<TData = Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchBrandRegistrations>>,
          TError,
          Awaited<ReturnType<typeof fetchBrandRegistrations>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchBrandRegistrations<TData = Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchBrandRegistrations<TData = Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandRegistrations>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchBrandRegistrationsQueryOptions(sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type updateBrandRegistrationsResponse202 = {
  data: MessagingV1BrandRegistrations
  status: 202
}
    
export type updateBrandRegistrationsResponseSuccess = (updateBrandRegistrationsResponse202) & {
  headers: Headers;
};
;

export type updateBrandRegistrationsResponse = (updateBrandRegistrationsResponseSuccess)

export const getUpdateBrandRegistrationsUrl = (sid: string,) => {


  

  return `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${sid}`
}

export const updateBrandRegistrations = async (sid: string, options?: RequestInit): Promise<updateBrandRegistrationsResponse> => {
  
  const res = await fetch(getUpdateBrandRegistrationsUrl(sid),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateBrandRegistrationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateBrandRegistrationsResponse
}




export const getUpdateBrandRegistrationsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBrandRegistrations>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateBrandRegistrations>>, TError,{sid: string}, TContext> => {

const mutationKey = ['updateBrandRegistrations'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateBrandRegistrations>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  updateBrandRegistrations(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateBrandRegistrationsMutationResult = NonNullable<Awaited<ReturnType<typeof updateBrandRegistrations>>>
    
    export type UpdateBrandRegistrationsMutationError = unknown

    export const useUpdateBrandRegistrations = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateBrandRegistrations>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateBrandRegistrations>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getUpdateBrandRegistrationsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type listBrandRegistrationsResponse200 = {
  data: ListBrandRegistrations200
  status: 200
}
    
export type listBrandRegistrationsResponseSuccess = (listBrandRegistrationsResponse200) & {
  headers: Headers;
};
;

export type listBrandRegistrationsResponse = (listBrandRegistrationsResponseSuccess)

export const getListBrandRegistrationsUrl = (params?: ListBrandRegistrationsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/a2p/BrandRegistrations?${stringifiedParams}` : `https://messaging.twilio.com/v1/a2p/BrandRegistrations`
}

export const listBrandRegistrations = async (params?: ListBrandRegistrationsParams, options?: RequestInit): Promise<listBrandRegistrationsResponse> => {
  
  const res = await fetch(getListBrandRegistrationsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listBrandRegistrationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listBrandRegistrationsResponse
}





export const getListBrandRegistrationsQueryKey = (params?: ListBrandRegistrationsParams,) => {
    return [
    `https://messaging.twilio.com/v1/a2p/BrandRegistrations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListBrandRegistrationsQueryOptions = <TData = Awaited<ReturnType<typeof listBrandRegistrations>>, TError = unknown>(params?: ListBrandRegistrationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandRegistrations>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBrandRegistrationsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBrandRegistrations>>> = ({ signal }) => listBrandRegistrations(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBrandRegistrations>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBrandRegistrationsQueryResult = NonNullable<Awaited<ReturnType<typeof listBrandRegistrations>>>
export type ListBrandRegistrationsQueryError = unknown


export function useListBrandRegistrations<TData = Awaited<ReturnType<typeof listBrandRegistrations>>, TError = unknown>(
 params: undefined |  ListBrandRegistrationsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandRegistrations>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBrandRegistrations>>,
          TError,
          Awaited<ReturnType<typeof listBrandRegistrations>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBrandRegistrations<TData = Awaited<ReturnType<typeof listBrandRegistrations>>, TError = unknown>(
 params?: ListBrandRegistrationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandRegistrations>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBrandRegistrations>>,
          TError,
          Awaited<ReturnType<typeof listBrandRegistrations>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBrandRegistrations<TData = Awaited<ReturnType<typeof listBrandRegistrations>>, TError = unknown>(
 params?: ListBrandRegistrationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandRegistrations>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListBrandRegistrations<TData = Awaited<ReturnType<typeof listBrandRegistrations>>, TError = unknown>(
 params?: ListBrandRegistrationsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandRegistrations>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListBrandRegistrationsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type createBrandRegistrationsResponse201 = {
  data: MessagingV1BrandRegistrations
  status: 201
}
    
export type createBrandRegistrationsResponseSuccess = (createBrandRegistrationsResponse201) & {
  headers: Headers;
};
;

export type createBrandRegistrationsResponse = (createBrandRegistrationsResponseSuccess)

export const getCreateBrandRegistrationsUrl = () => {


  

  return `https://messaging.twilio.com/v1/a2p/BrandRegistrations`
}

export const createBrandRegistrations = async (createBrandRegistrationsBody: CreateBrandRegistrationsBody, options?: RequestInit): Promise<createBrandRegistrationsResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`CustomerProfileBundleSid`, createBrandRegistrationsBody.CustomerProfileBundleSid)
formUrlEncoded.append(`A2PProfileBundleSid`, createBrandRegistrationsBody.A2PProfileBundleSid)
if(createBrandRegistrationsBody.BrandType !== undefined) {
 formUrlEncoded.append(`BrandType`, createBrandRegistrationsBody.BrandType)
 }
if(createBrandRegistrationsBody.Mock !== undefined) {
 formUrlEncoded.append(`Mock`, createBrandRegistrationsBody.Mock.toString())
 }
if(createBrandRegistrationsBody.SkipAutomaticSecVet !== undefined) {
 formUrlEncoded.append(`SkipAutomaticSecVet`, createBrandRegistrationsBody.SkipAutomaticSecVet.toString())
 }

  const res = await fetch(getCreateBrandRegistrationsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createBrandRegistrationsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createBrandRegistrationsResponse
}




export const getCreateBrandRegistrationsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrandRegistrations>>, TError,{data: CreateBrandRegistrationsBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createBrandRegistrations>>, TError,{data: CreateBrandRegistrationsBody}, TContext> => {

const mutationKey = ['createBrandRegistrations'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBrandRegistrations>>, {data: CreateBrandRegistrationsBody}> = (props) => {
          const {data} = props ?? {};

          return  createBrandRegistrations(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBrandRegistrationsMutationResult = NonNullable<Awaited<ReturnType<typeof createBrandRegistrations>>>
    export type CreateBrandRegistrationsMutationBody = CreateBrandRegistrationsBody
    export type CreateBrandRegistrationsMutationError = unknown

    export const useCreateBrandRegistrations = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrandRegistrations>>, TError,{data: CreateBrandRegistrationsBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBrandRegistrations>>,
        TError,
        {data: CreateBrandRegistrationsBody},
        TContext
      > => {

      const mutationOptions = getCreateBrandRegistrationsMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createBrandVettingResponse201 = {
  data: MessagingV1BrandRegistrationsBrandVetting
  status: 201
}

export type createBrandVettingResponse202 = {
  data: MessagingV1BrandRegistrationsBrandVetting
  status: 202
}
    
export type createBrandVettingResponseSuccess = (createBrandVettingResponse201 | createBrandVettingResponse202) & {
  headers: Headers;
};
;

export type createBrandVettingResponse = (createBrandVettingResponseSuccess)

export const getCreateBrandVettingUrl = (brandSid: string,) => {


  

  return `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${brandSid}/Vettings`
}

export const createBrandVetting = async (brandSid: string,
    createBrandVettingBody: CreateBrandVettingBody, options?: RequestInit): Promise<createBrandVettingResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`VettingProvider`, createBrandVettingBody.VettingProvider)
if(createBrandVettingBody.VettingId !== undefined) {
 formUrlEncoded.append(`VettingId`, createBrandVettingBody.VettingId)
 }

  const res = await fetch(getCreateBrandVettingUrl(brandSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createBrandVettingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createBrandVettingResponse
}




export const getCreateBrandVettingMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrandVetting>>, TError,{brandSid: string;data: CreateBrandVettingBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createBrandVetting>>, TError,{brandSid: string;data: CreateBrandVettingBody}, TContext> => {

const mutationKey = ['createBrandVetting'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createBrandVetting>>, {brandSid: string;data: CreateBrandVettingBody}> = (props) => {
          const {brandSid,data} = props ?? {};

          return  createBrandVetting(brandSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateBrandVettingMutationResult = NonNullable<Awaited<ReturnType<typeof createBrandVetting>>>
    export type CreateBrandVettingMutationBody = CreateBrandVettingBody
    export type CreateBrandVettingMutationError = unknown

    export const useCreateBrandVetting = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createBrandVetting>>, TError,{brandSid: string;data: CreateBrandVettingBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createBrandVetting>>,
        TError,
        {brandSid: string;data: CreateBrandVettingBody},
        TContext
      > => {

      const mutationOptions = getCreateBrandVettingMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type listBrandVettingResponse200 = {
  data: ListBrandVetting200
  status: 200
}
    
export type listBrandVettingResponseSuccess = (listBrandVettingResponse200) & {
  headers: Headers;
};
;

export type listBrandVettingResponse = (listBrandVettingResponseSuccess)

export const getListBrandVettingUrl = (brandSid: string,
    params?: ListBrandVettingParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${brandSid}/Vettings?${stringifiedParams}` : `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${brandSid}/Vettings`
}

export const listBrandVetting = async (brandSid: string,
    params?: ListBrandVettingParams, options?: RequestInit): Promise<listBrandVettingResponse> => {
  
  const res = await fetch(getListBrandVettingUrl(brandSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listBrandVettingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listBrandVettingResponse
}





export const getListBrandVettingQueryKey = (brandSid?: string,
    params?: ListBrandVettingParams,) => {
    return [
    `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${brandSid}/Vettings`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListBrandVettingQueryOptions = <TData = Awaited<ReturnType<typeof listBrandVetting>>, TError = unknown>(brandSid: string,
    params?: ListBrandVettingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandVetting>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListBrandVettingQueryKey(brandSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listBrandVetting>>> = ({ signal }) => listBrandVetting(brandSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(brandSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listBrandVetting>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListBrandVettingQueryResult = NonNullable<Awaited<ReturnType<typeof listBrandVetting>>>
export type ListBrandVettingQueryError = unknown


export function useListBrandVetting<TData = Awaited<ReturnType<typeof listBrandVetting>>, TError = unknown>(
 brandSid: string,
    params: undefined |  ListBrandVettingParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandVetting>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBrandVetting>>,
          TError,
          Awaited<ReturnType<typeof listBrandVetting>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBrandVetting<TData = Awaited<ReturnType<typeof listBrandVetting>>, TError = unknown>(
 brandSid: string,
    params?: ListBrandVettingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandVetting>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listBrandVetting>>,
          TError,
          Awaited<ReturnType<typeof listBrandVetting>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListBrandVetting<TData = Awaited<ReturnType<typeof listBrandVetting>>, TError = unknown>(
 brandSid: string,
    params?: ListBrandVettingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandVetting>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListBrandVetting<TData = Awaited<ReturnType<typeof listBrandVetting>>, TError = unknown>(
 brandSid: string,
    params?: ListBrandVettingParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listBrandVetting>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListBrandVettingQueryOptions(brandSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type fetchBrandVettingResponse200 = {
  data: MessagingV1BrandRegistrationsBrandVetting
  status: 200
}
    
export type fetchBrandVettingResponseSuccess = (fetchBrandVettingResponse200) & {
  headers: Headers;
};
;

export type fetchBrandVettingResponse = (fetchBrandVettingResponseSuccess)

export const getFetchBrandVettingUrl = (brandSid: string,
    brandVettingSid: string,) => {


  

  return `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${brandSid}/Vettings/${brandVettingSid}`
}

export const fetchBrandVetting = async (brandSid: string,
    brandVettingSid: string, options?: RequestInit): Promise<fetchBrandVettingResponse> => {
  
  const res = await fetch(getFetchBrandVettingUrl(brandSid,brandVettingSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchBrandVettingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchBrandVettingResponse
}





export const getFetchBrandVettingQueryKey = (brandSid?: string,
    brandVettingSid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/a2p/BrandRegistrations/${brandSid}/Vettings/${brandVettingSid}`
    ] as const;
    }

    
export const getFetchBrandVettingQueryOptions = <TData = Awaited<ReturnType<typeof fetchBrandVetting>>, TError = unknown>(brandSid: string,
    brandVettingSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandVetting>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchBrandVettingQueryKey(brandSid,brandVettingSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchBrandVetting>>> = ({ signal }) => fetchBrandVetting(brandSid,brandVettingSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(brandSid && brandVettingSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchBrandVetting>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchBrandVettingQueryResult = NonNullable<Awaited<ReturnType<typeof fetchBrandVetting>>>
export type FetchBrandVettingQueryError = unknown


export function useFetchBrandVetting<TData = Awaited<ReturnType<typeof fetchBrandVetting>>, TError = unknown>(
 brandSid: string,
    brandVettingSid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandVetting>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchBrandVetting>>,
          TError,
          Awaited<ReturnType<typeof fetchBrandVetting>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchBrandVetting<TData = Awaited<ReturnType<typeof fetchBrandVetting>>, TError = unknown>(
 brandSid: string,
    brandVettingSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandVetting>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchBrandVetting>>,
          TError,
          Awaited<ReturnType<typeof fetchBrandVetting>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchBrandVetting<TData = Awaited<ReturnType<typeof fetchBrandVetting>>, TError = unknown>(
 brandSid: string,
    brandVettingSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandVetting>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchBrandVetting<TData = Awaited<ReturnType<typeof fetchBrandVetting>>, TError = unknown>(
 brandSid: string,
    brandVettingSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchBrandVetting>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchBrandVettingQueryOptions(brandSid,brandVettingSid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type listChannelSenderResponse200 = {
  data: ListChannelSender200
  status: 200
}
    
export type listChannelSenderResponseSuccess = (listChannelSenderResponse200) & {
  headers: Headers;
};
;

export type listChannelSenderResponse = (listChannelSenderResponseSuccess)

export const getListChannelSenderUrl = (messagingServiceSid: string,
    params?: ListChannelSenderParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/ChannelSenders?${stringifiedParams}` : `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/ChannelSenders`
}

export const listChannelSender = async (messagingServiceSid: string,
    params?: ListChannelSenderParams, options?: RequestInit): Promise<listChannelSenderResponse> => {
  
  const res = await fetch(getListChannelSenderUrl(messagingServiceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listChannelSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listChannelSenderResponse
}





export const getListChannelSenderQueryKey = (messagingServiceSid?: string,
    params?: ListChannelSenderParams,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/ChannelSenders`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListChannelSenderQueryOptions = <TData = Awaited<ReturnType<typeof listChannelSender>>, TError = unknown>(messagingServiceSid: string,
    params?: ListChannelSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listChannelSender>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListChannelSenderQueryKey(messagingServiceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listChannelSender>>> = ({ signal }) => listChannelSender(messagingServiceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messagingServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listChannelSender>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListChannelSenderQueryResult = NonNullable<Awaited<ReturnType<typeof listChannelSender>>>
export type ListChannelSenderQueryError = unknown


export function useListChannelSender<TData = Awaited<ReturnType<typeof listChannelSender>>, TError = unknown>(
 messagingServiceSid: string,
    params: undefined |  ListChannelSenderParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listChannelSender>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listChannelSender>>,
          TError,
          Awaited<ReturnType<typeof listChannelSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListChannelSender<TData = Awaited<ReturnType<typeof listChannelSender>>, TError = unknown>(
 messagingServiceSid: string,
    params?: ListChannelSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listChannelSender>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listChannelSender>>,
          TError,
          Awaited<ReturnType<typeof listChannelSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListChannelSender<TData = Awaited<ReturnType<typeof listChannelSender>>, TError = unknown>(
 messagingServiceSid: string,
    params?: ListChannelSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listChannelSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListChannelSender<TData = Awaited<ReturnType<typeof listChannelSender>>, TError = unknown>(
 messagingServiceSid: string,
    params?: ListChannelSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listChannelSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListChannelSenderQueryOptions(messagingServiceSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type createChannelSenderResponse201 = {
  data: MessagingV1ServiceChannelSender
  status: 201
}
    
export type createChannelSenderResponseSuccess = (createChannelSenderResponse201) & {
  headers: Headers;
};
;

export type createChannelSenderResponse = (createChannelSenderResponseSuccess)

export const getCreateChannelSenderUrl = (messagingServiceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/ChannelSenders`
}

export const createChannelSender = async (messagingServiceSid: string,
    createChannelSenderBody: CreateChannelSenderBody, options?: RequestInit): Promise<createChannelSenderResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Sid`, createChannelSenderBody.Sid)

  const res = await fetch(getCreateChannelSenderUrl(messagingServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createChannelSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createChannelSenderResponse
}




export const getCreateChannelSenderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createChannelSender>>, TError,{messagingServiceSid: string;data: CreateChannelSenderBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createChannelSender>>, TError,{messagingServiceSid: string;data: CreateChannelSenderBody}, TContext> => {

const mutationKey = ['createChannelSender'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createChannelSender>>, {messagingServiceSid: string;data: CreateChannelSenderBody}> = (props) => {
          const {messagingServiceSid,data} = props ?? {};

          return  createChannelSender(messagingServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateChannelSenderMutationResult = NonNullable<Awaited<ReturnType<typeof createChannelSender>>>
    export type CreateChannelSenderMutationBody = CreateChannelSenderBody
    export type CreateChannelSenderMutationError = unknown

    export const useCreateChannelSender = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createChannelSender>>, TError,{messagingServiceSid: string;data: CreateChannelSenderBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createChannelSender>>,
        TError,
        {messagingServiceSid: string;data: CreateChannelSenderBody},
        TContext
      > => {

      const mutationOptions = getCreateChannelSenderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchChannelSenderResponse200 = {
  data: MessagingV1ServiceChannelSender
  status: 200
}
    
export type fetchChannelSenderResponseSuccess = (fetchChannelSenderResponse200) & {
  headers: Headers;
};
;

export type fetchChannelSenderResponse = (fetchChannelSenderResponseSuccess)

export const getFetchChannelSenderUrl = (messagingServiceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/ChannelSenders/${sid}`
}

export const fetchChannelSender = async (messagingServiceSid: string,
    sid: string, options?: RequestInit): Promise<fetchChannelSenderResponse> => {
  
  const res = await fetch(getFetchChannelSenderUrl(messagingServiceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchChannelSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchChannelSenderResponse
}





export const getFetchChannelSenderQueryKey = (messagingServiceSid?: string,
    sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/ChannelSenders/${sid}`
    ] as const;
    }

    
export const getFetchChannelSenderQueryOptions = <TData = Awaited<ReturnType<typeof fetchChannelSender>>, TError = unknown>(messagingServiceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchChannelSender>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchChannelSenderQueryKey(messagingServiceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchChannelSender>>> = ({ signal }) => fetchChannelSender(messagingServiceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messagingServiceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchChannelSender>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchChannelSenderQueryResult = NonNullable<Awaited<ReturnType<typeof fetchChannelSender>>>
export type FetchChannelSenderQueryError = unknown


export function useFetchChannelSender<TData = Awaited<ReturnType<typeof fetchChannelSender>>, TError = unknown>(
 messagingServiceSid: string,
    sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchChannelSender>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchChannelSender>>,
          TError,
          Awaited<ReturnType<typeof fetchChannelSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchChannelSender<TData = Awaited<ReturnType<typeof fetchChannelSender>>, TError = unknown>(
 messagingServiceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchChannelSender>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchChannelSender>>,
          TError,
          Awaited<ReturnType<typeof fetchChannelSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchChannelSender<TData = Awaited<ReturnType<typeof fetchChannelSender>>, TError = unknown>(
 messagingServiceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchChannelSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchChannelSender<TData = Awaited<ReturnType<typeof fetchChannelSender>>, TError = unknown>(
 messagingServiceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchChannelSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchChannelSenderQueryOptions(messagingServiceSid,sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type deleteChannelSenderResponse204 = {
  data: void
  status: 204
}
    
export type deleteChannelSenderResponseSuccess = (deleteChannelSenderResponse204) & {
  headers: Headers;
};
;

export type deleteChannelSenderResponse = (deleteChannelSenderResponseSuccess)

export const getDeleteChannelSenderUrl = (messagingServiceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/ChannelSenders/${sid}`
}

export const deleteChannelSender = async (messagingServiceSid: string,
    sid: string, options?: RequestInit): Promise<deleteChannelSenderResponse> => {
  
  const res = await fetch(getDeleteChannelSenderUrl(messagingServiceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteChannelSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteChannelSenderResponse
}




export const getDeleteChannelSenderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteChannelSender>>, TError,{messagingServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteChannelSender>>, TError,{messagingServiceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteChannelSender'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteChannelSender>>, {messagingServiceSid: string;sid: string}> = (props) => {
          const {messagingServiceSid,sid} = props ?? {};

          return  deleteChannelSender(messagingServiceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteChannelSenderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteChannelSender>>>
    
    export type DeleteChannelSenderMutationError = unknown

    export const useDeleteChannelSender = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteChannelSender>>, TError,{messagingServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteChannelSender>>,
        TError,
        {messagingServiceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteChannelSenderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Fetch a list of all United States numbers that have been deactivated on a specific date.
 * @summary Fetch a list of all United States numbers that have been deactivated on a specific date.
 */
export type fetchDeactivationResponse307 = {
  data: MessagingV1Deactivation
  status: 307
}
    
;
export type fetchDeactivationResponseError = (fetchDeactivationResponse307) & {
  headers: Headers;
};

export type fetchDeactivationResponse = (fetchDeactivationResponseError)

export const getFetchDeactivationUrl = (params?: FetchDeactivationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Deactivations?${stringifiedParams}` : `https://messaging.twilio.com/v1/Deactivations`
}

export const fetchDeactivation = async (params?: FetchDeactivationParams, options?: RequestInit): Promise<fetchDeactivationResponse> => {
  
  const res = await fetch(getFetchDeactivationUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchDeactivationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchDeactivationResponse
}





export const getFetchDeactivationQueryKey = (params?: FetchDeactivationParams,) => {
    return [
    `https://messaging.twilio.com/v1/Deactivations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFetchDeactivationQueryOptions = <TData = Awaited<ReturnType<typeof fetchDeactivation>>, TError = MessagingV1Deactivation>(params?: FetchDeactivationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDeactivation>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchDeactivationQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchDeactivation>>> = ({ signal }) => fetchDeactivation(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchDeactivation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchDeactivationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchDeactivation>>>
export type FetchDeactivationQueryError = MessagingV1Deactivation


export function useFetchDeactivation<TData = Awaited<ReturnType<typeof fetchDeactivation>>, TError = MessagingV1Deactivation>(
 params: undefined |  FetchDeactivationParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDeactivation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDeactivation>>,
          TError,
          Awaited<ReturnType<typeof fetchDeactivation>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDeactivation<TData = Awaited<ReturnType<typeof fetchDeactivation>>, TError = MessagingV1Deactivation>(
 params?: FetchDeactivationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDeactivation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDeactivation>>,
          TError,
          Awaited<ReturnType<typeof fetchDeactivation>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDeactivation<TData = Awaited<ReturnType<typeof fetchDeactivation>>, TError = MessagingV1Deactivation>(
 params?: FetchDeactivationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDeactivation>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch a list of all United States numbers that have been deactivated on a specific date.
 */

export function useFetchDeactivation<TData = Awaited<ReturnType<typeof fetchDeactivation>>, TError = MessagingV1Deactivation>(
 params?: FetchDeactivationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDeactivation>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchDeactivationQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type createDestinationAlphaSenderResponse201 = {
  data: MessagingV1ServiceDestinationAlphaSender
  status: 201
}
    
export type createDestinationAlphaSenderResponseSuccess = (createDestinationAlphaSenderResponse201) & {
  headers: Headers;
};
;

export type createDestinationAlphaSenderResponse = (createDestinationAlphaSenderResponseSuccess)

export const getCreateDestinationAlphaSenderUrl = (serviceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/DestinationAlphaSenders`
}

export const createDestinationAlphaSender = async (serviceSid: string,
    createDestinationAlphaSenderBody: CreateDestinationAlphaSenderBody, options?: RequestInit): Promise<createDestinationAlphaSenderResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`AlphaSender`, createDestinationAlphaSenderBody.AlphaSender)
if(createDestinationAlphaSenderBody.IsoCountryCode !== undefined) {
 formUrlEncoded.append(`IsoCountryCode`, createDestinationAlphaSenderBody.IsoCountryCode)
 }

  const res = await fetch(getCreateDestinationAlphaSenderUrl(serviceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createDestinationAlphaSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createDestinationAlphaSenderResponse
}




export const getCreateDestinationAlphaSenderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDestinationAlphaSender>>, TError,{serviceSid: string;data: CreateDestinationAlphaSenderBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createDestinationAlphaSender>>, TError,{serviceSid: string;data: CreateDestinationAlphaSenderBody}, TContext> => {

const mutationKey = ['createDestinationAlphaSender'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createDestinationAlphaSender>>, {serviceSid: string;data: CreateDestinationAlphaSenderBody}> = (props) => {
          const {serviceSid,data} = props ?? {};

          return  createDestinationAlphaSender(serviceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateDestinationAlphaSenderMutationResult = NonNullable<Awaited<ReturnType<typeof createDestinationAlphaSender>>>
    export type CreateDestinationAlphaSenderMutationBody = CreateDestinationAlphaSenderBody
    export type CreateDestinationAlphaSenderMutationError = unknown

    export const useCreateDestinationAlphaSender = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createDestinationAlphaSender>>, TError,{serviceSid: string;data: CreateDestinationAlphaSenderBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createDestinationAlphaSender>>,
        TError,
        {serviceSid: string;data: CreateDestinationAlphaSenderBody},
        TContext
      > => {

      const mutationOptions = getCreateDestinationAlphaSenderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type listDestinationAlphaSenderResponse200 = {
  data: ListDestinationAlphaSender200
  status: 200
}
    
export type listDestinationAlphaSenderResponseSuccess = (listDestinationAlphaSenderResponse200) & {
  headers: Headers;
};
;

export type listDestinationAlphaSenderResponse = (listDestinationAlphaSenderResponseSuccess)

export const getListDestinationAlphaSenderUrl = (serviceSid: string,
    params?: ListDestinationAlphaSenderParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Services/${serviceSid}/DestinationAlphaSenders?${stringifiedParams}` : `https://messaging.twilio.com/v1/Services/${serviceSid}/DestinationAlphaSenders`
}

export const listDestinationAlphaSender = async (serviceSid: string,
    params?: ListDestinationAlphaSenderParams, options?: RequestInit): Promise<listDestinationAlphaSenderResponse> => {
  
  const res = await fetch(getListDestinationAlphaSenderUrl(serviceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listDestinationAlphaSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listDestinationAlphaSenderResponse
}





export const getListDestinationAlphaSenderQueryKey = (serviceSid?: string,
    params?: ListDestinationAlphaSenderParams,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${serviceSid}/DestinationAlphaSenders`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListDestinationAlphaSenderQueryOptions = <TData = Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError = unknown>(serviceSid: string,
    params?: ListDestinationAlphaSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListDestinationAlphaSenderQueryKey(serviceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listDestinationAlphaSender>>> = ({ signal }) => listDestinationAlphaSender(serviceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(serviceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListDestinationAlphaSenderQueryResult = NonNullable<Awaited<ReturnType<typeof listDestinationAlphaSender>>>
export type ListDestinationAlphaSenderQueryError = unknown


export function useListDestinationAlphaSender<TData = Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError = unknown>(
 serviceSid: string,
    params: undefined |  ListDestinationAlphaSenderParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDestinationAlphaSender>>,
          TError,
          Awaited<ReturnType<typeof listDestinationAlphaSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDestinationAlphaSender<TData = Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError = unknown>(
 serviceSid: string,
    params?: ListDestinationAlphaSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listDestinationAlphaSender>>,
          TError,
          Awaited<ReturnType<typeof listDestinationAlphaSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListDestinationAlphaSender<TData = Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError = unknown>(
 serviceSid: string,
    params?: ListDestinationAlphaSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListDestinationAlphaSender<TData = Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError = unknown>(
 serviceSid: string,
    params?: ListDestinationAlphaSenderParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listDestinationAlphaSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListDestinationAlphaSenderQueryOptions(serviceSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type fetchDestinationAlphaSenderResponse200 = {
  data: MessagingV1ServiceDestinationAlphaSender
  status: 200
}
    
export type fetchDestinationAlphaSenderResponseSuccess = (fetchDestinationAlphaSenderResponse200) & {
  headers: Headers;
};
;

export type fetchDestinationAlphaSenderResponse = (fetchDestinationAlphaSenderResponseSuccess)

export const getFetchDestinationAlphaSenderUrl = (serviceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/DestinationAlphaSenders/${sid}`
}

export const fetchDestinationAlphaSender = async (serviceSid: string,
    sid: string, options?: RequestInit): Promise<fetchDestinationAlphaSenderResponse> => {
  
  const res = await fetch(getFetchDestinationAlphaSenderUrl(serviceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchDestinationAlphaSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchDestinationAlphaSenderResponse
}





export const getFetchDestinationAlphaSenderQueryKey = (serviceSid?: string,
    sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${serviceSid}/DestinationAlphaSenders/${sid}`
    ] as const;
    }

    
export const getFetchDestinationAlphaSenderQueryOptions = <TData = Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError = unknown>(serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchDestinationAlphaSenderQueryKey(serviceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchDestinationAlphaSender>>> = ({ signal }) => fetchDestinationAlphaSender(serviceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(serviceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchDestinationAlphaSenderQueryResult = NonNullable<Awaited<ReturnType<typeof fetchDestinationAlphaSender>>>
export type FetchDestinationAlphaSenderQueryError = unknown


export function useFetchDestinationAlphaSender<TData = Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError = unknown>(
 serviceSid: string,
    sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDestinationAlphaSender>>,
          TError,
          Awaited<ReturnType<typeof fetchDestinationAlphaSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDestinationAlphaSender<TData = Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDestinationAlphaSender>>,
          TError,
          Awaited<ReturnType<typeof fetchDestinationAlphaSender>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDestinationAlphaSender<TData = Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchDestinationAlphaSender<TData = Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDestinationAlphaSender>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchDestinationAlphaSenderQueryOptions(serviceSid,sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type deleteDestinationAlphaSenderResponse204 = {
  data: void
  status: 204
}
    
export type deleteDestinationAlphaSenderResponseSuccess = (deleteDestinationAlphaSenderResponse204) & {
  headers: Headers;
};
;

export type deleteDestinationAlphaSenderResponse = (deleteDestinationAlphaSenderResponseSuccess)

export const getDeleteDestinationAlphaSenderUrl = (serviceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/DestinationAlphaSenders/${sid}`
}

export const deleteDestinationAlphaSender = async (serviceSid: string,
    sid: string, options?: RequestInit): Promise<deleteDestinationAlphaSenderResponse> => {
  
  const res = await fetch(getDeleteDestinationAlphaSenderUrl(serviceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteDestinationAlphaSenderResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteDestinationAlphaSenderResponse
}




export const getDeleteDestinationAlphaSenderMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDestinationAlphaSender>>, TError,{serviceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDestinationAlphaSender>>, TError,{serviceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteDestinationAlphaSender'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDestinationAlphaSender>>, {serviceSid: string;sid: string}> = (props) => {
          const {serviceSid,sid} = props ?? {};

          return  deleteDestinationAlphaSender(serviceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDestinationAlphaSenderMutationResult = NonNullable<Awaited<ReturnType<typeof deleteDestinationAlphaSender>>>
    
    export type DeleteDestinationAlphaSenderMutationError = unknown

    export const useDeleteDestinationAlphaSender = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDestinationAlphaSender>>, TError,{serviceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDestinationAlphaSender>>,
        TError,
        {serviceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteDestinationAlphaSenderMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type updateDomainCertV4Response200 = {
  data: MessagingV1DomainCertV4
  status: 200
}

export type updateDomainCertV4Response201 = {
  data: MessagingV1DomainCertV4
  status: 201
}
    
export type updateDomainCertV4ResponseSuccess = (updateDomainCertV4Response200 | updateDomainCertV4Response201) & {
  headers: Headers;
};
;

export type updateDomainCertV4Response = (updateDomainCertV4ResponseSuccess)

export const getUpdateDomainCertV4Url = (domainSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/Certificate`
}

export const updateDomainCertV4 = async (domainSid: string,
    updateDomainCertV4Body: UpdateDomainCertV4Body, options?: RequestInit): Promise<updateDomainCertV4Response> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`TlsCert`, updateDomainCertV4Body.TlsCert)

  const res = await fetch(getUpdateDomainCertV4Url(domainSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateDomainCertV4Response['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateDomainCertV4Response
}




export const getUpdateDomainCertV4MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDomainCertV4>>, TError,{domainSid: string;data: UpdateDomainCertV4Body}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateDomainCertV4>>, TError,{domainSid: string;data: UpdateDomainCertV4Body}, TContext> => {

const mutationKey = ['updateDomainCertV4'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDomainCertV4>>, {domainSid: string;data: UpdateDomainCertV4Body}> = (props) => {
          const {domainSid,data} = props ?? {};

          return  updateDomainCertV4(domainSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDomainCertV4MutationResult = NonNullable<Awaited<ReturnType<typeof updateDomainCertV4>>>
    export type UpdateDomainCertV4MutationBody = UpdateDomainCertV4Body
    export type UpdateDomainCertV4MutationError = unknown

    export const useUpdateDomainCertV4 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDomainCertV4>>, TError,{domainSid: string;data: UpdateDomainCertV4Body}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDomainCertV4>>,
        TError,
        {domainSid: string;data: UpdateDomainCertV4Body},
        TContext
      > => {

      const mutationOptions = getUpdateDomainCertV4MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchDomainCertV4Response200 = {
  data: MessagingV1DomainCertV4
  status: 200
}
    
export type fetchDomainCertV4ResponseSuccess = (fetchDomainCertV4Response200) & {
  headers: Headers;
};
;

export type fetchDomainCertV4Response = (fetchDomainCertV4ResponseSuccess)

export const getFetchDomainCertV4Url = (domainSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/Certificate`
}

export const fetchDomainCertV4 = async (domainSid: string, options?: RequestInit): Promise<fetchDomainCertV4Response> => {
  
  const res = await fetch(getFetchDomainCertV4Url(domainSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchDomainCertV4Response['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchDomainCertV4Response
}





export const getFetchDomainCertV4QueryKey = (domainSid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/Certificate`
    ] as const;
    }

    
export const getFetchDomainCertV4QueryOptions = <TData = Awaited<ReturnType<typeof fetchDomainCertV4>>, TError = unknown>(domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainCertV4>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchDomainCertV4QueryKey(domainSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchDomainCertV4>>> = ({ signal }) => fetchDomainCertV4(domainSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domainSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchDomainCertV4>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchDomainCertV4QueryResult = NonNullable<Awaited<ReturnType<typeof fetchDomainCertV4>>>
export type FetchDomainCertV4QueryError = unknown


export function useFetchDomainCertV4<TData = Awaited<ReturnType<typeof fetchDomainCertV4>>, TError = unknown>(
 domainSid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainCertV4>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDomainCertV4>>,
          TError,
          Awaited<ReturnType<typeof fetchDomainCertV4>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDomainCertV4<TData = Awaited<ReturnType<typeof fetchDomainCertV4>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainCertV4>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDomainCertV4>>,
          TError,
          Awaited<ReturnType<typeof fetchDomainCertV4>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDomainCertV4<TData = Awaited<ReturnType<typeof fetchDomainCertV4>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainCertV4>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchDomainCertV4<TData = Awaited<ReturnType<typeof fetchDomainCertV4>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainCertV4>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchDomainCertV4QueryOptions(domainSid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type deleteDomainCertV4Response204 = {
  data: void
  status: 204
}
    
export type deleteDomainCertV4ResponseSuccess = (deleteDomainCertV4Response204) & {
  headers: Headers;
};
;

export type deleteDomainCertV4Response = (deleteDomainCertV4ResponseSuccess)

export const getDeleteDomainCertV4Url = (domainSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/Certificate`
}

export const deleteDomainCertV4 = async (domainSid: string, options?: RequestInit): Promise<deleteDomainCertV4Response> => {
  
  const res = await fetch(getDeleteDomainCertV4Url(domainSid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteDomainCertV4Response['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteDomainCertV4Response
}




export const getDeleteDomainCertV4MutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDomainCertV4>>, TError,{domainSid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteDomainCertV4>>, TError,{domainSid: string}, TContext> => {

const mutationKey = ['deleteDomainCertV4'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteDomainCertV4>>, {domainSid: string}> = (props) => {
          const {domainSid} = props ?? {};

          return  deleteDomainCertV4(domainSid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteDomainCertV4MutationResult = NonNullable<Awaited<ReturnType<typeof deleteDomainCertV4>>>
    
    export type DeleteDomainCertV4MutationError = unknown

    export const useDeleteDomainCertV4 = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteDomainCertV4>>, TError,{domainSid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteDomainCertV4>>,
        TError,
        {domainSid: string},
        TContext
      > => {

      const mutationOptions = getDeleteDomainCertV4MutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type updateDomainConfigResponse200 = {
  data: MessagingV1DomainConfig
  status: 200
}

export type updateDomainConfigResponse201 = {
  data: MessagingV1DomainConfig
  status: 201
}
    
export type updateDomainConfigResponseSuccess = (updateDomainConfigResponse200 | updateDomainConfigResponse201) & {
  headers: Headers;
};
;

export type updateDomainConfigResponse = (updateDomainConfigResponseSuccess)

export const getUpdateDomainConfigUrl = (domainSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/Config`
}

export const updateDomainConfig = async (domainSid: string,
    updateDomainConfigBody: UpdateDomainConfigBody, options?: RequestInit): Promise<updateDomainConfigResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateDomainConfigBody.FallbackUrl !== undefined) {
 formUrlEncoded.append(`FallbackUrl`, updateDomainConfigBody.FallbackUrl)
 }
if(updateDomainConfigBody.CallbackUrl !== undefined) {
 formUrlEncoded.append(`CallbackUrl`, updateDomainConfigBody.CallbackUrl)
 }
if(updateDomainConfigBody.ContinueOnFailure !== undefined) {
 formUrlEncoded.append(`ContinueOnFailure`, updateDomainConfigBody.ContinueOnFailure.toString())
 }
if(updateDomainConfigBody.DisableHttps !== undefined) {
 formUrlEncoded.append(`DisableHttps`, updateDomainConfigBody.DisableHttps.toString())
 }

  const res = await fetch(getUpdateDomainConfigUrl(domainSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateDomainConfigResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateDomainConfigResponse
}




export const getUpdateDomainConfigMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDomainConfig>>, TError,{domainSid: string;data: UpdateDomainConfigBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateDomainConfig>>, TError,{domainSid: string;data: UpdateDomainConfigBody}, TContext> => {

const mutationKey = ['updateDomainConfig'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateDomainConfig>>, {domainSid: string;data: UpdateDomainConfigBody}> = (props) => {
          const {domainSid,data} = props ?? {};

          return  updateDomainConfig(domainSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateDomainConfigMutationResult = NonNullable<Awaited<ReturnType<typeof updateDomainConfig>>>
    export type UpdateDomainConfigMutationBody = UpdateDomainConfigBody
    export type UpdateDomainConfigMutationError = unknown

    export const useUpdateDomainConfig = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateDomainConfig>>, TError,{domainSid: string;data: UpdateDomainConfigBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateDomainConfig>>,
        TError,
        {domainSid: string;data: UpdateDomainConfigBody},
        TContext
      > => {

      const mutationOptions = getUpdateDomainConfigMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchDomainConfigResponse200 = {
  data: MessagingV1DomainConfig
  status: 200
}
    
export type fetchDomainConfigResponseSuccess = (fetchDomainConfigResponse200) & {
  headers: Headers;
};
;

export type fetchDomainConfigResponse = (fetchDomainConfigResponseSuccess)

export const getFetchDomainConfigUrl = (domainSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/Config`
}

export const fetchDomainConfig = async (domainSid: string, options?: RequestInit): Promise<fetchDomainConfigResponse> => {
  
  const res = await fetch(getFetchDomainConfigUrl(domainSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchDomainConfigResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchDomainConfigResponse
}





export const getFetchDomainConfigQueryKey = (domainSid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/Config`
    ] as const;
    }

    
export const getFetchDomainConfigQueryOptions = <TData = Awaited<ReturnType<typeof fetchDomainConfig>>, TError = unknown>(domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfig>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchDomainConfigQueryKey(domainSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchDomainConfig>>> = ({ signal }) => fetchDomainConfig(domainSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domainSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfig>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchDomainConfigQueryResult = NonNullable<Awaited<ReturnType<typeof fetchDomainConfig>>>
export type FetchDomainConfigQueryError = unknown


export function useFetchDomainConfig<TData = Awaited<ReturnType<typeof fetchDomainConfig>>, TError = unknown>(
 domainSid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfig>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDomainConfig>>,
          TError,
          Awaited<ReturnType<typeof fetchDomainConfig>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDomainConfig<TData = Awaited<ReturnType<typeof fetchDomainConfig>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfig>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDomainConfig>>,
          TError,
          Awaited<ReturnType<typeof fetchDomainConfig>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDomainConfig<TData = Awaited<ReturnType<typeof fetchDomainConfig>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfig>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchDomainConfig<TData = Awaited<ReturnType<typeof fetchDomainConfig>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfig>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchDomainConfigQueryOptions(domainSid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type fetchDomainConfigMessagingServiceResponse200 = {
  data: MessagingV1DomainConfigMessagingService
  status: 200
}
    
export type fetchDomainConfigMessagingServiceResponseSuccess = (fetchDomainConfigMessagingServiceResponse200) & {
  headers: Headers;
};
;

export type fetchDomainConfigMessagingServiceResponse = (fetchDomainConfigMessagingServiceResponseSuccess)

export const getFetchDomainConfigMessagingServiceUrl = (messagingServiceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/MessagingService/${messagingServiceSid}/DomainConfig`
}

export const fetchDomainConfigMessagingService = async (messagingServiceSid: string, options?: RequestInit): Promise<fetchDomainConfigMessagingServiceResponse> => {
  
  const res = await fetch(getFetchDomainConfigMessagingServiceUrl(messagingServiceSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchDomainConfigMessagingServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchDomainConfigMessagingServiceResponse
}





export const getFetchDomainConfigMessagingServiceQueryKey = (messagingServiceSid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/LinkShortening/MessagingService/${messagingServiceSid}/DomainConfig`
    ] as const;
    }

    
export const getFetchDomainConfigMessagingServiceQueryOptions = <TData = Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError = unknown>(messagingServiceSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchDomainConfigMessagingServiceQueryKey(messagingServiceSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>> = ({ signal }) => fetchDomainConfigMessagingService(messagingServiceSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messagingServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchDomainConfigMessagingServiceQueryResult = NonNullable<Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>>
export type FetchDomainConfigMessagingServiceQueryError = unknown


export function useFetchDomainConfigMessagingService<TData = Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError = unknown>(
 messagingServiceSid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>,
          TError,
          Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDomainConfigMessagingService<TData = Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError = unknown>(
 messagingServiceSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>,
          TError,
          Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDomainConfigMessagingService<TData = Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError = unknown>(
 messagingServiceSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchDomainConfigMessagingService<TData = Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError = unknown>(
 messagingServiceSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainConfigMessagingService>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchDomainConfigMessagingServiceQueryOptions(messagingServiceSid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type fetchDomainDnsValidationResponse200 = {
  data: MessagingV1DomainDnsValidation
  status: 200
}
    
export type fetchDomainDnsValidationResponseSuccess = (fetchDomainDnsValidationResponse200) & {
  headers: Headers;
};
;

export type fetchDomainDnsValidationResponse = (fetchDomainDnsValidationResponseSuccess)

export const getFetchDomainDnsValidationUrl = (domainSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/ValidateDns`
}

export const fetchDomainDnsValidation = async (domainSid: string, options?: RequestInit): Promise<fetchDomainDnsValidationResponse> => {
  
  const res = await fetch(getFetchDomainDnsValidationUrl(domainSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchDomainDnsValidationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchDomainDnsValidationResponse
}





export const getFetchDomainDnsValidationQueryKey = (domainSid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/ValidateDns`
    ] as const;
    }

    
export const getFetchDomainDnsValidationQueryOptions = <TData = Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError = unknown>(domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchDomainDnsValidationQueryKey(domainSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchDomainDnsValidation>>> = ({ signal }) => fetchDomainDnsValidation(domainSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(domainSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchDomainDnsValidationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchDomainDnsValidation>>>
export type FetchDomainDnsValidationQueryError = unknown


export function useFetchDomainDnsValidation<TData = Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError = unknown>(
 domainSid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDomainDnsValidation>>,
          TError,
          Awaited<ReturnType<typeof fetchDomainDnsValidation>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDomainDnsValidation<TData = Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchDomainDnsValidation>>,
          TError,
          Awaited<ReturnType<typeof fetchDomainDnsValidation>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchDomainDnsValidation<TData = Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchDomainDnsValidation<TData = Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError = unknown>(
 domainSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchDomainDnsValidation>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchDomainDnsValidationQueryOptions(domainSid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type createExternalCampaignResponse201 = {
  data: MessagingV1ExternalCampaign
  status: 201
}
    
export type createExternalCampaignResponseSuccess = (createExternalCampaignResponse201) & {
  headers: Headers;
};
;

export type createExternalCampaignResponse = (createExternalCampaignResponseSuccess)

export const getCreateExternalCampaignUrl = () => {


  

  return `https://messaging.twilio.com/v1/Services/PreregisteredUsa2p`
}

export const createExternalCampaign = async (createExternalCampaignBody: CreateExternalCampaignBody, options?: RequestInit): Promise<createExternalCampaignResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`CampaignId`, createExternalCampaignBody.CampaignId)
formUrlEncoded.append(`MessagingServiceSid`, createExternalCampaignBody.MessagingServiceSid)
if(createExternalCampaignBody.CnpMigration !== undefined) {
 formUrlEncoded.append(`CnpMigration`, createExternalCampaignBody.CnpMigration.toString())
 }

  const res = await fetch(getCreateExternalCampaignUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createExternalCampaignResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createExternalCampaignResponse
}




export const getCreateExternalCampaignMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExternalCampaign>>, TError,{data: CreateExternalCampaignBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createExternalCampaign>>, TError,{data: CreateExternalCampaignBody}, TContext> => {

const mutationKey = ['createExternalCampaign'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createExternalCampaign>>, {data: CreateExternalCampaignBody}> = (props) => {
          const {data} = props ?? {};

          return  createExternalCampaign(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateExternalCampaignMutationResult = NonNullable<Awaited<ReturnType<typeof createExternalCampaign>>>
    export type CreateExternalCampaignMutationBody = CreateExternalCampaignBody
    export type CreateExternalCampaignMutationError = unknown

    export const useCreateExternalCampaign = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createExternalCampaign>>, TError,{data: CreateExternalCampaignBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createExternalCampaign>>,
        TError,
        {data: CreateExternalCampaignBody},
        TContext
      > => {

      const mutationOptions = getCreateExternalCampaignMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createLinkshorteningMessagingServiceResponse201 = {
  data: MessagingV1LinkshorteningMessagingService
  status: 201
}
    
export type createLinkshorteningMessagingServiceResponseSuccess = (createLinkshorteningMessagingServiceResponse201) & {
  headers: Headers;
};
;

export type createLinkshorteningMessagingServiceResponse = (createLinkshorteningMessagingServiceResponseSuccess)

export const getCreateLinkshorteningMessagingServiceUrl = (domainSid: string,
    messagingServiceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/MessagingServices/${messagingServiceSid}`
}

export const createLinkshorteningMessagingService = async (domainSid: string,
    messagingServiceSid: string, options?: RequestInit): Promise<createLinkshorteningMessagingServiceResponse> => {
  
  const res = await fetch(getCreateLinkshorteningMessagingServiceUrl(domainSid,messagingServiceSid),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createLinkshorteningMessagingServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createLinkshorteningMessagingServiceResponse
}




export const getCreateLinkshorteningMessagingServiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLinkshorteningMessagingService>>, TError,{domainSid: string;messagingServiceSid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createLinkshorteningMessagingService>>, TError,{domainSid: string;messagingServiceSid: string}, TContext> => {

const mutationKey = ['createLinkshorteningMessagingService'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createLinkshorteningMessagingService>>, {domainSid: string;messagingServiceSid: string}> = (props) => {
          const {domainSid,messagingServiceSid} = props ?? {};

          return  createLinkshorteningMessagingService(domainSid,messagingServiceSid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateLinkshorteningMessagingServiceMutationResult = NonNullable<Awaited<ReturnType<typeof createLinkshorteningMessagingService>>>
    
    export type CreateLinkshorteningMessagingServiceMutationError = unknown

    export const useCreateLinkshorteningMessagingService = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createLinkshorteningMessagingService>>, TError,{domainSid: string;messagingServiceSid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createLinkshorteningMessagingService>>,
        TError,
        {domainSid: string;messagingServiceSid: string},
        TContext
      > => {

      const mutationOptions = getCreateLinkshorteningMessagingServiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type deleteLinkshorteningMessagingServiceResponse204 = {
  data: void
  status: 204
}
    
export type deleteLinkshorteningMessagingServiceResponseSuccess = (deleteLinkshorteningMessagingServiceResponse204) & {
  headers: Headers;
};
;

export type deleteLinkshorteningMessagingServiceResponse = (deleteLinkshorteningMessagingServiceResponseSuccess)

export const getDeleteLinkshorteningMessagingServiceUrl = (domainSid: string,
    messagingServiceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/MessagingServices/${messagingServiceSid}`
}

export const deleteLinkshorteningMessagingService = async (domainSid: string,
    messagingServiceSid: string, options?: RequestInit): Promise<deleteLinkshorteningMessagingServiceResponse> => {
  
  const res = await fetch(getDeleteLinkshorteningMessagingServiceUrl(domainSid,messagingServiceSid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteLinkshorteningMessagingServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteLinkshorteningMessagingServiceResponse
}




export const getDeleteLinkshorteningMessagingServiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLinkshorteningMessagingService>>, TError,{domainSid: string;messagingServiceSid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteLinkshorteningMessagingService>>, TError,{domainSid: string;messagingServiceSid: string}, TContext> => {

const mutationKey = ['deleteLinkshorteningMessagingService'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteLinkshorteningMessagingService>>, {domainSid: string;messagingServiceSid: string}> = (props) => {
          const {domainSid,messagingServiceSid} = props ?? {};

          return  deleteLinkshorteningMessagingService(domainSid,messagingServiceSid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteLinkshorteningMessagingServiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteLinkshorteningMessagingService>>>
    
    export type DeleteLinkshorteningMessagingServiceMutationError = unknown

    export const useDeleteLinkshorteningMessagingService = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteLinkshorteningMessagingService>>, TError,{domainSid: string;messagingServiceSid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteLinkshorteningMessagingService>>,
        TError,
        {domainSid: string;messagingServiceSid: string},
        TContext
      > => {

      const mutationOptions = getDeleteLinkshorteningMessagingServiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchLinkshorteningMessagingServiceDomainAssociationResponse200 = {
  data: MessagingV1LinkshorteningMessagingServiceDomainAssociation
  status: 200
}
    
export type fetchLinkshorteningMessagingServiceDomainAssociationResponseSuccess = (fetchLinkshorteningMessagingServiceDomainAssociationResponse200) & {
  headers: Headers;
};
;

export type fetchLinkshorteningMessagingServiceDomainAssociationResponse = (fetchLinkshorteningMessagingServiceDomainAssociationResponseSuccess)

export const getFetchLinkshorteningMessagingServiceDomainAssociationUrl = (messagingServiceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/MessagingServices/${messagingServiceSid}/Domain`
}

export const fetchLinkshorteningMessagingServiceDomainAssociation = async (messagingServiceSid: string, options?: RequestInit): Promise<fetchLinkshorteningMessagingServiceDomainAssociationResponse> => {
  
  const res = await fetch(getFetchLinkshorteningMessagingServiceDomainAssociationUrl(messagingServiceSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchLinkshorteningMessagingServiceDomainAssociationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchLinkshorteningMessagingServiceDomainAssociationResponse
}





export const getFetchLinkshorteningMessagingServiceDomainAssociationQueryKey = (messagingServiceSid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/LinkShortening/MessagingServices/${messagingServiceSid}/Domain`
    ] as const;
    }

    
export const getFetchLinkshorteningMessagingServiceDomainAssociationQueryOptions = <TData = Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError = unknown>(messagingServiceSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchLinkshorteningMessagingServiceDomainAssociationQueryKey(messagingServiceSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>> = ({ signal }) => fetchLinkshorteningMessagingServiceDomainAssociation(messagingServiceSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messagingServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchLinkshorteningMessagingServiceDomainAssociationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>>
export type FetchLinkshorteningMessagingServiceDomainAssociationQueryError = unknown


export function useFetchLinkshorteningMessagingServiceDomainAssociation<TData = Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError = unknown>(
 messagingServiceSid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>,
          TError,
          Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchLinkshorteningMessagingServiceDomainAssociation<TData = Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError = unknown>(
 messagingServiceSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>,
          TError,
          Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchLinkshorteningMessagingServiceDomainAssociation<TData = Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError = unknown>(
 messagingServiceSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchLinkshorteningMessagingServiceDomainAssociation<TData = Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError = unknown>(
 messagingServiceSid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchLinkshorteningMessagingServiceDomainAssociation>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchLinkshorteningMessagingServiceDomainAssociationQueryOptions(messagingServiceSid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type createPhoneNumberResponse200 = {
  data: MessagingV1ServicePhoneNumber
  status: 200
}

export type createPhoneNumberResponse201 = {
  data: MessagingV1ServicePhoneNumber
  status: 201
}
    
export type createPhoneNumberResponseSuccess = (createPhoneNumberResponse200 | createPhoneNumberResponse201) & {
  headers: Headers;
};
;

export type createPhoneNumberResponse = (createPhoneNumberResponseSuccess)

export const getCreatePhoneNumberUrl = (serviceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/PhoneNumbers`
}

export const createPhoneNumber = async (serviceSid: string,
    createPhoneNumberBody: CreatePhoneNumberBody, options?: RequestInit): Promise<createPhoneNumberResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`PhoneNumberSid`, createPhoneNumberBody.PhoneNumberSid)

  const res = await fetch(getCreatePhoneNumberUrl(serviceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createPhoneNumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createPhoneNumberResponse
}




export const getCreatePhoneNumberMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPhoneNumber>>, TError,{serviceSid: string;data: CreatePhoneNumberBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createPhoneNumber>>, TError,{serviceSid: string;data: CreatePhoneNumberBody}, TContext> => {

const mutationKey = ['createPhoneNumber'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createPhoneNumber>>, {serviceSid: string;data: CreatePhoneNumberBody}> = (props) => {
          const {serviceSid,data} = props ?? {};

          return  createPhoneNumber(serviceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreatePhoneNumberMutationResult = NonNullable<Awaited<ReturnType<typeof createPhoneNumber>>>
    export type CreatePhoneNumberMutationBody = CreatePhoneNumberBody
    export type CreatePhoneNumberMutationError = unknown

    export const useCreatePhoneNumber = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createPhoneNumber>>, TError,{serviceSid: string;data: CreatePhoneNumberBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createPhoneNumber>>,
        TError,
        {serviceSid: string;data: CreatePhoneNumberBody},
        TContext
      > => {

      const mutationOptions = getCreatePhoneNumberMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type listPhoneNumberResponse200 = {
  data: ListPhoneNumber200
  status: 200
}
    
export type listPhoneNumberResponseSuccess = (listPhoneNumberResponse200) & {
  headers: Headers;
};
;

export type listPhoneNumberResponse = (listPhoneNumberResponseSuccess)

export const getListPhoneNumberUrl = (serviceSid: string,
    params?: ListPhoneNumberParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Services/${serviceSid}/PhoneNumbers?${stringifiedParams}` : `https://messaging.twilio.com/v1/Services/${serviceSid}/PhoneNumbers`
}

export const listPhoneNumber = async (serviceSid: string,
    params?: ListPhoneNumberParams, options?: RequestInit): Promise<listPhoneNumberResponse> => {
  
  const res = await fetch(getListPhoneNumberUrl(serviceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listPhoneNumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listPhoneNumberResponse
}





export const getListPhoneNumberQueryKey = (serviceSid?: string,
    params?: ListPhoneNumberParams,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${serviceSid}/PhoneNumbers`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListPhoneNumberQueryOptions = <TData = Awaited<ReturnType<typeof listPhoneNumber>>, TError = unknown>(serviceSid: string,
    params?: ListPhoneNumberParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPhoneNumber>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListPhoneNumberQueryKey(serviceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listPhoneNumber>>> = ({ signal }) => listPhoneNumber(serviceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(serviceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listPhoneNumber>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListPhoneNumberQueryResult = NonNullable<Awaited<ReturnType<typeof listPhoneNumber>>>
export type ListPhoneNumberQueryError = unknown


export function useListPhoneNumber<TData = Awaited<ReturnType<typeof listPhoneNumber>>, TError = unknown>(
 serviceSid: string,
    params: undefined |  ListPhoneNumberParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPhoneNumber>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPhoneNumber>>,
          TError,
          Awaited<ReturnType<typeof listPhoneNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPhoneNumber<TData = Awaited<ReturnType<typeof listPhoneNumber>>, TError = unknown>(
 serviceSid: string,
    params?: ListPhoneNumberParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPhoneNumber>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listPhoneNumber>>,
          TError,
          Awaited<ReturnType<typeof listPhoneNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListPhoneNumber<TData = Awaited<ReturnType<typeof listPhoneNumber>>, TError = unknown>(
 serviceSid: string,
    params?: ListPhoneNumberParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPhoneNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListPhoneNumber<TData = Awaited<ReturnType<typeof listPhoneNumber>>, TError = unknown>(
 serviceSid: string,
    params?: ListPhoneNumberParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listPhoneNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListPhoneNumberQueryOptions(serviceSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type deletePhoneNumberResponse204 = {
  data: void
  status: 204
}
    
export type deletePhoneNumberResponseSuccess = (deletePhoneNumberResponse204) & {
  headers: Headers;
};
;

export type deletePhoneNumberResponse = (deletePhoneNumberResponseSuccess)

export const getDeletePhoneNumberUrl = (serviceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/PhoneNumbers/${sid}`
}

export const deletePhoneNumber = async (serviceSid: string,
    sid: string, options?: RequestInit): Promise<deletePhoneNumberResponse> => {
  
  const res = await fetch(getDeletePhoneNumberUrl(serviceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deletePhoneNumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deletePhoneNumberResponse
}




export const getDeletePhoneNumberMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePhoneNumber>>, TError,{serviceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deletePhoneNumber>>, TError,{serviceSid: string;sid: string}, TContext> => {

const mutationKey = ['deletePhoneNumber'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deletePhoneNumber>>, {serviceSid: string;sid: string}> = (props) => {
          const {serviceSid,sid} = props ?? {};

          return  deletePhoneNumber(serviceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeletePhoneNumberMutationResult = NonNullable<Awaited<ReturnType<typeof deletePhoneNumber>>>
    
    export type DeletePhoneNumberMutationError = unknown

    export const useDeletePhoneNumber = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deletePhoneNumber>>, TError,{serviceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deletePhoneNumber>>,
        TError,
        {serviceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeletePhoneNumberMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchPhoneNumberResponse200 = {
  data: MessagingV1ServicePhoneNumber
  status: 200
}
    
export type fetchPhoneNumberResponseSuccess = (fetchPhoneNumberResponse200) & {
  headers: Headers;
};
;

export type fetchPhoneNumberResponse = (fetchPhoneNumberResponseSuccess)

export const getFetchPhoneNumberUrl = (serviceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/PhoneNumbers/${sid}`
}

export const fetchPhoneNumber = async (serviceSid: string,
    sid: string, options?: RequestInit): Promise<fetchPhoneNumberResponse> => {
  
  const res = await fetch(getFetchPhoneNumberUrl(serviceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchPhoneNumberResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchPhoneNumberResponse
}





export const getFetchPhoneNumberQueryKey = (serviceSid?: string,
    sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${serviceSid}/PhoneNumbers/${sid}`
    ] as const;
    }

    
export const getFetchPhoneNumberQueryOptions = <TData = Awaited<ReturnType<typeof fetchPhoneNumber>>, TError = unknown>(serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchPhoneNumber>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchPhoneNumberQueryKey(serviceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchPhoneNumber>>> = ({ signal }) => fetchPhoneNumber(serviceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(serviceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchPhoneNumber>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchPhoneNumberQueryResult = NonNullable<Awaited<ReturnType<typeof fetchPhoneNumber>>>
export type FetchPhoneNumberQueryError = unknown


export function useFetchPhoneNumber<TData = Awaited<ReturnType<typeof fetchPhoneNumber>>, TError = unknown>(
 serviceSid: string,
    sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchPhoneNumber>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchPhoneNumber>>,
          TError,
          Awaited<ReturnType<typeof fetchPhoneNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchPhoneNumber<TData = Awaited<ReturnType<typeof fetchPhoneNumber>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchPhoneNumber>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchPhoneNumber>>,
          TError,
          Awaited<ReturnType<typeof fetchPhoneNumber>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchPhoneNumber<TData = Awaited<ReturnType<typeof fetchPhoneNumber>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchPhoneNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchPhoneNumber<TData = Awaited<ReturnType<typeof fetchPhoneNumber>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchPhoneNumber>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchPhoneNumberQueryOptions(serviceSid,sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type updateRequestManagedCertResponse200 = {
  data: MessagingV1RequestManagedCert
  status: 200
}

export type updateRequestManagedCertResponse201 = {
  data: MessagingV1RequestManagedCert
  status: 201
}
    
export type updateRequestManagedCertResponseSuccess = (updateRequestManagedCertResponse200 | updateRequestManagedCertResponse201) & {
  headers: Headers;
};
;

export type updateRequestManagedCertResponse = (updateRequestManagedCertResponseSuccess)

export const getUpdateRequestManagedCertUrl = (domainSid: string,) => {


  

  return `https://messaging.twilio.com/v1/LinkShortening/Domains/${domainSid}/RequestManagedCert`
}

export const updateRequestManagedCert = async (domainSid: string, options?: RequestInit): Promise<updateRequestManagedCertResponse> => {
  
  const res = await fetch(getUpdateRequestManagedCertUrl(domainSid),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateRequestManagedCertResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateRequestManagedCertResponse
}




export const getUpdateRequestManagedCertMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRequestManagedCert>>, TError,{domainSid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateRequestManagedCert>>, TError,{domainSid: string}, TContext> => {

const mutationKey = ['updateRequestManagedCert'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRequestManagedCert>>, {domainSid: string}> = (props) => {
          const {domainSid} = props ?? {};

          return  updateRequestManagedCert(domainSid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRequestManagedCertMutationResult = NonNullable<Awaited<ReturnType<typeof updateRequestManagedCert>>>
    
    export type UpdateRequestManagedCertMutationError = unknown

    export const useUpdateRequestManagedCert = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRequestManagedCert>>, TError,{domainSid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateRequestManagedCert>>,
        TError,
        {domainSid: string},
        TContext
      > => {

      const mutationOptions = getUpdateRequestManagedCertMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createServiceResponse201 = {
  data: MessagingV1Service
  status: 201
}
    
export type createServiceResponseSuccess = (createServiceResponse201) & {
  headers: Headers;
};
;

export type createServiceResponse = (createServiceResponseSuccess)

export const getCreateServiceUrl = () => {


  

  return `https://messaging.twilio.com/v1/Services`
}

export const createService = async (createServiceBody: CreateServiceBody, options?: RequestInit): Promise<createServiceResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`FriendlyName`, createServiceBody.FriendlyName)
if(createServiceBody.InboundRequestUrl !== undefined) {
 formUrlEncoded.append(`InboundRequestUrl`, createServiceBody.InboundRequestUrl)
 }
if(createServiceBody.InboundMethod !== undefined) {
 formUrlEncoded.append(`InboundMethod`, createServiceBody.InboundMethod)
 }
if(createServiceBody.FallbackUrl !== undefined) {
 formUrlEncoded.append(`FallbackUrl`, createServiceBody.FallbackUrl)
 }
if(createServiceBody.FallbackMethod !== undefined) {
 formUrlEncoded.append(`FallbackMethod`, createServiceBody.FallbackMethod)
 }
if(createServiceBody.StatusCallback !== undefined) {
 formUrlEncoded.append(`StatusCallback`, createServiceBody.StatusCallback)
 }
if(createServiceBody.StickySender !== undefined) {
 formUrlEncoded.append(`StickySender`, createServiceBody.StickySender.toString())
 }
if(createServiceBody.MmsConverter !== undefined) {
 formUrlEncoded.append(`MmsConverter`, createServiceBody.MmsConverter.toString())
 }
if(createServiceBody.SmartEncoding !== undefined) {
 formUrlEncoded.append(`SmartEncoding`, createServiceBody.SmartEncoding.toString())
 }
if(createServiceBody.ScanMessageContent !== undefined) {
 formUrlEncoded.append(`ScanMessageContent`, createServiceBody.ScanMessageContent)
 }
if(createServiceBody.FallbackToLongCode !== undefined) {
 formUrlEncoded.append(`FallbackToLongCode`, createServiceBody.FallbackToLongCode.toString())
 }
if(createServiceBody.AreaCodeGeomatch !== undefined) {
 formUrlEncoded.append(`AreaCodeGeomatch`, createServiceBody.AreaCodeGeomatch.toString())
 }
if(createServiceBody.ValidityPeriod !== undefined) {
 formUrlEncoded.append(`ValidityPeriod`, createServiceBody.ValidityPeriod.toString())
 }
if(createServiceBody.SynchronousValidation !== undefined) {
 formUrlEncoded.append(`SynchronousValidation`, createServiceBody.SynchronousValidation.toString())
 }
if(createServiceBody.Usecase !== undefined) {
 formUrlEncoded.append(`Usecase`, createServiceBody.Usecase)
 }
if(createServiceBody.UseInboundWebhookOnNumber !== undefined) {
 formUrlEncoded.append(`UseInboundWebhookOnNumber`, createServiceBody.UseInboundWebhookOnNumber.toString())
 }

  const res = await fetch(getCreateServiceUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceResponse
}




export const getCreateServiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceBody}, TContext> => {

const mutationKey = ['createService'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createService>>, {data: CreateServiceBody}> = (props) => {
          const {data} = props ?? {};

          return  createService(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceMutationResult = NonNullable<Awaited<ReturnType<typeof createService>>>
    export type CreateServiceMutationBody = CreateServiceBody
    export type CreateServiceMutationError = unknown

    export const useCreateService = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createService>>,
        TError,
        {data: CreateServiceBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type listServiceResponse200 = {
  data: ListService200
  status: 200
}
    
export type listServiceResponseSuccess = (listServiceResponse200) & {
  headers: Headers;
};
;

export type listServiceResponse = (listServiceResponseSuccess)

export const getListServiceUrl = (params?: ListServiceParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Services?${stringifiedParams}` : `https://messaging.twilio.com/v1/Services`
}

export const listService = async (params?: ListServiceParams, options?: RequestInit): Promise<listServiceResponse> => {
  
  const res = await fetch(getListServiceUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceResponse
}





export const getListServiceQueryKey = (params?: ListServiceParams,) => {
    return [
    `https://messaging.twilio.com/v1/Services`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceQueryOptions = <TData = Awaited<ReturnType<typeof listService>>, TError = unknown>(params?: ListServiceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listService>>> = ({ signal }) => listService(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListServiceQueryResult = NonNullable<Awaited<ReturnType<typeof listService>>>
export type ListServiceQueryError = unknown


export function useListService<TData = Awaited<ReturnType<typeof listService>>, TError = unknown>(
 params: undefined |  ListServiceParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listService>>,
          TError,
          Awaited<ReturnType<typeof listService>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListService<TData = Awaited<ReturnType<typeof listService>>, TError = unknown>(
 params?: ListServiceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listService>>,
          TError,
          Awaited<ReturnType<typeof listService>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListService<TData = Awaited<ReturnType<typeof listService>>, TError = unknown>(
 params?: ListServiceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListService<TData = Awaited<ReturnType<typeof listService>>, TError = unknown>(
 params?: ListServiceParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListServiceQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type updateServiceResponse200 = {
  data: MessagingV1Service
  status: 200
}
    
export type updateServiceResponseSuccess = (updateServiceResponse200) & {
  headers: Headers;
};
;

export type updateServiceResponse = (updateServiceResponseSuccess)

export const getUpdateServiceUrl = (sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${sid}`
}

export const updateService = async (sid: string,
    updateServiceBody: UpdateServiceBody, options?: RequestInit): Promise<updateServiceResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, updateServiceBody.FriendlyName)
 }
if(updateServiceBody.InboundRequestUrl !== undefined) {
 formUrlEncoded.append(`InboundRequestUrl`, updateServiceBody.InboundRequestUrl)
 }
if(updateServiceBody.InboundMethod !== undefined) {
 formUrlEncoded.append(`InboundMethod`, updateServiceBody.InboundMethod)
 }
if(updateServiceBody.FallbackUrl !== undefined) {
 formUrlEncoded.append(`FallbackUrl`, updateServiceBody.FallbackUrl)
 }
if(updateServiceBody.FallbackMethod !== undefined) {
 formUrlEncoded.append(`FallbackMethod`, updateServiceBody.FallbackMethod)
 }
if(updateServiceBody.StatusCallback !== undefined) {
 formUrlEncoded.append(`StatusCallback`, updateServiceBody.StatusCallback)
 }
if(updateServiceBody.StickySender !== undefined) {
 formUrlEncoded.append(`StickySender`, updateServiceBody.StickySender.toString())
 }
if(updateServiceBody.MmsConverter !== undefined) {
 formUrlEncoded.append(`MmsConverter`, updateServiceBody.MmsConverter.toString())
 }
if(updateServiceBody.SmartEncoding !== undefined) {
 formUrlEncoded.append(`SmartEncoding`, updateServiceBody.SmartEncoding.toString())
 }
if(updateServiceBody.ScanMessageContent !== undefined) {
 formUrlEncoded.append(`ScanMessageContent`, updateServiceBody.ScanMessageContent)
 }
if(updateServiceBody.FallbackToLongCode !== undefined) {
 formUrlEncoded.append(`FallbackToLongCode`, updateServiceBody.FallbackToLongCode.toString())
 }
if(updateServiceBody.AreaCodeGeomatch !== undefined) {
 formUrlEncoded.append(`AreaCodeGeomatch`, updateServiceBody.AreaCodeGeomatch.toString())
 }
if(updateServiceBody.ValidityPeriod !== undefined) {
 formUrlEncoded.append(`ValidityPeriod`, updateServiceBody.ValidityPeriod.toString())
 }
if(updateServiceBody.SynchronousValidation !== undefined) {
 formUrlEncoded.append(`SynchronousValidation`, updateServiceBody.SynchronousValidation.toString())
 }
if(updateServiceBody.Usecase !== undefined) {
 formUrlEncoded.append(`Usecase`, updateServiceBody.Usecase)
 }
if(updateServiceBody.UseInboundWebhookOnNumber !== undefined) {
 formUrlEncoded.append(`UseInboundWebhookOnNumber`, updateServiceBody.UseInboundWebhookOnNumber.toString())
 }

  const res = await fetch(getUpdateServiceUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceResponse
}




export const getUpdateServiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{sid: string;data: UpdateServiceBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{sid: string;data: UpdateServiceBody}, TContext> => {

const mutationKey = ['updateService'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateService>>, {sid: string;data: UpdateServiceBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateService(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceMutationResult = NonNullable<Awaited<ReturnType<typeof updateService>>>
    export type UpdateServiceMutationBody = UpdateServiceBody
    export type UpdateServiceMutationError = unknown

    export const useUpdateService = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateService>>, TError,{sid: string;data: UpdateServiceBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateService>>,
        TError,
        {sid: string;data: UpdateServiceBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchServiceResponse200 = {
  data: MessagingV1Service
  status: 200
}
    
export type fetchServiceResponseSuccess = (fetchServiceResponse200) & {
  headers: Headers;
};
;

export type fetchServiceResponse = (fetchServiceResponseSuccess)

export const getFetchServiceUrl = (sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${sid}`
}

export const fetchService = async (sid: string, options?: RequestInit): Promise<fetchServiceResponse> => {
  
  const res = await fetch(getFetchServiceUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceResponse
}





export const getFetchServiceQueryKey = (sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${sid}`
    ] as const;
    }

    
export const getFetchServiceQueryOptions = <TData = Awaited<ReturnType<typeof fetchService>>, TError = unknown>(sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchService>>> = ({ signal }) => fetchService(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchServiceQueryResult = NonNullable<Awaited<ReturnType<typeof fetchService>>>
export type FetchServiceQueryError = unknown


export function useFetchService<TData = Awaited<ReturnType<typeof fetchService>>, TError = unknown>(
 sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchService>>,
          TError,
          Awaited<ReturnType<typeof fetchService>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchService<TData = Awaited<ReturnType<typeof fetchService>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchService>>,
          TError,
          Awaited<ReturnType<typeof fetchService>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchService<TData = Awaited<ReturnType<typeof fetchService>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchService<TData = Awaited<ReturnType<typeof fetchService>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchServiceQueryOptions(sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type deleteServiceResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceResponseSuccess = (deleteServiceResponse204) & {
  headers: Headers;
};
;

export type deleteServiceResponse = (deleteServiceResponseSuccess)

export const getDeleteServiceUrl = (sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${sid}`
}

export const deleteService = async (sid: string, options?: RequestInit): Promise<deleteServiceResponse> => {
  
  const res = await fetch(getDeleteServiceUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceResponse
}




export const getDeleteServiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteService'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteService>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteService(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteService>>>
    
    export type DeleteServiceMutationError = unknown

    export const useDeleteService = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteService>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createShortCodeResponse200 = {
  data: MessagingV1ServiceShortCode
  status: 200
}

export type createShortCodeResponse201 = {
  data: MessagingV1ServiceShortCode
  status: 201
}
    
export type createShortCodeResponseSuccess = (createShortCodeResponse200 | createShortCodeResponse201) & {
  headers: Headers;
};
;

export type createShortCodeResponse = (createShortCodeResponseSuccess)

export const getCreateShortCodeUrl = (serviceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/ShortCodes`
}

export const createShortCode = async (serviceSid: string,
    createShortCodeBody: CreateShortCodeBody, options?: RequestInit): Promise<createShortCodeResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`ShortCodeSid`, createShortCodeBody.ShortCodeSid)

  const res = await fetch(getCreateShortCodeUrl(serviceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createShortCodeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createShortCodeResponse
}




export const getCreateShortCodeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createShortCode>>, TError,{serviceSid: string;data: CreateShortCodeBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createShortCode>>, TError,{serviceSid: string;data: CreateShortCodeBody}, TContext> => {

const mutationKey = ['createShortCode'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createShortCode>>, {serviceSid: string;data: CreateShortCodeBody}> = (props) => {
          const {serviceSid,data} = props ?? {};

          return  createShortCode(serviceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateShortCodeMutationResult = NonNullable<Awaited<ReturnType<typeof createShortCode>>>
    export type CreateShortCodeMutationBody = CreateShortCodeBody
    export type CreateShortCodeMutationError = unknown

    export const useCreateShortCode = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createShortCode>>, TError,{serviceSid: string;data: CreateShortCodeBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createShortCode>>,
        TError,
        {serviceSid: string;data: CreateShortCodeBody},
        TContext
      > => {

      const mutationOptions = getCreateShortCodeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type listShortCodeResponse200 = {
  data: ListShortCode200
  status: 200
}
    
export type listShortCodeResponseSuccess = (listShortCodeResponse200) & {
  headers: Headers;
};
;

export type listShortCodeResponse = (listShortCodeResponseSuccess)

export const getListShortCodeUrl = (serviceSid: string,
    params?: ListShortCodeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Services/${serviceSid}/ShortCodes?${stringifiedParams}` : `https://messaging.twilio.com/v1/Services/${serviceSid}/ShortCodes`
}

export const listShortCode = async (serviceSid: string,
    params?: ListShortCodeParams, options?: RequestInit): Promise<listShortCodeResponse> => {
  
  const res = await fetch(getListShortCodeUrl(serviceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listShortCodeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listShortCodeResponse
}





export const getListShortCodeQueryKey = (serviceSid?: string,
    params?: ListShortCodeParams,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${serviceSid}/ShortCodes`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListShortCodeQueryOptions = <TData = Awaited<ReturnType<typeof listShortCode>>, TError = unknown>(serviceSid: string,
    params?: ListShortCodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listShortCode>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListShortCodeQueryKey(serviceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listShortCode>>> = ({ signal }) => listShortCode(serviceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(serviceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listShortCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListShortCodeQueryResult = NonNullable<Awaited<ReturnType<typeof listShortCode>>>
export type ListShortCodeQueryError = unknown


export function useListShortCode<TData = Awaited<ReturnType<typeof listShortCode>>, TError = unknown>(
 serviceSid: string,
    params: undefined |  ListShortCodeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listShortCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listShortCode>>,
          TError,
          Awaited<ReturnType<typeof listShortCode>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListShortCode<TData = Awaited<ReturnType<typeof listShortCode>>, TError = unknown>(
 serviceSid: string,
    params?: ListShortCodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listShortCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listShortCode>>,
          TError,
          Awaited<ReturnType<typeof listShortCode>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListShortCode<TData = Awaited<ReturnType<typeof listShortCode>>, TError = unknown>(
 serviceSid: string,
    params?: ListShortCodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listShortCode>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListShortCode<TData = Awaited<ReturnType<typeof listShortCode>>, TError = unknown>(
 serviceSid: string,
    params?: ListShortCodeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listShortCode>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListShortCodeQueryOptions(serviceSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type deleteShortCodeResponse204 = {
  data: void
  status: 204
}
    
export type deleteShortCodeResponseSuccess = (deleteShortCodeResponse204) & {
  headers: Headers;
};
;

export type deleteShortCodeResponse = (deleteShortCodeResponseSuccess)

export const getDeleteShortCodeUrl = (serviceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/ShortCodes/${sid}`
}

export const deleteShortCode = async (serviceSid: string,
    sid: string, options?: RequestInit): Promise<deleteShortCodeResponse> => {
  
  const res = await fetch(getDeleteShortCodeUrl(serviceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteShortCodeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteShortCodeResponse
}




export const getDeleteShortCodeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteShortCode>>, TError,{serviceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteShortCode>>, TError,{serviceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteShortCode'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteShortCode>>, {serviceSid: string;sid: string}> = (props) => {
          const {serviceSid,sid} = props ?? {};

          return  deleteShortCode(serviceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteShortCodeMutationResult = NonNullable<Awaited<ReturnType<typeof deleteShortCode>>>
    
    export type DeleteShortCodeMutationError = unknown

    export const useDeleteShortCode = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteShortCode>>, TError,{serviceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteShortCode>>,
        TError,
        {serviceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteShortCodeMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchShortCodeResponse200 = {
  data: MessagingV1ServiceShortCode
  status: 200
}
    
export type fetchShortCodeResponseSuccess = (fetchShortCodeResponse200) & {
  headers: Headers;
};
;

export type fetchShortCodeResponse = (fetchShortCodeResponseSuccess)

export const getFetchShortCodeUrl = (serviceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${serviceSid}/ShortCodes/${sid}`
}

export const fetchShortCode = async (serviceSid: string,
    sid: string, options?: RequestInit): Promise<fetchShortCodeResponse> => {
  
  const res = await fetch(getFetchShortCodeUrl(serviceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchShortCodeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchShortCodeResponse
}





export const getFetchShortCodeQueryKey = (serviceSid?: string,
    sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${serviceSid}/ShortCodes/${sid}`
    ] as const;
    }

    
export const getFetchShortCodeQueryOptions = <TData = Awaited<ReturnType<typeof fetchShortCode>>, TError = unknown>(serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchShortCode>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchShortCodeQueryKey(serviceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchShortCode>>> = ({ signal }) => fetchShortCode(serviceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(serviceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchShortCode>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchShortCodeQueryResult = NonNullable<Awaited<ReturnType<typeof fetchShortCode>>>
export type FetchShortCodeQueryError = unknown


export function useFetchShortCode<TData = Awaited<ReturnType<typeof fetchShortCode>>, TError = unknown>(
 serviceSid: string,
    sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchShortCode>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchShortCode>>,
          TError,
          Awaited<ReturnType<typeof fetchShortCode>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchShortCode<TData = Awaited<ReturnType<typeof fetchShortCode>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchShortCode>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchShortCode>>,
          TError,
          Awaited<ReturnType<typeof fetchShortCode>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchShortCode<TData = Awaited<ReturnType<typeof fetchShortCode>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchShortCode>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchShortCode<TData = Awaited<ReturnType<typeof fetchShortCode>>, TError = unknown>(
 serviceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchShortCode>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchShortCodeQueryOptions(serviceSid,sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a tollfree verification
 * @summary Retrieve a tollfree verification
 */
export type fetchTollfreeVerificationResponse200 = {
  data: MessagingV1TollfreeVerification
  status: 200
}
    
export type fetchTollfreeVerificationResponseSuccess = (fetchTollfreeVerificationResponse200) & {
  headers: Headers;
};
;

export type fetchTollfreeVerificationResponse = (fetchTollfreeVerificationResponseSuccess)

export const getFetchTollfreeVerificationUrl = (sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Tollfree/Verifications/${sid}`
}

export const fetchTollfreeVerification = async (sid: string, options?: RequestInit): Promise<fetchTollfreeVerificationResponse> => {
  
  const res = await fetch(getFetchTollfreeVerificationUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchTollfreeVerificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchTollfreeVerificationResponse
}





export const getFetchTollfreeVerificationQueryKey = (sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/Tollfree/Verifications/${sid}`
    ] as const;
    }

    
export const getFetchTollfreeVerificationQueryOptions = <TData = Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError = unknown>(sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchTollfreeVerificationQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchTollfreeVerification>>> = ({ signal }) => fetchTollfreeVerification(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchTollfreeVerificationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchTollfreeVerification>>>
export type FetchTollfreeVerificationQueryError = unknown


export function useFetchTollfreeVerification<TData = Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError = unknown>(
 sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchTollfreeVerification>>,
          TError,
          Awaited<ReturnType<typeof fetchTollfreeVerification>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchTollfreeVerification<TData = Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchTollfreeVerification>>,
          TError,
          Awaited<ReturnType<typeof fetchTollfreeVerification>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchTollfreeVerification<TData = Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a tollfree verification
 */

export function useFetchTollfreeVerification<TData = Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchTollfreeVerification>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchTollfreeVerificationQueryOptions(sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Edit a tollfree verification
 * @summary Edit a tollfree verification
 */
export type updateTollfreeVerificationResponse202 = {
  data: MessagingV1TollfreeVerification
  status: 202
}
    
export type updateTollfreeVerificationResponseSuccess = (updateTollfreeVerificationResponse202) & {
  headers: Headers;
};
;

export type updateTollfreeVerificationResponse = (updateTollfreeVerificationResponseSuccess)

export const getUpdateTollfreeVerificationUrl = (sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Tollfree/Verifications/${sid}`
}

export const updateTollfreeVerification = async (sid: string,
    updateTollfreeVerificationBody: UpdateTollfreeVerificationBody, options?: RequestInit): Promise<updateTollfreeVerificationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateTollfreeVerificationBody.BusinessName !== undefined) {
 formUrlEncoded.append(`BusinessName`, updateTollfreeVerificationBody.BusinessName)
 }
if(updateTollfreeVerificationBody.BusinessWebsite !== undefined) {
 formUrlEncoded.append(`BusinessWebsite`, updateTollfreeVerificationBody.BusinessWebsite)
 }
if(updateTollfreeVerificationBody.NotificationEmail !== undefined) {
 formUrlEncoded.append(`NotificationEmail`, updateTollfreeVerificationBody.NotificationEmail)
 }
if(updateTollfreeVerificationBody.UseCaseCategories !== undefined) {
 updateTollfreeVerificationBody.UseCaseCategories.forEach(value => formUrlEncoded.append(`UseCaseCategories`, value));
 }
if(updateTollfreeVerificationBody.UseCaseSummary !== undefined) {
 formUrlEncoded.append(`UseCaseSummary`, updateTollfreeVerificationBody.UseCaseSummary)
 }
if(updateTollfreeVerificationBody.ProductionMessageSample !== undefined) {
 formUrlEncoded.append(`ProductionMessageSample`, updateTollfreeVerificationBody.ProductionMessageSample)
 }
if(updateTollfreeVerificationBody.OptInImageUrls !== undefined) {
 updateTollfreeVerificationBody.OptInImageUrls.forEach(value => formUrlEncoded.append(`OptInImageUrls`, value));
 }
if(updateTollfreeVerificationBody.OptInType !== undefined) {
 formUrlEncoded.append(`OptInType`, updateTollfreeVerificationBody.OptInType)
 }
if(updateTollfreeVerificationBody.MessageVolume !== undefined) {
 formUrlEncoded.append(`MessageVolume`, updateTollfreeVerificationBody.MessageVolume)
 }
if(updateTollfreeVerificationBody.BusinessStreetAddress !== undefined) {
 formUrlEncoded.append(`BusinessStreetAddress`, updateTollfreeVerificationBody.BusinessStreetAddress)
 }
if(updateTollfreeVerificationBody.BusinessStreetAddress2 !== undefined) {
 formUrlEncoded.append(`BusinessStreetAddress2`, updateTollfreeVerificationBody.BusinessStreetAddress2)
 }
if(updateTollfreeVerificationBody.BusinessCity !== undefined) {
 formUrlEncoded.append(`BusinessCity`, updateTollfreeVerificationBody.BusinessCity)
 }
if(updateTollfreeVerificationBody.BusinessStateProvinceRegion !== undefined) {
 formUrlEncoded.append(`BusinessStateProvinceRegion`, updateTollfreeVerificationBody.BusinessStateProvinceRegion)
 }
if(updateTollfreeVerificationBody.BusinessPostalCode !== undefined) {
 formUrlEncoded.append(`BusinessPostalCode`, updateTollfreeVerificationBody.BusinessPostalCode)
 }
if(updateTollfreeVerificationBody.BusinessCountry !== undefined) {
 formUrlEncoded.append(`BusinessCountry`, updateTollfreeVerificationBody.BusinessCountry)
 }
if(updateTollfreeVerificationBody.AdditionalInformation !== undefined) {
 formUrlEncoded.append(`AdditionalInformation`, updateTollfreeVerificationBody.AdditionalInformation)
 }
if(updateTollfreeVerificationBody.BusinessContactFirstName !== undefined) {
 formUrlEncoded.append(`BusinessContactFirstName`, updateTollfreeVerificationBody.BusinessContactFirstName)
 }
if(updateTollfreeVerificationBody.BusinessContactLastName !== undefined) {
 formUrlEncoded.append(`BusinessContactLastName`, updateTollfreeVerificationBody.BusinessContactLastName)
 }
if(updateTollfreeVerificationBody.BusinessContactEmail !== undefined) {
 formUrlEncoded.append(`BusinessContactEmail`, updateTollfreeVerificationBody.BusinessContactEmail)
 }
if(updateTollfreeVerificationBody.BusinessContactPhone !== undefined) {
 formUrlEncoded.append(`BusinessContactPhone`, updateTollfreeVerificationBody.BusinessContactPhone)
 }
if(updateTollfreeVerificationBody.EditReason !== undefined) {
 formUrlEncoded.append(`EditReason`, updateTollfreeVerificationBody.EditReason)
 }
if(updateTollfreeVerificationBody.BusinessRegistrationNumber !== undefined) {
 formUrlEncoded.append(`BusinessRegistrationNumber`, updateTollfreeVerificationBody.BusinessRegistrationNumber)
 }
if(updateTollfreeVerificationBody.BusinessRegistrationAuthority !== undefined) {
 formUrlEncoded.append(`BusinessRegistrationAuthority`, updateTollfreeVerificationBody.BusinessRegistrationAuthority)
 }
if(updateTollfreeVerificationBody.BusinessRegistrationCountry !== undefined) {
 formUrlEncoded.append(`BusinessRegistrationCountry`, updateTollfreeVerificationBody.BusinessRegistrationCountry)
 }
if(updateTollfreeVerificationBody.BusinessType !== undefined) {
 formUrlEncoded.append(`BusinessType`, updateTollfreeVerificationBody.BusinessType)
 }
if(updateTollfreeVerificationBody.BusinessRegistrationPhoneNumber !== undefined) {
 formUrlEncoded.append(`BusinessRegistrationPhoneNumber`, updateTollfreeVerificationBody.BusinessRegistrationPhoneNumber)
 }
if(updateTollfreeVerificationBody.DoingBusinessAs !== undefined) {
 formUrlEncoded.append(`DoingBusinessAs`, updateTollfreeVerificationBody.DoingBusinessAs)
 }
if(updateTollfreeVerificationBody.OptInConfirmationMessage !== undefined) {
 formUrlEncoded.append(`OptInConfirmationMessage`, updateTollfreeVerificationBody.OptInConfirmationMessage)
 }
if(updateTollfreeVerificationBody.HelpMessageSample !== undefined) {
 formUrlEncoded.append(`HelpMessageSample`, updateTollfreeVerificationBody.HelpMessageSample)
 }
if(updateTollfreeVerificationBody.PrivacyPolicyUrl !== undefined) {
 formUrlEncoded.append(`PrivacyPolicyUrl`, updateTollfreeVerificationBody.PrivacyPolicyUrl)
 }
if(updateTollfreeVerificationBody.TermsAndConditionsUrl !== undefined) {
 formUrlEncoded.append(`TermsAndConditionsUrl`, updateTollfreeVerificationBody.TermsAndConditionsUrl)
 }
if(updateTollfreeVerificationBody.AgeGatedContent !== undefined) {
 formUrlEncoded.append(`AgeGatedContent`, updateTollfreeVerificationBody.AgeGatedContent.toString())
 }
if(updateTollfreeVerificationBody.OptInKeywords !== undefined) {
 updateTollfreeVerificationBody.OptInKeywords.forEach(value => formUrlEncoded.append(`OptInKeywords`, value));
 }
if(updateTollfreeVerificationBody.VettingProvider !== undefined && updateTollfreeVerificationBody.VettingProvider !== null) {
 formUrlEncoded.append(`VettingProvider`, updateTollfreeVerificationBody.VettingProvider)
 }
if(updateTollfreeVerificationBody.VettingId !== undefined) {
 formUrlEncoded.append(`VettingId`, updateTollfreeVerificationBody.VettingId)
 }

  const res = await fetch(getUpdateTollfreeVerificationUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateTollfreeVerificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateTollfreeVerificationResponse
}




export const getUpdateTollfreeVerificationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTollfreeVerification>>, TError,{sid: string;data: UpdateTollfreeVerificationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateTollfreeVerification>>, TError,{sid: string;data: UpdateTollfreeVerificationBody}, TContext> => {

const mutationKey = ['updateTollfreeVerification'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateTollfreeVerification>>, {sid: string;data: UpdateTollfreeVerificationBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateTollfreeVerification(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateTollfreeVerificationMutationResult = NonNullable<Awaited<ReturnType<typeof updateTollfreeVerification>>>
    export type UpdateTollfreeVerificationMutationBody = UpdateTollfreeVerificationBody
    export type UpdateTollfreeVerificationMutationError = unknown

    /**
 * @summary Edit a tollfree verification
 */
export const useUpdateTollfreeVerification = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateTollfreeVerification>>, TError,{sid: string;data: UpdateTollfreeVerificationBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateTollfreeVerification>>,
        TError,
        {sid: string;data: UpdateTollfreeVerificationBody},
        TContext
      > => {

      const mutationOptions = getUpdateTollfreeVerificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a tollfree verification
 * @summary Delete a tollfree verification
 */
export type deleteTollfreeVerificationResponse204 = {
  data: void
  status: 204
}
    
export type deleteTollfreeVerificationResponseSuccess = (deleteTollfreeVerificationResponse204) & {
  headers: Headers;
};
;

export type deleteTollfreeVerificationResponse = (deleteTollfreeVerificationResponseSuccess)

export const getDeleteTollfreeVerificationUrl = (sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Tollfree/Verifications/${sid}`
}

export const deleteTollfreeVerification = async (sid: string, options?: RequestInit): Promise<deleteTollfreeVerificationResponse> => {
  
  const res = await fetch(getDeleteTollfreeVerificationUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteTollfreeVerificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteTollfreeVerificationResponse
}




export const getDeleteTollfreeVerificationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTollfreeVerification>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteTollfreeVerification>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteTollfreeVerification'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteTollfreeVerification>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteTollfreeVerification(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteTollfreeVerificationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteTollfreeVerification>>>
    
    export type DeleteTollfreeVerificationMutationError = unknown

    /**
 * @summary Delete a tollfree verification
 */
export const useDeleteTollfreeVerification = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteTollfreeVerification>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteTollfreeVerification>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteTollfreeVerificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * List tollfree verifications
 * @summary List tollfree verifications
 */
export type listTollfreeVerificationResponse200 = {
  data: ListTollfreeVerification200
  status: 200
}
    
export type listTollfreeVerificationResponseSuccess = (listTollfreeVerificationResponse200) & {
  headers: Headers;
};
;

export type listTollfreeVerificationResponse = (listTollfreeVerificationResponseSuccess)

export const getListTollfreeVerificationUrl = (params?: ListTollfreeVerificationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["TrustProductSid"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Tollfree/Verifications?${stringifiedParams}` : `https://messaging.twilio.com/v1/Tollfree/Verifications`
}

export const listTollfreeVerification = async (params?: ListTollfreeVerificationParams, options?: RequestInit): Promise<listTollfreeVerificationResponse> => {
  
  const res = await fetch(getListTollfreeVerificationUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listTollfreeVerificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listTollfreeVerificationResponse
}





export const getListTollfreeVerificationQueryKey = (params?: ListTollfreeVerificationParams,) => {
    return [
    `https://messaging.twilio.com/v1/Tollfree/Verifications`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListTollfreeVerificationQueryOptions = <TData = Awaited<ReturnType<typeof listTollfreeVerification>>, TError = unknown>(params?: ListTollfreeVerificationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTollfreeVerification>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListTollfreeVerificationQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listTollfreeVerification>>> = ({ signal }) => listTollfreeVerification(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listTollfreeVerification>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListTollfreeVerificationQueryResult = NonNullable<Awaited<ReturnType<typeof listTollfreeVerification>>>
export type ListTollfreeVerificationQueryError = unknown


export function useListTollfreeVerification<TData = Awaited<ReturnType<typeof listTollfreeVerification>>, TError = unknown>(
 params: undefined |  ListTollfreeVerificationParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTollfreeVerification>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTollfreeVerification>>,
          TError,
          Awaited<ReturnType<typeof listTollfreeVerification>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTollfreeVerification<TData = Awaited<ReturnType<typeof listTollfreeVerification>>, TError = unknown>(
 params?: ListTollfreeVerificationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTollfreeVerification>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listTollfreeVerification>>,
          TError,
          Awaited<ReturnType<typeof listTollfreeVerification>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListTollfreeVerification<TData = Awaited<ReturnType<typeof listTollfreeVerification>>, TError = unknown>(
 params?: ListTollfreeVerificationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTollfreeVerification>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary List tollfree verifications
 */

export function useListTollfreeVerification<TData = Awaited<ReturnType<typeof listTollfreeVerification>>, TError = unknown>(
 params?: ListTollfreeVerificationParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listTollfreeVerification>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListTollfreeVerificationQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a tollfree verification
 * @summary Create a tollfree verification
 */
export type createTollfreeVerificationResponse201 = {
  data: MessagingV1TollfreeVerification
  status: 201
}
    
export type createTollfreeVerificationResponseSuccess = (createTollfreeVerificationResponse201) & {
  headers: Headers;
};
;

export type createTollfreeVerificationResponse = (createTollfreeVerificationResponseSuccess)

export const getCreateTollfreeVerificationUrl = () => {


  

  return `https://messaging.twilio.com/v1/Tollfree/Verifications`
}

export const createTollfreeVerification = async (createTollfreeVerificationBody: CreateTollfreeVerificationBody, options?: RequestInit): Promise<createTollfreeVerificationResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`BusinessName`, createTollfreeVerificationBody.BusinessName)
formUrlEncoded.append(`BusinessWebsite`, createTollfreeVerificationBody.BusinessWebsite)
formUrlEncoded.append(`NotificationEmail`, createTollfreeVerificationBody.NotificationEmail)
createTollfreeVerificationBody.UseCaseCategories.forEach(value => formUrlEncoded.append(`UseCaseCategories`, value));
formUrlEncoded.append(`UseCaseSummary`, createTollfreeVerificationBody.UseCaseSummary)
formUrlEncoded.append(`ProductionMessageSample`, createTollfreeVerificationBody.ProductionMessageSample)
createTollfreeVerificationBody.OptInImageUrls.forEach(value => formUrlEncoded.append(`OptInImageUrls`, value));
formUrlEncoded.append(`OptInType`, createTollfreeVerificationBody.OptInType)
formUrlEncoded.append(`MessageVolume`, createTollfreeVerificationBody.MessageVolume)
formUrlEncoded.append(`TollfreePhoneNumberSid`, createTollfreeVerificationBody.TollfreePhoneNumberSid)
if(createTollfreeVerificationBody.CustomerProfileSid !== undefined) {
 formUrlEncoded.append(`CustomerProfileSid`, createTollfreeVerificationBody.CustomerProfileSid)
 }
if(createTollfreeVerificationBody.BusinessStreetAddress !== undefined) {
 formUrlEncoded.append(`BusinessStreetAddress`, createTollfreeVerificationBody.BusinessStreetAddress)
 }
if(createTollfreeVerificationBody.BusinessStreetAddress2 !== undefined) {
 formUrlEncoded.append(`BusinessStreetAddress2`, createTollfreeVerificationBody.BusinessStreetAddress2)
 }
if(createTollfreeVerificationBody.BusinessCity !== undefined) {
 formUrlEncoded.append(`BusinessCity`, createTollfreeVerificationBody.BusinessCity)
 }
if(createTollfreeVerificationBody.BusinessStateProvinceRegion !== undefined) {
 formUrlEncoded.append(`BusinessStateProvinceRegion`, createTollfreeVerificationBody.BusinessStateProvinceRegion)
 }
if(createTollfreeVerificationBody.BusinessPostalCode !== undefined) {
 formUrlEncoded.append(`BusinessPostalCode`, createTollfreeVerificationBody.BusinessPostalCode)
 }
if(createTollfreeVerificationBody.BusinessCountry !== undefined) {
 formUrlEncoded.append(`BusinessCountry`, createTollfreeVerificationBody.BusinessCountry)
 }
if(createTollfreeVerificationBody.AdditionalInformation !== undefined) {
 formUrlEncoded.append(`AdditionalInformation`, createTollfreeVerificationBody.AdditionalInformation)
 }
if(createTollfreeVerificationBody.BusinessContactFirstName !== undefined) {
 formUrlEncoded.append(`BusinessContactFirstName`, createTollfreeVerificationBody.BusinessContactFirstName)
 }
if(createTollfreeVerificationBody.BusinessContactLastName !== undefined) {
 formUrlEncoded.append(`BusinessContactLastName`, createTollfreeVerificationBody.BusinessContactLastName)
 }
if(createTollfreeVerificationBody.BusinessContactEmail !== undefined) {
 formUrlEncoded.append(`BusinessContactEmail`, createTollfreeVerificationBody.BusinessContactEmail)
 }
if(createTollfreeVerificationBody.BusinessContactPhone !== undefined) {
 formUrlEncoded.append(`BusinessContactPhone`, createTollfreeVerificationBody.BusinessContactPhone)
 }
if(createTollfreeVerificationBody.ExternalReferenceId !== undefined) {
 formUrlEncoded.append(`ExternalReferenceId`, createTollfreeVerificationBody.ExternalReferenceId)
 }
if(createTollfreeVerificationBody.BusinessRegistrationNumber !== undefined) {
 formUrlEncoded.append(`BusinessRegistrationNumber`, createTollfreeVerificationBody.BusinessRegistrationNumber)
 }
if(createTollfreeVerificationBody.BusinessRegistrationAuthority !== undefined) {
 formUrlEncoded.append(`BusinessRegistrationAuthority`, createTollfreeVerificationBody.BusinessRegistrationAuthority)
 }
if(createTollfreeVerificationBody.BusinessRegistrationCountry !== undefined) {
 formUrlEncoded.append(`BusinessRegistrationCountry`, createTollfreeVerificationBody.BusinessRegistrationCountry)
 }
if(createTollfreeVerificationBody.BusinessType !== undefined) {
 formUrlEncoded.append(`BusinessType`, createTollfreeVerificationBody.BusinessType)
 }
if(createTollfreeVerificationBody.BusinessRegistrationPhoneNumber !== undefined) {
 formUrlEncoded.append(`BusinessRegistrationPhoneNumber`, createTollfreeVerificationBody.BusinessRegistrationPhoneNumber)
 }
if(createTollfreeVerificationBody.DoingBusinessAs !== undefined) {
 formUrlEncoded.append(`DoingBusinessAs`, createTollfreeVerificationBody.DoingBusinessAs)
 }
if(createTollfreeVerificationBody.OptInConfirmationMessage !== undefined) {
 formUrlEncoded.append(`OptInConfirmationMessage`, createTollfreeVerificationBody.OptInConfirmationMessage)
 }
if(createTollfreeVerificationBody.HelpMessageSample !== undefined) {
 formUrlEncoded.append(`HelpMessageSample`, createTollfreeVerificationBody.HelpMessageSample)
 }
if(createTollfreeVerificationBody.PrivacyPolicyUrl !== undefined) {
 formUrlEncoded.append(`PrivacyPolicyUrl`, createTollfreeVerificationBody.PrivacyPolicyUrl)
 }
if(createTollfreeVerificationBody.TermsAndConditionsUrl !== undefined) {
 formUrlEncoded.append(`TermsAndConditionsUrl`, createTollfreeVerificationBody.TermsAndConditionsUrl)
 }
if(createTollfreeVerificationBody.AgeGatedContent !== undefined) {
 formUrlEncoded.append(`AgeGatedContent`, createTollfreeVerificationBody.AgeGatedContent.toString())
 }
if(createTollfreeVerificationBody.OptInKeywords !== undefined) {
 createTollfreeVerificationBody.OptInKeywords.forEach(value => formUrlEncoded.append(`OptInKeywords`, value));
 }
if(createTollfreeVerificationBody.VettingProvider !== undefined && createTollfreeVerificationBody.VettingProvider !== null) {
 formUrlEncoded.append(`VettingProvider`, createTollfreeVerificationBody.VettingProvider)
 }
if(createTollfreeVerificationBody.VettingId !== undefined) {
 formUrlEncoded.append(`VettingId`, createTollfreeVerificationBody.VettingId)
 }

  const res = await fetch(getCreateTollfreeVerificationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createTollfreeVerificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createTollfreeVerificationResponse
}




export const getCreateTollfreeVerificationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTollfreeVerification>>, TError,{data: CreateTollfreeVerificationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createTollfreeVerification>>, TError,{data: CreateTollfreeVerificationBody}, TContext> => {

const mutationKey = ['createTollfreeVerification'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createTollfreeVerification>>, {data: CreateTollfreeVerificationBody}> = (props) => {
          const {data} = props ?? {};

          return  createTollfreeVerification(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateTollfreeVerificationMutationResult = NonNullable<Awaited<ReturnType<typeof createTollfreeVerification>>>
    export type CreateTollfreeVerificationMutationBody = CreateTollfreeVerificationBody
    export type CreateTollfreeVerificationMutationError = unknown

    /**
 * @summary Create a tollfree verification
 */
export const useCreateTollfreeVerification = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createTollfreeVerification>>, TError,{data: CreateTollfreeVerificationBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createTollfreeVerification>>,
        TError,
        {data: CreateTollfreeVerificationBody},
        TContext
      > => {

      const mutationOptions = getCreateTollfreeVerificationMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type createUsAppToPersonResponse201 = {
  data: MessagingV1ServiceUsAppToPerson
  status: 201
}
    
export type createUsAppToPersonResponseSuccess = (createUsAppToPersonResponse201) & {
  headers: Headers;
};
;

export type createUsAppToPersonResponse = (createUsAppToPersonResponseSuccess)

export const getCreateUsAppToPersonUrl = (messagingServiceSid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p`
}

export const createUsAppToPerson = async (messagingServiceSid: string,
    createUsAppToPersonBody: CreateUsAppToPersonBody, options?: RequestInit): Promise<createUsAppToPersonResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`BrandRegistrationSid`, createUsAppToPersonBody.BrandRegistrationSid)
formUrlEncoded.append(`Description`, createUsAppToPersonBody.Description)
formUrlEncoded.append(`MessageFlow`, createUsAppToPersonBody.MessageFlow)
createUsAppToPersonBody.MessageSamples.forEach(value => formUrlEncoded.append(`MessageSamples`, value));
formUrlEncoded.append(`UsAppToPersonUsecase`, createUsAppToPersonBody.UsAppToPersonUsecase)
formUrlEncoded.append(`HasEmbeddedLinks`, createUsAppToPersonBody.HasEmbeddedLinks.toString())
formUrlEncoded.append(`HasEmbeddedPhone`, createUsAppToPersonBody.HasEmbeddedPhone.toString())
if(createUsAppToPersonBody.OptInMessage !== undefined) {
 formUrlEncoded.append(`OptInMessage`, createUsAppToPersonBody.OptInMessage)
 }
if(createUsAppToPersonBody.OptOutMessage !== undefined) {
 formUrlEncoded.append(`OptOutMessage`, createUsAppToPersonBody.OptOutMessage)
 }
if(createUsAppToPersonBody.HelpMessage !== undefined) {
 formUrlEncoded.append(`HelpMessage`, createUsAppToPersonBody.HelpMessage)
 }
if(createUsAppToPersonBody.OptInKeywords !== undefined) {
 createUsAppToPersonBody.OptInKeywords.forEach(value => formUrlEncoded.append(`OptInKeywords`, value));
 }
if(createUsAppToPersonBody.OptOutKeywords !== undefined) {
 createUsAppToPersonBody.OptOutKeywords.forEach(value => formUrlEncoded.append(`OptOutKeywords`, value));
 }
if(createUsAppToPersonBody.HelpKeywords !== undefined) {
 createUsAppToPersonBody.HelpKeywords.forEach(value => formUrlEncoded.append(`HelpKeywords`, value));
 }
if(createUsAppToPersonBody.SubscriberOptIn !== undefined) {
 formUrlEncoded.append(`SubscriberOptIn`, createUsAppToPersonBody.SubscriberOptIn.toString())
 }
if(createUsAppToPersonBody.AgeGated !== undefined) {
 formUrlEncoded.append(`AgeGated`, createUsAppToPersonBody.AgeGated.toString())
 }
if(createUsAppToPersonBody.DirectLending !== undefined) {
 formUrlEncoded.append(`DirectLending`, createUsAppToPersonBody.DirectLending.toString())
 }

  const res = await fetch(getCreateUsAppToPersonUrl(messagingServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createUsAppToPersonResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createUsAppToPersonResponse
}




export const getCreateUsAppToPersonMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUsAppToPerson>>, TError,{messagingServiceSid: string;data: CreateUsAppToPersonBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createUsAppToPerson>>, TError,{messagingServiceSid: string;data: CreateUsAppToPersonBody}, TContext> => {

const mutationKey = ['createUsAppToPerson'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUsAppToPerson>>, {messagingServiceSid: string;data: CreateUsAppToPersonBody}> = (props) => {
          const {messagingServiceSid,data} = props ?? {};

          return  createUsAppToPerson(messagingServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUsAppToPersonMutationResult = NonNullable<Awaited<ReturnType<typeof createUsAppToPerson>>>
    export type CreateUsAppToPersonMutationBody = CreateUsAppToPersonBody
    export type CreateUsAppToPersonMutationError = unknown

    export const useCreateUsAppToPerson = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUsAppToPerson>>, TError,{messagingServiceSid: string;data: CreateUsAppToPersonBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createUsAppToPerson>>,
        TError,
        {messagingServiceSid: string;data: CreateUsAppToPersonBody},
        TContext
      > => {

      const mutationOptions = getCreateUsAppToPersonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type listUsAppToPersonResponse200 = {
  data: ListUsAppToPerson200
  status: 200
}
    
export type listUsAppToPersonResponseSuccess = (listUsAppToPersonResponse200) & {
  headers: Headers;
};
;

export type listUsAppToPersonResponse = (listUsAppToPersonResponseSuccess)

export const getListUsAppToPersonUrl = (messagingServiceSid: string,
    params?: ListUsAppToPersonParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p?${stringifiedParams}` : `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p`
}

export const listUsAppToPerson = async (messagingServiceSid: string,
    params?: ListUsAppToPersonParams, options?: RequestInit): Promise<listUsAppToPersonResponse> => {
  
  const res = await fetch(getListUsAppToPersonUrl(messagingServiceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUsAppToPersonResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUsAppToPersonResponse
}





export const getListUsAppToPersonQueryKey = (messagingServiceSid?: string,
    params?: ListUsAppToPersonParams,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListUsAppToPersonQueryOptions = <TData = Awaited<ReturnType<typeof listUsAppToPerson>>, TError = unknown>(messagingServiceSid: string,
    params?: ListUsAppToPersonParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsAppToPerson>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUsAppToPersonQueryKey(messagingServiceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUsAppToPerson>>> = ({ signal }) => listUsAppToPerson(messagingServiceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messagingServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUsAppToPerson>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListUsAppToPersonQueryResult = NonNullable<Awaited<ReturnType<typeof listUsAppToPerson>>>
export type ListUsAppToPersonQueryError = unknown


export function useListUsAppToPerson<TData = Awaited<ReturnType<typeof listUsAppToPerson>>, TError = unknown>(
 messagingServiceSid: string,
    params: undefined |  ListUsAppToPersonParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsAppToPerson>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsAppToPerson>>,
          TError,
          Awaited<ReturnType<typeof listUsAppToPerson>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsAppToPerson<TData = Awaited<ReturnType<typeof listUsAppToPerson>>, TError = unknown>(
 messagingServiceSid: string,
    params?: ListUsAppToPersonParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsAppToPerson>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listUsAppToPerson>>,
          TError,
          Awaited<ReturnType<typeof listUsAppToPerson>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListUsAppToPerson<TData = Awaited<ReturnType<typeof listUsAppToPerson>>, TError = unknown>(
 messagingServiceSid: string,
    params?: ListUsAppToPersonParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsAppToPerson>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useListUsAppToPerson<TData = Awaited<ReturnType<typeof listUsAppToPerson>>, TError = unknown>(
 messagingServiceSid: string,
    params?: ListUsAppToPersonParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listUsAppToPerson>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListUsAppToPersonQueryOptions(messagingServiceSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type deleteUsAppToPersonResponse204 = {
  data: void
  status: 204
}
    
export type deleteUsAppToPersonResponseSuccess = (deleteUsAppToPersonResponse204) & {
  headers: Headers;
};
;

export type deleteUsAppToPersonResponse = (deleteUsAppToPersonResponseSuccess)

export const getDeleteUsAppToPersonUrl = (messagingServiceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p/${sid}`
}

export const deleteUsAppToPerson = async (messagingServiceSid: string,
    sid: string, options?: RequestInit): Promise<deleteUsAppToPersonResponse> => {
  
  const res = await fetch(getDeleteUsAppToPersonUrl(messagingServiceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteUsAppToPersonResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteUsAppToPersonResponse
}




export const getDeleteUsAppToPersonMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsAppToPerson>>, TError,{messagingServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUsAppToPerson>>, TError,{messagingServiceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteUsAppToPerson'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUsAppToPerson>>, {messagingServiceSid: string;sid: string}> = (props) => {
          const {messagingServiceSid,sid} = props ?? {};

          return  deleteUsAppToPerson(messagingServiceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUsAppToPersonMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUsAppToPerson>>>
    
    export type DeleteUsAppToPersonMutationError = unknown

    export const useDeleteUsAppToPerson = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUsAppToPerson>>, TError,{messagingServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteUsAppToPerson>>,
        TError,
        {messagingServiceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteUsAppToPersonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchUsAppToPersonResponse200 = {
  data: MessagingV1ServiceUsAppToPerson
  status: 200
}
    
export type fetchUsAppToPersonResponseSuccess = (fetchUsAppToPersonResponse200) & {
  headers: Headers;
};
;

export type fetchUsAppToPersonResponse = (fetchUsAppToPersonResponseSuccess)

export const getFetchUsAppToPersonUrl = (messagingServiceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p/${sid}`
}

export const fetchUsAppToPerson = async (messagingServiceSid: string,
    sid: string, options?: RequestInit): Promise<fetchUsAppToPersonResponse> => {
  
  const res = await fetch(getFetchUsAppToPersonUrl(messagingServiceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchUsAppToPersonResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchUsAppToPersonResponse
}





export const getFetchUsAppToPersonQueryKey = (messagingServiceSid?: string,
    sid?: string,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p/${sid}`
    ] as const;
    }

    
export const getFetchUsAppToPersonQueryOptions = <TData = Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError = unknown>(messagingServiceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchUsAppToPersonQueryKey(messagingServiceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchUsAppToPerson>>> = ({ signal }) => fetchUsAppToPerson(messagingServiceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messagingServiceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchUsAppToPersonQueryResult = NonNullable<Awaited<ReturnType<typeof fetchUsAppToPerson>>>
export type FetchUsAppToPersonQueryError = unknown


export function useFetchUsAppToPerson<TData = Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError = unknown>(
 messagingServiceSid: string,
    sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchUsAppToPerson>>,
          TError,
          Awaited<ReturnType<typeof fetchUsAppToPerson>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchUsAppToPerson<TData = Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError = unknown>(
 messagingServiceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchUsAppToPerson>>,
          TError,
          Awaited<ReturnType<typeof fetchUsAppToPerson>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchUsAppToPerson<TData = Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError = unknown>(
 messagingServiceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchUsAppToPerson<TData = Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError = unknown>(
 messagingServiceSid: string,
    sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPerson>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchUsAppToPersonQueryOptions(messagingServiceSid,sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type updateUsAppToPersonResponse200 = {
  data: MessagingV1ServiceUsAppToPerson
  status: 200
}
    
export type updateUsAppToPersonResponseSuccess = (updateUsAppToPersonResponse200) & {
  headers: Headers;
};
;

export type updateUsAppToPersonResponse = (updateUsAppToPersonResponseSuccess)

export const getUpdateUsAppToPersonUrl = (messagingServiceSid: string,
    sid: string,) => {


  

  return `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p/${sid}`
}

export const updateUsAppToPerson = async (messagingServiceSid: string,
    sid: string,
    updateUsAppToPersonBody: UpdateUsAppToPersonBody, options?: RequestInit): Promise<updateUsAppToPersonResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`HasEmbeddedLinks`, updateUsAppToPersonBody.HasEmbeddedLinks.toString())
formUrlEncoded.append(`HasEmbeddedPhone`, updateUsAppToPersonBody.HasEmbeddedPhone.toString())
updateUsAppToPersonBody.MessageSamples.forEach(value => formUrlEncoded.append(`MessageSamples`, value));
formUrlEncoded.append(`MessageFlow`, updateUsAppToPersonBody.MessageFlow)
formUrlEncoded.append(`Description`, updateUsAppToPersonBody.Description)
formUrlEncoded.append(`AgeGated`, updateUsAppToPersonBody.AgeGated.toString())
formUrlEncoded.append(`DirectLending`, updateUsAppToPersonBody.DirectLending.toString())

  const res = await fetch(getUpdateUsAppToPersonUrl(messagingServiceSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateUsAppToPersonResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateUsAppToPersonResponse
}




export const getUpdateUsAppToPersonMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUsAppToPerson>>, TError,{messagingServiceSid: string;sid: string;data: UpdateUsAppToPersonBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateUsAppToPerson>>, TError,{messagingServiceSid: string;sid: string;data: UpdateUsAppToPersonBody}, TContext> => {

const mutationKey = ['updateUsAppToPerson'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUsAppToPerson>>, {messagingServiceSid: string;sid: string;data: UpdateUsAppToPersonBody}> = (props) => {
          const {messagingServiceSid,sid,data} = props ?? {};

          return  updateUsAppToPerson(messagingServiceSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUsAppToPersonMutationResult = NonNullable<Awaited<ReturnType<typeof updateUsAppToPerson>>>
    export type UpdateUsAppToPersonMutationBody = UpdateUsAppToPersonBody
    export type UpdateUsAppToPersonMutationError = unknown

    export const useUpdateUsAppToPerson = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUsAppToPerson>>, TError,{messagingServiceSid: string;sid: string;data: UpdateUsAppToPersonBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateUsAppToPerson>>,
        TError,
        {messagingServiceSid: string;sid: string;data: UpdateUsAppToPersonBody},
        TContext
      > => {

      const mutationOptions = getUpdateUsAppToPersonMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
export type fetchUsAppToPersonUsecaseResponse200 = {
  data: MessagingV1ServiceUsAppToPersonUsecase
  status: 200
}
    
export type fetchUsAppToPersonUsecaseResponseSuccess = (fetchUsAppToPersonUsecaseResponse200) & {
  headers: Headers;
};
;

export type fetchUsAppToPersonUsecaseResponse = (fetchUsAppToPersonUsecaseResponseSuccess)

export const getFetchUsAppToPersonUsecaseUrl = (messagingServiceSid: string,
    params?: FetchUsAppToPersonUsecaseParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p/Usecases?${stringifiedParams}` : `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p/Usecases`
}

export const fetchUsAppToPersonUsecase = async (messagingServiceSid: string,
    params?: FetchUsAppToPersonUsecaseParams, options?: RequestInit): Promise<fetchUsAppToPersonUsecaseResponse> => {
  
  const res = await fetch(getFetchUsAppToPersonUsecaseUrl(messagingServiceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchUsAppToPersonUsecaseResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchUsAppToPersonUsecaseResponse
}





export const getFetchUsAppToPersonUsecaseQueryKey = (messagingServiceSid?: string,
    params?: FetchUsAppToPersonUsecaseParams,) => {
    return [
    `https://messaging.twilio.com/v1/Services/${messagingServiceSid}/Compliance/Usa2p/Usecases`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getFetchUsAppToPersonUsecaseQueryOptions = <TData = Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError = unknown>(messagingServiceSid: string,
    params?: FetchUsAppToPersonUsecaseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchUsAppToPersonUsecaseQueryKey(messagingServiceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>> = ({ signal }) => fetchUsAppToPersonUsecase(messagingServiceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(messagingServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchUsAppToPersonUsecaseQueryResult = NonNullable<Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>>
export type FetchUsAppToPersonUsecaseQueryError = unknown


export function useFetchUsAppToPersonUsecase<TData = Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError = unknown>(
 messagingServiceSid: string,
    params: undefined |  FetchUsAppToPersonUsecaseParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>,
          TError,
          Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchUsAppToPersonUsecase<TData = Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError = unknown>(
 messagingServiceSid: string,
    params?: FetchUsAppToPersonUsecaseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>,
          TError,
          Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchUsAppToPersonUsecase<TData = Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError = unknown>(
 messagingServiceSid: string,
    params?: FetchUsAppToPersonUsecaseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchUsAppToPersonUsecase<TData = Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError = unknown>(
 messagingServiceSid: string,
    params?: FetchUsAppToPersonUsecaseParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsAppToPersonUsecase>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchUsAppToPersonUsecaseQueryOptions(messagingServiceSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type fetchUsecaseResponse200 = {
  data: MessagingV1Usecase
  status: 200
}
    
export type fetchUsecaseResponseSuccess = (fetchUsecaseResponse200) & {
  headers: Headers;
};
;

export type fetchUsecaseResponse = (fetchUsecaseResponseSuccess)

export const getFetchUsecaseUrl = () => {


  

  return `https://messaging.twilio.com/v1/Services/Usecases`
}

export const fetchUsecase = async ( options?: RequestInit): Promise<fetchUsecaseResponse> => {
  
  const res = await fetch(getFetchUsecaseUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchUsecaseResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchUsecaseResponse
}





export const getFetchUsecaseQueryKey = () => {
    return [
    `https://messaging.twilio.com/v1/Services/Usecases`
    ] as const;
    }

    
export const getFetchUsecaseQueryOptions = <TData = Awaited<ReturnType<typeof fetchUsecase>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsecase>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchUsecaseQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchUsecase>>> = ({ signal }) => fetchUsecase({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchUsecase>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchUsecaseQueryResult = NonNullable<Awaited<ReturnType<typeof fetchUsecase>>>
export type FetchUsecaseQueryError = unknown


export function useFetchUsecase<TData = Awaited<ReturnType<typeof fetchUsecase>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsecase>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchUsecase>>,
          TError,
          Awaited<ReturnType<typeof fetchUsecase>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchUsecase<TData = Awaited<ReturnType<typeof fetchUsecase>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsecase>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchUsecase>>,
          TError,
          Awaited<ReturnType<typeof fetchUsecase>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchUsecase<TData = Awaited<ReturnType<typeof fetchUsecase>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsecase>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }

export function useFetchUsecase<TData = Awaited<ReturnType<typeof fetchUsecase>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchUsecase>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchUsecaseQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
