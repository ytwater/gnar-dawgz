/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Twilio - Events
 * This is the public Twilio REST API.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  CreateSinkBody,
  CreateSinkValidateBody,
  CreateSubscribedEventBody,
  CreateSubscriptionBody,
  EventsV1EventType,
  EventsV1Schema,
  EventsV1SchemaSchemaVersion,
  EventsV1Sink,
  EventsV1SinkSinkTest,
  EventsV1SinkSinkValidate,
  EventsV1Subscription,
  EventsV1SubscriptionSubscribedEvent,
  ListEventType200,
  ListEventTypeParams,
  ListSchemaVersion200,
  ListSchemaVersionParams,
  ListSink200,
  ListSinkParams,
  ListSubscribedEvent200,
  ListSubscribedEventParams,
  ListSubscription200,
  ListSubscriptionParams,
  UpdateSinkBody,
  UpdateSubscribedEventBody,
  UpdateSubscriptionBody
} from './models';

/**
 * Retrieve a paginated list of all the available Event Types.
 * @summary Retrieve a paginated list of all the available Event Types.
 */
export type listEventTypeResponse200 = {
  data: ListEventType200
  status: 200
}
    
export type listEventTypeResponseSuccess = (listEventTypeResponse200) & {
  headers: Headers;
};
;

export type listEventTypeResponse = (listEventTypeResponseSuccess)

export const getListEventTypeUrl = (params?: ListEventTypeParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Types?${stringifiedParams}` : `https://conversations.twilio.com/v1/Types`
}

export const listEventType = async (params?: ListEventTypeParams, options?: RequestInit): Promise<listEventTypeResponse> => {
  
  const res = await fetch(getListEventTypeUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listEventTypeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listEventTypeResponse
}





export const getListEventTypeQueryKey = (params?: ListEventTypeParams,) => {
    return [
    `https://conversations.twilio.com/v1/Types`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListEventTypeQueryOptions = <TData = Awaited<ReturnType<typeof listEventType>>, TError = unknown>(params?: ListEventTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEventType>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListEventTypeQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listEventType>>> = ({ signal }) => listEventType(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listEventType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListEventTypeQueryResult = NonNullable<Awaited<ReturnType<typeof listEventType>>>
export type ListEventTypeQueryError = unknown


export function useListEventType<TData = Awaited<ReturnType<typeof listEventType>>, TError = unknown>(
 params: undefined |  ListEventTypeParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEventType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEventType>>,
          TError,
          Awaited<ReturnType<typeof listEventType>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListEventType<TData = Awaited<ReturnType<typeof listEventType>>, TError = unknown>(
 params?: ListEventTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEventType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listEventType>>,
          TError,
          Awaited<ReturnType<typeof listEventType>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListEventType<TData = Awaited<ReturnType<typeof listEventType>>, TError = unknown>(
 params?: ListEventTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEventType>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a paginated list of all the available Event Types.
 */

export function useListEventType<TData = Awaited<ReturnType<typeof listEventType>>, TError = unknown>(
 params?: ListEventTypeParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listEventType>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListEventTypeQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Fetch a specific Event Type.
 * @summary Fetch a specific Event Type.
 */
export type fetchEventTypeResponse200 = {
  data: EventsV1EventType
  status: 200
}
    
export type fetchEventTypeResponseSuccess = (fetchEventTypeResponse200) & {
  headers: Headers;
};
;

export type fetchEventTypeResponse = (fetchEventTypeResponseSuccess)

export const getFetchEventTypeUrl = (type: string,) => {


  

  return `https://conversations.twilio.com/v1/Types/${type}`
}

export const fetchEventType = async (type: string, options?: RequestInit): Promise<fetchEventTypeResponse> => {
  
  const res = await fetch(getFetchEventTypeUrl(type),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchEventTypeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchEventTypeResponse
}





export const getFetchEventTypeQueryKey = (type?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Types/${type}`
    ] as const;
    }

    
export const getFetchEventTypeQueryOptions = <TData = Awaited<ReturnType<typeof fetchEventType>>, TError = unknown>(type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchEventType>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchEventTypeQueryKey(type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchEventType>>> = ({ signal }) => fetchEventType(type, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchEventType>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchEventTypeQueryResult = NonNullable<Awaited<ReturnType<typeof fetchEventType>>>
export type FetchEventTypeQueryError = unknown


export function useFetchEventType<TData = Awaited<ReturnType<typeof fetchEventType>>, TError = unknown>(
 type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchEventType>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchEventType>>,
          TError,
          Awaited<ReturnType<typeof fetchEventType>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchEventType<TData = Awaited<ReturnType<typeof fetchEventType>>, TError = unknown>(
 type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchEventType>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchEventType>>,
          TError,
          Awaited<ReturnType<typeof fetchEventType>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchEventType<TData = Awaited<ReturnType<typeof fetchEventType>>, TError = unknown>(
 type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchEventType>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch a specific Event Type.
 */

export function useFetchEventType<TData = Awaited<ReturnType<typeof fetchEventType>>, TError = unknown>(
 type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchEventType>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchEventTypeQueryOptions(type,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Fetch a specific schema with its nested versions.
 * @summary Fetch a specific schema with its nested versions.
 */
export type fetchSchemaResponse200 = {
  data: EventsV1Schema
  status: 200
}
    
export type fetchSchemaResponseSuccess = (fetchSchemaResponse200) & {
  headers: Headers;
};
;

export type fetchSchemaResponse = (fetchSchemaResponseSuccess)

export const getFetchSchemaUrl = (id: string,) => {


  

  return `https://conversations.twilio.com/v1/Schemas/${id}`
}

export const fetchSchema = async (id: string, options?: RequestInit): Promise<fetchSchemaResponse> => {
  
  const res = await fetch(getFetchSchemaUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchSchemaResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchSchemaResponse
}





export const getFetchSchemaQueryKey = (id?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Schemas/${id}`
    ] as const;
    }

    
export const getFetchSchemaQueryOptions = <TData = Awaited<ReturnType<typeof fetchSchema>>, TError = unknown>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchema>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchSchemaQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchSchema>>> = ({ signal }) => fetchSchema(id, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchSchema>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchSchemaQueryResult = NonNullable<Awaited<ReturnType<typeof fetchSchema>>>
export type FetchSchemaQueryError = unknown


export function useFetchSchema<TData = Awaited<ReturnType<typeof fetchSchema>>, TError = unknown>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchema>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSchema>>,
          TError,
          Awaited<ReturnType<typeof fetchSchema>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSchema<TData = Awaited<ReturnType<typeof fetchSchema>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchema>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSchema>>,
          TError,
          Awaited<ReturnType<typeof fetchSchema>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSchema<TData = Awaited<ReturnType<typeof fetchSchema>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchema>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch a specific schema with its nested versions.
 */

export function useFetchSchema<TData = Awaited<ReturnType<typeof fetchSchema>>, TError = unknown>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchema>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchSchemaQueryOptions(id,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a paginated list of versions of the schema.
 * @summary Retrieve a paginated list of versions of the schema.
 */
export type listSchemaVersionResponse200 = {
  data: ListSchemaVersion200
  status: 200
}
    
export type listSchemaVersionResponseSuccess = (listSchemaVersionResponse200) & {
  headers: Headers;
};
;

export type listSchemaVersionResponse = (listSchemaVersionResponseSuccess)

export const getListSchemaVersionUrl = (id: string,
    params?: ListSchemaVersionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Schemas/${id}/Versions?${stringifiedParams}` : `https://conversations.twilio.com/v1/Schemas/${id}/Versions`
}

export const listSchemaVersion = async (id: string,
    params?: ListSchemaVersionParams, options?: RequestInit): Promise<listSchemaVersionResponse> => {
  
  const res = await fetch(getListSchemaVersionUrl(id,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listSchemaVersionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listSchemaVersionResponse
}





export const getListSchemaVersionQueryKey = (id?: string,
    params?: ListSchemaVersionParams,) => {
    return [
    `https://conversations.twilio.com/v1/Schemas/${id}/Versions`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListSchemaVersionQueryOptions = <TData = Awaited<ReturnType<typeof listSchemaVersion>>, TError = unknown>(id: string,
    params?: ListSchemaVersionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemaVersion>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSchemaVersionQueryKey(id,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSchemaVersion>>> = ({ signal }) => listSchemaVersion(id,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSchemaVersion>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSchemaVersionQueryResult = NonNullable<Awaited<ReturnType<typeof listSchemaVersion>>>
export type ListSchemaVersionQueryError = unknown


export function useListSchemaVersion<TData = Awaited<ReturnType<typeof listSchemaVersion>>, TError = unknown>(
 id: string,
    params: undefined |  ListSchemaVersionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemaVersion>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSchemaVersion>>,
          TError,
          Awaited<ReturnType<typeof listSchemaVersion>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSchemaVersion<TData = Awaited<ReturnType<typeof listSchemaVersion>>, TError = unknown>(
 id: string,
    params?: ListSchemaVersionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemaVersion>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSchemaVersion>>,
          TError,
          Awaited<ReturnType<typeof listSchemaVersion>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSchemaVersion<TData = Awaited<ReturnType<typeof listSchemaVersion>>, TError = unknown>(
 id: string,
    params?: ListSchemaVersionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemaVersion>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a paginated list of versions of the schema.
 */

export function useListSchemaVersion<TData = Awaited<ReturnType<typeof listSchemaVersion>>, TError = unknown>(
 id: string,
    params?: ListSchemaVersionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSchemaVersion>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSchemaVersionQueryOptions(id,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Fetch a specific schema and version.
 * @summary Fetch a specific schema and version.
 */
export type fetchSchemaVersionResponse200 = {
  data: EventsV1SchemaSchemaVersion
  status: 200
}
    
export type fetchSchemaVersionResponseSuccess = (fetchSchemaVersionResponse200) & {
  headers: Headers;
};
;

export type fetchSchemaVersionResponse = (fetchSchemaVersionResponseSuccess)

export const getFetchSchemaVersionUrl = (id: string,
    schemaVersion: number,) => {


  

  return `https://conversations.twilio.com/v1/Schemas/${id}/Versions/${schemaVersion}`
}

export const fetchSchemaVersion = async (id: string,
    schemaVersion: number, options?: RequestInit): Promise<fetchSchemaVersionResponse> => {
  
  const res = await fetch(getFetchSchemaVersionUrl(id,schemaVersion),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchSchemaVersionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchSchemaVersionResponse
}





export const getFetchSchemaVersionQueryKey = (id?: string,
    schemaVersion?: number,) => {
    return [
    `https://conversations.twilio.com/v1/Schemas/${id}/Versions/${schemaVersion}`
    ] as const;
    }

    
export const getFetchSchemaVersionQueryOptions = <TData = Awaited<ReturnType<typeof fetchSchemaVersion>>, TError = unknown>(id: string,
    schemaVersion: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchemaVersion>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchSchemaVersionQueryKey(id,schemaVersion);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchSchemaVersion>>> = ({ signal }) => fetchSchemaVersion(id,schemaVersion, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id && schemaVersion), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchSchemaVersion>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchSchemaVersionQueryResult = NonNullable<Awaited<ReturnType<typeof fetchSchemaVersion>>>
export type FetchSchemaVersionQueryError = unknown


export function useFetchSchemaVersion<TData = Awaited<ReturnType<typeof fetchSchemaVersion>>, TError = unknown>(
 id: string,
    schemaVersion: number, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchemaVersion>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSchemaVersion>>,
          TError,
          Awaited<ReturnType<typeof fetchSchemaVersion>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSchemaVersion<TData = Awaited<ReturnType<typeof fetchSchemaVersion>>, TError = unknown>(
 id: string,
    schemaVersion: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchemaVersion>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSchemaVersion>>,
          TError,
          Awaited<ReturnType<typeof fetchSchemaVersion>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSchemaVersion<TData = Awaited<ReturnType<typeof fetchSchemaVersion>>, TError = unknown>(
 id: string,
    schemaVersion: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchemaVersion>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch a specific schema and version.
 */

export function useFetchSchemaVersion<TData = Awaited<ReturnType<typeof fetchSchemaVersion>>, TError = unknown>(
 id: string,
    schemaVersion: number, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSchemaVersion>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchSchemaVersionQueryOptions(id,schemaVersion,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Fetch a specific Sink.
 * @summary Fetch a specific Sink.
 */
export type fetchSinkResponse200 = {
  data: EventsV1Sink
  status: 200
}
    
export type fetchSinkResponseSuccess = (fetchSinkResponse200) & {
  headers: Headers;
};
;

export type fetchSinkResponse = (fetchSinkResponseSuccess)

export const getFetchSinkUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Sinks/${sid}`
}

export const fetchSink = async (sid: string, options?: RequestInit): Promise<fetchSinkResponse> => {
  
  const res = await fetch(getFetchSinkUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchSinkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchSinkResponse
}





export const getFetchSinkQueryKey = (sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Sinks/${sid}`
    ] as const;
    }

    
export const getFetchSinkQueryOptions = <TData = Awaited<ReturnType<typeof fetchSink>>, TError = unknown>(sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSink>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchSinkQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchSink>>> = ({ signal }) => fetchSink(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchSink>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchSinkQueryResult = NonNullable<Awaited<ReturnType<typeof fetchSink>>>
export type FetchSinkQueryError = unknown


export function useFetchSink<TData = Awaited<ReturnType<typeof fetchSink>>, TError = unknown>(
 sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSink>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSink>>,
          TError,
          Awaited<ReturnType<typeof fetchSink>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSink<TData = Awaited<ReturnType<typeof fetchSink>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSink>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSink>>,
          TError,
          Awaited<ReturnType<typeof fetchSink>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSink<TData = Awaited<ReturnType<typeof fetchSink>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSink>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch a specific Sink.
 */

export function useFetchSink<TData = Awaited<ReturnType<typeof fetchSink>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSink>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchSinkQueryOptions(sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Delete a specific Sink.
 * @summary Delete a specific Sink.
 */
export type deleteSinkResponse204 = {
  data: void
  status: 204
}
    
export type deleteSinkResponseSuccess = (deleteSinkResponse204) & {
  headers: Headers;
};
;

export type deleteSinkResponse = (deleteSinkResponseSuccess)

export const getDeleteSinkUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Sinks/${sid}`
}

export const deleteSink = async (sid: string, options?: RequestInit): Promise<deleteSinkResponse> => {
  
  const res = await fetch(getDeleteSinkUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteSinkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteSinkResponse
}




export const getDeleteSinkMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSink>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSink>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteSink'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSink>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteSink(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSinkMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSink>>>
    
    export type DeleteSinkMutationError = unknown

    /**
 * @summary Delete a specific Sink.
 */
export const useDeleteSink = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSink>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSink>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteSinkMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Update a specific Sink
 * @summary Update a specific Sink
 */
export type updateSinkResponse200 = {
  data: EventsV1Sink
  status: 200
}
    
export type updateSinkResponseSuccess = (updateSinkResponse200) & {
  headers: Headers;
};
;

export type updateSinkResponse = (updateSinkResponseSuccess)

export const getUpdateSinkUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Sinks/${sid}`
}

export const updateSink = async (sid: string,
    updateSinkBody: UpdateSinkBody, options?: RequestInit): Promise<updateSinkResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Description`, updateSinkBody.Description)

  const res = await fetch(getUpdateSinkUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateSinkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateSinkResponse
}




export const getUpdateSinkMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSink>>, TError,{sid: string;data: UpdateSinkBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateSink>>, TError,{sid: string;data: UpdateSinkBody}, TContext> => {

const mutationKey = ['updateSink'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSink>>, {sid: string;data: UpdateSinkBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateSink(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSinkMutationResult = NonNullable<Awaited<ReturnType<typeof updateSink>>>
    export type UpdateSinkMutationBody = UpdateSinkBody
    export type UpdateSinkMutationError = unknown

    /**
 * @summary Update a specific Sink
 */
export const useUpdateSink = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSink>>, TError,{sid: string;data: UpdateSinkBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSink>>,
        TError,
        {sid: string;data: UpdateSinkBody},
        TContext
      > => {

      const mutationOptions = getUpdateSinkMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Create a new Sink
 * @summary Create a new Sink
 */
export type createSinkResponse201 = {
  data: EventsV1Sink
  status: 201
}
    
export type createSinkResponseSuccess = (createSinkResponse201) & {
  headers: Headers;
};
;

export type createSinkResponse = (createSinkResponseSuccess)

export const getCreateSinkUrl = () => {


  

  return `https://conversations.twilio.com/v1/Sinks`
}

export const createSink = async (createSinkBody: CreateSinkBody, options?: RequestInit): Promise<createSinkResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Description`, createSinkBody.Description)
formUrlEncoded.append(`SinkConfiguration`, createSinkBody.SinkConfiguration)
formUrlEncoded.append(`SinkType`, createSinkBody.SinkType)

  const res = await fetch(getCreateSinkUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createSinkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createSinkResponse
}




export const getCreateSinkMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSink>>, TError,{data: CreateSinkBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createSink>>, TError,{data: CreateSinkBody}, TContext> => {

const mutationKey = ['createSink'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSink>>, {data: CreateSinkBody}> = (props) => {
          const {data} = props ?? {};

          return  createSink(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSinkMutationResult = NonNullable<Awaited<ReturnType<typeof createSink>>>
    export type CreateSinkMutationBody = CreateSinkBody
    export type CreateSinkMutationError = unknown

    /**
 * @summary Create a new Sink
 */
export const useCreateSink = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSink>>, TError,{data: CreateSinkBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSink>>,
        TError,
        {data: CreateSinkBody},
        TContext
      > => {

      const mutationOptions = getCreateSinkMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a paginated list of Sinks belonging to the account used to make the request.
 * @summary Retrieve a paginated list of Sinks belonging to the account used to make the request.
 */
export type listSinkResponse200 = {
  data: ListSink200
  status: 200
}
    
export type listSinkResponseSuccess = (listSinkResponse200) & {
  headers: Headers;
};
;

export type listSinkResponse = (listSinkResponseSuccess)

export const getListSinkUrl = (params?: ListSinkParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Sinks?${stringifiedParams}` : `https://conversations.twilio.com/v1/Sinks`
}

export const listSink = async (params?: ListSinkParams, options?: RequestInit): Promise<listSinkResponse> => {
  
  const res = await fetch(getListSinkUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listSinkResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listSinkResponse
}





export const getListSinkQueryKey = (params?: ListSinkParams,) => {
    return [
    `https://conversations.twilio.com/v1/Sinks`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListSinkQueryOptions = <TData = Awaited<ReturnType<typeof listSink>>, TError = unknown>(params?: ListSinkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSink>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSinkQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSink>>> = ({ signal }) => listSink(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSink>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSinkQueryResult = NonNullable<Awaited<ReturnType<typeof listSink>>>
export type ListSinkQueryError = unknown


export function useListSink<TData = Awaited<ReturnType<typeof listSink>>, TError = unknown>(
 params: undefined |  ListSinkParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSink>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSink>>,
          TError,
          Awaited<ReturnType<typeof listSink>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSink<TData = Awaited<ReturnType<typeof listSink>>, TError = unknown>(
 params?: ListSinkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSink>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSink>>,
          TError,
          Awaited<ReturnType<typeof listSink>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSink<TData = Awaited<ReturnType<typeof listSink>>, TError = unknown>(
 params?: ListSinkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSink>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a paginated list of Sinks belonging to the account used to make the request.
 */

export function useListSink<TData = Awaited<ReturnType<typeof listSink>>, TError = unknown>(
 params?: ListSinkParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSink>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSinkQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new Sink Test Event for the given Sink.
 * @summary Create a new Sink Test Event for the given Sink.
 */
export type createSinkTestResponse200 = {
  data: EventsV1SinkSinkTest
  status: 200
}

export type createSinkTestResponse201 = {
  data: EventsV1SinkSinkTest
  status: 201
}
    
export type createSinkTestResponseSuccess = (createSinkTestResponse200 | createSinkTestResponse201) & {
  headers: Headers;
};
;

export type createSinkTestResponse = (createSinkTestResponseSuccess)

export const getCreateSinkTestUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Sinks/${sid}/Test`
}

export const createSinkTest = async (sid: string, options?: RequestInit): Promise<createSinkTestResponse> => {
  
  const res = await fetch(getCreateSinkTestUrl(sid),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createSinkTestResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createSinkTestResponse
}




export const getCreateSinkTestMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSinkTest>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createSinkTest>>, TError,{sid: string}, TContext> => {

const mutationKey = ['createSinkTest'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSinkTest>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  createSinkTest(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSinkTestMutationResult = NonNullable<Awaited<ReturnType<typeof createSinkTest>>>
    
    export type CreateSinkTestMutationError = unknown

    /**
 * @summary Create a new Sink Test Event for the given Sink.
 */
export const useCreateSinkTest = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSinkTest>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSinkTest>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getCreateSinkTestMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Validate that a test event for a Sink was received.
 * @summary Validate that a test event for a Sink was received.
 */
export type createSinkValidateResponse201 = {
  data: EventsV1SinkSinkValidate
  status: 201
}
    
export type createSinkValidateResponseSuccess = (createSinkValidateResponse201) & {
  headers: Headers;
};
;

export type createSinkValidateResponse = (createSinkValidateResponseSuccess)

export const getCreateSinkValidateUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Sinks/${sid}/Validate`
}

export const createSinkValidate = async (sid: string,
    createSinkValidateBody: CreateSinkValidateBody, options?: RequestInit): Promise<createSinkValidateResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`TestId`, createSinkValidateBody.TestId)

  const res = await fetch(getCreateSinkValidateUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createSinkValidateResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createSinkValidateResponse
}




export const getCreateSinkValidateMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSinkValidate>>, TError,{sid: string;data: CreateSinkValidateBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createSinkValidate>>, TError,{sid: string;data: CreateSinkValidateBody}, TContext> => {

const mutationKey = ['createSinkValidate'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSinkValidate>>, {sid: string;data: CreateSinkValidateBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  createSinkValidate(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSinkValidateMutationResult = NonNullable<Awaited<ReturnType<typeof createSinkValidate>>>
    export type CreateSinkValidateMutationBody = CreateSinkValidateBody
    export type CreateSinkValidateMutationError = unknown

    /**
 * @summary Validate that a test event for a Sink was received.
 */
export const useCreateSinkValidate = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSinkValidate>>, TError,{sid: string;data: CreateSinkValidateBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSinkValidate>>,
        TError,
        {sid: string;data: CreateSinkValidateBody},
        TContext
      > => {

      const mutationOptions = getCreateSinkValidateMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a list of all Subscribed Event types for a Subscription.
 * @summary Retrieve a list of all Subscribed Event types for a Subscription.
 */
export type listSubscribedEventResponse200 = {
  data: ListSubscribedEvent200
  status: 200
}
    
export type listSubscribedEventResponseSuccess = (listSubscribedEventResponse200) & {
  headers: Headers;
};
;

export type listSubscribedEventResponse = (listSubscribedEventResponseSuccess)

export const getListSubscribedEventUrl = (subscriptionSid: string,
    params?: ListSubscribedEventParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Subscriptions/${subscriptionSid}/SubscribedEvents?${stringifiedParams}` : `https://conversations.twilio.com/v1/Subscriptions/${subscriptionSid}/SubscribedEvents`
}

export const listSubscribedEvent = async (subscriptionSid: string,
    params?: ListSubscribedEventParams, options?: RequestInit): Promise<listSubscribedEventResponse> => {
  
  const res = await fetch(getListSubscribedEventUrl(subscriptionSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listSubscribedEventResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listSubscribedEventResponse
}





export const getListSubscribedEventQueryKey = (subscriptionSid?: string,
    params?: ListSubscribedEventParams,) => {
    return [
    `https://conversations.twilio.com/v1/Subscriptions/${subscriptionSid}/SubscribedEvents`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListSubscribedEventQueryOptions = <TData = Awaited<ReturnType<typeof listSubscribedEvent>>, TError = unknown>(subscriptionSid: string,
    params?: ListSubscribedEventParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscribedEvent>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSubscribedEventQueryKey(subscriptionSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSubscribedEvent>>> = ({ signal }) => listSubscribedEvent(subscriptionSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(subscriptionSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSubscribedEvent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSubscribedEventQueryResult = NonNullable<Awaited<ReturnType<typeof listSubscribedEvent>>>
export type ListSubscribedEventQueryError = unknown


export function useListSubscribedEvent<TData = Awaited<ReturnType<typeof listSubscribedEvent>>, TError = unknown>(
 subscriptionSid: string,
    params: undefined |  ListSubscribedEventParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscribedEvent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSubscribedEvent>>,
          TError,
          Awaited<ReturnType<typeof listSubscribedEvent>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSubscribedEvent<TData = Awaited<ReturnType<typeof listSubscribedEvent>>, TError = unknown>(
 subscriptionSid: string,
    params?: ListSubscribedEventParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscribedEvent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSubscribedEvent>>,
          TError,
          Awaited<ReturnType<typeof listSubscribedEvent>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSubscribedEvent<TData = Awaited<ReturnType<typeof listSubscribedEvent>>, TError = unknown>(
 subscriptionSid: string,
    params?: ListSubscribedEventParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscribedEvent>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a list of all Subscribed Event types for a Subscription.
 */

export function useListSubscribedEvent<TData = Awaited<ReturnType<typeof listSubscribedEvent>>, TError = unknown>(
 subscriptionSid: string,
    params?: ListSubscribedEventParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscribedEvent>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSubscribedEventQueryOptions(subscriptionSid,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add an event type to a Subscription.
 * @summary Add an event type to a Subscription.
 */
export type createSubscribedEventResponse200 = {
  data: EventsV1SubscriptionSubscribedEvent
  status: 200
}

export type createSubscribedEventResponse201 = {
  data: EventsV1SubscriptionSubscribedEvent
  status: 201
}
    
export type createSubscribedEventResponseSuccess = (createSubscribedEventResponse200 | createSubscribedEventResponse201) & {
  headers: Headers;
};
;

export type createSubscribedEventResponse = (createSubscribedEventResponseSuccess)

export const getCreateSubscribedEventUrl = (subscriptionSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Subscriptions/${subscriptionSid}/SubscribedEvents`
}

export const createSubscribedEvent = async (subscriptionSid: string,
    createSubscribedEventBody: CreateSubscribedEventBody, options?: RequestInit): Promise<createSubscribedEventResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Type`, createSubscribedEventBody.Type)
if(createSubscribedEventBody.SchemaVersion !== undefined) {
 formUrlEncoded.append(`SchemaVersion`, createSubscribedEventBody.SchemaVersion.toString())
 }

  const res = await fetch(getCreateSubscribedEventUrl(subscriptionSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createSubscribedEventResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createSubscribedEventResponse
}




export const getCreateSubscribedEventMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubscribedEvent>>, TError,{subscriptionSid: string;data: CreateSubscribedEventBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createSubscribedEvent>>, TError,{subscriptionSid: string;data: CreateSubscribedEventBody}, TContext> => {

const mutationKey = ['createSubscribedEvent'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubscribedEvent>>, {subscriptionSid: string;data: CreateSubscribedEventBody}> = (props) => {
          const {subscriptionSid,data} = props ?? {};

          return  createSubscribedEvent(subscriptionSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSubscribedEventMutationResult = NonNullable<Awaited<ReturnType<typeof createSubscribedEvent>>>
    export type CreateSubscribedEventMutationBody = CreateSubscribedEventBody
    export type CreateSubscribedEventMutationError = unknown

    /**
 * @summary Add an event type to a Subscription.
 */
export const useCreateSubscribedEvent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubscribedEvent>>, TError,{subscriptionSid: string;data: CreateSubscribedEventBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSubscribedEvent>>,
        TError,
        {subscriptionSid: string;data: CreateSubscribedEventBody},
        TContext
      > => {

      const mutationOptions = getCreateSubscribedEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Read an Event for a Subscription.
 * @summary Read an Event for a Subscription.
 */
export type fetchSubscribedEventResponse200 = {
  data: EventsV1SubscriptionSubscribedEvent
  status: 200
}
    
export type fetchSubscribedEventResponseSuccess = (fetchSubscribedEventResponse200) & {
  headers: Headers;
};
;

export type fetchSubscribedEventResponse = (fetchSubscribedEventResponseSuccess)

export const getFetchSubscribedEventUrl = (subscriptionSid: string,
    type: string,) => {


  

  return `https://conversations.twilio.com/v1/Subscriptions/${subscriptionSid}/SubscribedEvents/${type}`
}

export const fetchSubscribedEvent = async (subscriptionSid: string,
    type: string, options?: RequestInit): Promise<fetchSubscribedEventResponse> => {
  
  const res = await fetch(getFetchSubscribedEventUrl(subscriptionSid,type),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchSubscribedEventResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchSubscribedEventResponse
}





export const getFetchSubscribedEventQueryKey = (subscriptionSid?: string,
    type?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Subscriptions/${subscriptionSid}/SubscribedEvents/${type}`
    ] as const;
    }

    
export const getFetchSubscribedEventQueryOptions = <TData = Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError = unknown>(subscriptionSid: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchSubscribedEventQueryKey(subscriptionSid,type);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchSubscribedEvent>>> = ({ signal }) => fetchSubscribedEvent(subscriptionSid,type, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(subscriptionSid && type), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchSubscribedEventQueryResult = NonNullable<Awaited<ReturnType<typeof fetchSubscribedEvent>>>
export type FetchSubscribedEventQueryError = unknown


export function useFetchSubscribedEvent<TData = Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError = unknown>(
 subscriptionSid: string,
    type: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSubscribedEvent>>,
          TError,
          Awaited<ReturnType<typeof fetchSubscribedEvent>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSubscribedEvent<TData = Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError = unknown>(
 subscriptionSid: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSubscribedEvent>>,
          TError,
          Awaited<ReturnType<typeof fetchSubscribedEvent>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSubscribedEvent<TData = Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError = unknown>(
 subscriptionSid: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read an Event for a Subscription.
 */

export function useFetchSubscribedEvent<TData = Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError = unknown>(
 subscriptionSid: string,
    type: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscribedEvent>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchSubscribedEventQueryOptions(subscriptionSid,type,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an Event for a Subscription.
 * @summary Update an Event for a Subscription.
 */
export type updateSubscribedEventResponse200 = {
  data: EventsV1SubscriptionSubscribedEvent
  status: 200
}
    
export type updateSubscribedEventResponseSuccess = (updateSubscribedEventResponse200) & {
  headers: Headers;
};
;

export type updateSubscribedEventResponse = (updateSubscribedEventResponseSuccess)

export const getUpdateSubscribedEventUrl = (subscriptionSid: string,
    type: string,) => {


  

  return `https://conversations.twilio.com/v1/Subscriptions/${subscriptionSid}/SubscribedEvents/${type}`
}

export const updateSubscribedEvent = async (subscriptionSid: string,
    type: string,
    updateSubscribedEventBody: UpdateSubscribedEventBody, options?: RequestInit): Promise<updateSubscribedEventResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateSubscribedEventBody.SchemaVersion !== undefined) {
 formUrlEncoded.append(`SchemaVersion`, updateSubscribedEventBody.SchemaVersion.toString())
 }

  const res = await fetch(getUpdateSubscribedEventUrl(subscriptionSid,type),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateSubscribedEventResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateSubscribedEventResponse
}




export const getUpdateSubscribedEventMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubscribedEvent>>, TError,{subscriptionSid: string;type: string;data: UpdateSubscribedEventBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateSubscribedEvent>>, TError,{subscriptionSid: string;type: string;data: UpdateSubscribedEventBody}, TContext> => {

const mutationKey = ['updateSubscribedEvent'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubscribedEvent>>, {subscriptionSid: string;type: string;data: UpdateSubscribedEventBody}> = (props) => {
          const {subscriptionSid,type,data} = props ?? {};

          return  updateSubscribedEvent(subscriptionSid,type,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSubscribedEventMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubscribedEvent>>>
    export type UpdateSubscribedEventMutationBody = UpdateSubscribedEventBody
    export type UpdateSubscribedEventMutationError = unknown

    /**
 * @summary Update an Event for a Subscription.
 */
export const useUpdateSubscribedEvent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubscribedEvent>>, TError,{subscriptionSid: string;type: string;data: UpdateSubscribedEventBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSubscribedEvent>>,
        TError,
        {subscriptionSid: string;type: string;data: UpdateSubscribedEventBody},
        TContext
      > => {

      const mutationOptions = getUpdateSubscribedEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Remove an event type from a Subscription.
 * @summary Remove an event type from a Subscription.
 */
export type deleteSubscribedEventResponse204 = {
  data: void
  status: 204
}
    
export type deleteSubscribedEventResponseSuccess = (deleteSubscribedEventResponse204) & {
  headers: Headers;
};
;

export type deleteSubscribedEventResponse = (deleteSubscribedEventResponseSuccess)

export const getDeleteSubscribedEventUrl = (subscriptionSid: string,
    type: string,) => {


  

  return `https://conversations.twilio.com/v1/Subscriptions/${subscriptionSid}/SubscribedEvents/${type}`
}

export const deleteSubscribedEvent = async (subscriptionSid: string,
    type: string, options?: RequestInit): Promise<deleteSubscribedEventResponse> => {
  
  const res = await fetch(getDeleteSubscribedEventUrl(subscriptionSid,type),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteSubscribedEventResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteSubscribedEventResponse
}




export const getDeleteSubscribedEventMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubscribedEvent>>, TError,{subscriptionSid: string;type: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSubscribedEvent>>, TError,{subscriptionSid: string;type: string}, TContext> => {

const mutationKey = ['deleteSubscribedEvent'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubscribedEvent>>, {subscriptionSid: string;type: string}> = (props) => {
          const {subscriptionSid,type} = props ?? {};

          return  deleteSubscribedEvent(subscriptionSid,type,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSubscribedEventMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubscribedEvent>>>
    
    export type DeleteSubscribedEventMutationError = unknown

    /**
 * @summary Remove an event type from a Subscription.
 */
export const useDeleteSubscribedEvent = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubscribedEvent>>, TError,{subscriptionSid: string;type: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSubscribedEvent>>,
        TError,
        {subscriptionSid: string;type: string},
        TContext
      > => {

      const mutationOptions = getDeleteSubscribedEventMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Retrieve a paginated list of Subscriptions belonging to the account used to make the request.
 * @summary Retrieve a paginated list of Subscriptions belonging to the account used to make the request.
 */
export type listSubscriptionResponse200 = {
  data: ListSubscription200
  status: 200
}
    
export type listSubscriptionResponseSuccess = (listSubscriptionResponse200) & {
  headers: Headers;
};
;

export type listSubscriptionResponse = (listSubscriptionResponseSuccess)

export const getListSubscriptionUrl = (params?: ListSubscriptionParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Subscriptions?${stringifiedParams}` : `https://conversations.twilio.com/v1/Subscriptions`
}

export const listSubscription = async (params?: ListSubscriptionParams, options?: RequestInit): Promise<listSubscriptionResponse> => {
  
  const res = await fetch(getListSubscriptionUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listSubscriptionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listSubscriptionResponse
}





export const getListSubscriptionQueryKey = (params?: ListSubscriptionParams,) => {
    return [
    `https://conversations.twilio.com/v1/Subscriptions`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof listSubscription>>, TError = unknown>(params?: ListSubscriptionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscription>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListSubscriptionQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listSubscription>>> = ({ signal }) => listSubscription(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listSubscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ListSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof listSubscription>>>
export type ListSubscriptionQueryError = unknown


export function useListSubscription<TData = Awaited<ReturnType<typeof listSubscription>>, TError = unknown>(
 params: undefined |  ListSubscriptionParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSubscription>>,
          TError,
          Awaited<ReturnType<typeof listSubscription>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSubscription<TData = Awaited<ReturnType<typeof listSubscription>>, TError = unknown>(
 params?: ListSubscriptionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof listSubscription>>,
          TError,
          Awaited<ReturnType<typeof listSubscription>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useListSubscription<TData = Awaited<ReturnType<typeof listSubscription>>, TError = unknown>(
 params?: ListSubscriptionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscription>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Retrieve a paginated list of Subscriptions belonging to the account used to make the request.
 */

export function useListSubscription<TData = Awaited<ReturnType<typeof listSubscription>>, TError = unknown>(
 params?: ListSubscriptionParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof listSubscription>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getListSubscriptionQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new Subscription.
 * @summary Create a new Subscription.
 */
export type createSubscriptionResponse201 = {
  data: EventsV1Subscription
  status: 201
}
    
export type createSubscriptionResponseSuccess = (createSubscriptionResponse201) & {
  headers: Headers;
};
;

export type createSubscriptionResponse = (createSubscriptionResponseSuccess)

export const getCreateSubscriptionUrl = () => {


  

  return `https://conversations.twilio.com/v1/Subscriptions`
}

export const createSubscription = async (createSubscriptionBody: CreateSubscriptionBody, options?: RequestInit): Promise<createSubscriptionResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Description`, createSubscriptionBody.Description)
formUrlEncoded.append(`SinkSid`, createSubscriptionBody.SinkSid)
createSubscriptionBody.Types.forEach(value => formUrlEncoded.append(`Types`, value));

  const res = await fetch(getCreateSubscriptionUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createSubscriptionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createSubscriptionResponse
}




export const getCreateSubscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubscription>>, TError,{data: CreateSubscriptionBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createSubscription>>, TError,{data: CreateSubscriptionBody}, TContext> => {

const mutationKey = ['createSubscription'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createSubscription>>, {data: CreateSubscriptionBody}> = (props) => {
          const {data} = props ?? {};

          return  createSubscription(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof createSubscription>>>
    export type CreateSubscriptionMutationBody = CreateSubscriptionBody
    export type CreateSubscriptionMutationError = unknown

    /**
 * @summary Create a new Subscription.
 */
export const useCreateSubscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createSubscription>>, TError,{data: CreateSubscriptionBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof createSubscription>>,
        TError,
        {data: CreateSubscriptionBody},
        TContext
      > => {

      const mutationOptions = getCreateSubscriptionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Fetch a specific Subscription.
 * @summary Fetch a specific Subscription.
 */
export type fetchSubscriptionResponse200 = {
  data: EventsV1Subscription
  status: 200
}
    
export type fetchSubscriptionResponseSuccess = (fetchSubscriptionResponse200) & {
  headers: Headers;
};
;

export type fetchSubscriptionResponse = (fetchSubscriptionResponseSuccess)

export const getFetchSubscriptionUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Subscriptions/${sid}`
}

export const fetchSubscription = async (sid: string, options?: RequestInit): Promise<fetchSubscriptionResponse> => {
  
  const res = await fetch(getFetchSubscriptionUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchSubscriptionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchSubscriptionResponse
}





export const getFetchSubscriptionQueryKey = (sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Subscriptions/${sid}`
    ] as const;
    }

    
export const getFetchSubscriptionQueryOptions = <TData = Awaited<ReturnType<typeof fetchSubscription>>, TError = unknown>(sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscription>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchSubscriptionQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchSubscription>>> = ({ signal }) => fetchSubscription(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchSubscription>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type FetchSubscriptionQueryResult = NonNullable<Awaited<ReturnType<typeof fetchSubscription>>>
export type FetchSubscriptionQueryError = unknown


export function useFetchSubscription<TData = Awaited<ReturnType<typeof fetchSubscription>>, TError = unknown>(
 sid: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscription>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSubscription>>,
          TError,
          Awaited<ReturnType<typeof fetchSubscription>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSubscription<TData = Awaited<ReturnType<typeof fetchSubscription>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscription>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof fetchSubscription>>,
          TError,
          Awaited<ReturnType<typeof fetchSubscription>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useFetchSubscription<TData = Awaited<ReturnType<typeof fetchSubscription>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscription>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Fetch a specific Subscription.
 */

export function useFetchSubscription<TData = Awaited<ReturnType<typeof fetchSubscription>>, TError = unknown>(
 sid: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof fetchSubscription>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getFetchSubscriptionQueryOptions(sid,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a Subscription.
 * @summary Update a Subscription.
 */
export type updateSubscriptionResponse200 = {
  data: EventsV1Subscription
  status: 200
}
    
export type updateSubscriptionResponseSuccess = (updateSubscriptionResponse200) & {
  headers: Headers;
};
;

export type updateSubscriptionResponse = (updateSubscriptionResponseSuccess)

export const getUpdateSubscriptionUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Subscriptions/${sid}`
}

export const updateSubscription = async (sid: string,
    updateSubscriptionBody: UpdateSubscriptionBody, options?: RequestInit): Promise<updateSubscriptionResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateSubscriptionBody.Description !== undefined) {
 formUrlEncoded.append(`Description`, updateSubscriptionBody.Description)
 }

  const res = await fetch(getUpdateSubscriptionUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateSubscriptionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateSubscriptionResponse
}




export const getUpdateSubscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubscription>>, TError,{sid: string;data: UpdateSubscriptionBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateSubscription>>, TError,{sid: string;data: UpdateSubscriptionBody}, TContext> => {

const mutationKey = ['updateSubscription'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateSubscription>>, {sid: string;data: UpdateSubscriptionBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateSubscription(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof updateSubscription>>>
    export type UpdateSubscriptionMutationBody = UpdateSubscriptionBody
    export type UpdateSubscriptionMutationError = unknown

    /**
 * @summary Update a Subscription.
 */
export const useUpdateSubscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateSubscription>>, TError,{sid: string;data: UpdateSubscriptionBody}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof updateSubscription>>,
        TError,
        {sid: string;data: UpdateSubscriptionBody},
        TContext
      > => {

      const mutationOptions = getUpdateSubscriptionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
    
/**
 * Delete a specific Subscription.
 * @summary Delete a specific Subscription.
 */
export type deleteSubscriptionResponse204 = {
  data: void
  status: 204
}
    
export type deleteSubscriptionResponseSuccess = (deleteSubscriptionResponse204) & {
  headers: Headers;
};
;

export type deleteSubscriptionResponse = (deleteSubscriptionResponseSuccess)

export const getDeleteSubscriptionUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Subscriptions/${sid}`
}

export const deleteSubscription = async (sid: string, options?: RequestInit): Promise<deleteSubscriptionResponse> => {
  
  const res = await fetch(getDeleteSubscriptionUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteSubscriptionResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteSubscriptionResponse
}




export const getDeleteSubscriptionMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubscription>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteSubscription>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteSubscription'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteSubscription>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteSubscription(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteSubscriptionMutationResult = NonNullable<Awaited<ReturnType<typeof deleteSubscription>>>
    
    export type DeleteSubscriptionMutationError = unknown

    /**
 * @summary Delete a specific Subscription.
 */
export const useDeleteSubscription = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteSubscription>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof deleteSubscription>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteSubscriptionMutationOptions(options);

      return useMutation(mutationOptions, queryClient);
    }
