/**
 * Generated by orval v7.17.2 ðŸº
 * Do not edit manually.
 * Twilio - Conversations
 * This is the public Twilio REST API.
 * OpenAPI spec version: 1.0.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  ConversationsV1Configuration,
  ConversationsV1ConfigurationAddress,
  ConversationsV1ConfigurationConfigurationWebhook,
  ConversationsV1Conversation,
  ConversationsV1ConversationConversationMessage,
  ConversationsV1ConversationConversationMessageConversationMessageReceipt,
  ConversationsV1ConversationConversationParticipant,
  ConversationsV1ConversationConversationScopedWebhook,
  ConversationsV1ConversationWithParticipants,
  ConversationsV1Credential,
  ConversationsV1Role,
  ConversationsV1Service,
  ConversationsV1ServiceServiceBinding,
  ConversationsV1ServiceServiceConfiguration,
  ConversationsV1ServiceServiceConfigurationServiceNotification,
  ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration,
  ConversationsV1ServiceServiceConversation,
  ConversationsV1ServiceServiceConversationServiceConversationMessage,
  ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt,
  ConversationsV1ServiceServiceConversationServiceConversationParticipant,
  ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook,
  ConversationsV1ServiceServiceConversationWithParticipants,
  ConversationsV1ServiceServiceRole,
  ConversationsV1ServiceServiceUser,
  ConversationsV1ServiceServiceUserServiceUserConversation,
  ConversationsV1User,
  ConversationsV1UserUserConversation,
  CreateConfigurationAddressBody,
  CreateConversationBody,
  CreateConversationMessageBody,
  CreateConversationParticipantBody,
  CreateConversationScopedWebhookBody,
  CreateConversationWithParticipantsBody,
  CreateCredentialBody,
  CreateRoleBody,
  CreateServiceBody,
  CreateServiceConversationBody,
  CreateServiceConversationMessageBody,
  CreateServiceConversationParticipantBody,
  CreateServiceConversationScopedWebhookBody,
  CreateServiceConversationWithParticipantsBody,
  CreateServiceRoleBody,
  CreateServiceUserBody,
  CreateUserBody,
  ListConfigurationAddress200,
  ListConfigurationAddressParams,
  ListConversation200,
  ListConversationMessage200,
  ListConversationMessageParams,
  ListConversationMessageReceipt200,
  ListConversationMessageReceiptParams,
  ListConversationParams,
  ListConversationParticipant200,
  ListConversationParticipantParams,
  ListConversationScopedWebhook200,
  ListConversationScopedWebhookParams,
  ListCredential200,
  ListCredentialParams,
  ListParticipantConversation200,
  ListParticipantConversationParams,
  ListRole200,
  ListRoleParams,
  ListService200,
  ListServiceBinding200,
  ListServiceBindingParams,
  ListServiceConversation200,
  ListServiceConversationMessage200,
  ListServiceConversationMessageParams,
  ListServiceConversationMessageReceipt200,
  ListServiceConversationMessageReceiptParams,
  ListServiceConversationParams,
  ListServiceConversationParticipant200,
  ListServiceConversationParticipantParams,
  ListServiceConversationScopedWebhook200,
  ListServiceConversationScopedWebhookParams,
  ListServiceParams,
  ListServiceParticipantConversation200,
  ListServiceParticipantConversationParams,
  ListServiceRole200,
  ListServiceRoleParams,
  ListServiceUser200,
  ListServiceUserConversation200,
  ListServiceUserConversationParams,
  ListServiceUserParams,
  ListUser200,
  ListUserConversation200,
  ListUserConversationParams,
  ListUserParams,
  UpdateConfigurationAddressBody,
  UpdateConfigurationBody,
  UpdateConfigurationWebhookBody,
  UpdateConversationBody,
  UpdateConversationMessageBody,
  UpdateConversationParticipantBody,
  UpdateConversationScopedWebhookBody,
  UpdateCredentialBody,
  UpdateRoleBody,
  UpdateServiceConfigurationBody,
  UpdateServiceConversationBody,
  UpdateServiceConversationMessageBody,
  UpdateServiceConversationParticipantBody,
  UpdateServiceConversationScopedWebhookBody,
  UpdateServiceNotificationBody,
  UpdateServiceRoleBody,
  UpdateServiceUserBody,
  UpdateServiceUserConversationBody,
  UpdateServiceWebhookConfigurationBody,
  UpdateUserBody,
  UpdateUserConversationBody
} from './models';

/**
 * Fetch the global configuration of conversations on your account
 * @summary Fetch the global configuration of conversations on your account
 */
export type fetchConfigurationResponse200 = {
  data: ConversationsV1Configuration
  status: 200
}
    
export type fetchConfigurationResponseSuccess = (fetchConfigurationResponse200) & {
  headers: Headers;
};
;

export type fetchConfigurationResponse = (fetchConfigurationResponseSuccess)

export const getFetchConfigurationUrl = () => {


  

  return `https://conversations.twilio.com/v1/Configuration`
}

export const fetchConfiguration = async ( options?: RequestInit): Promise<fetchConfigurationResponse> => {
  
  const res = await fetch(getFetchConfigurationUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchConfigurationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchConfigurationResponse
}





export const getFetchConfigurationQueryKey = () => {
    return [
    `https://conversations.twilio.com/v1/Configuration`
    ] as const;
    }

    
export const getFetchConfigurationQueryOptions = <TData = Awaited<ReturnType<typeof fetchConfiguration>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConfiguration>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchConfigurationQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchConfiguration>>> = ({ signal }) => fetchConfiguration({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchConfiguration>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchConfiguration>>>
export type FetchConfigurationQueryError = unknown


/**
 * @summary Fetch the global configuration of conversations on your account
 */

export function useFetchConfiguration<TData = Awaited<ReturnType<typeof fetchConfiguration>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConfiguration>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchConfigurationQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update the global configuration of conversations on your account
 * @summary Update the global configuration of conversations on your account
 */
export type updateConfigurationResponse200 = {
  data: ConversationsV1Configuration
  status: 200
}
    
export type updateConfigurationResponseSuccess = (updateConfigurationResponse200) & {
  headers: Headers;
};
;

export type updateConfigurationResponse = (updateConfigurationResponseSuccess)

export const getUpdateConfigurationUrl = () => {


  

  return `https://conversations.twilio.com/v1/Configuration`
}

export const updateConfiguration = async (updateConfigurationBody: UpdateConfigurationBody, options?: RequestInit): Promise<updateConfigurationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateConfigurationBody.DefaultChatServiceSid !== undefined) {
 formUrlEncoded.append(`DefaultChatServiceSid`, updateConfigurationBody.DefaultChatServiceSid)
 }
if(updateConfigurationBody.DefaultMessagingServiceSid !== undefined) {
 formUrlEncoded.append(`DefaultMessagingServiceSid`, updateConfigurationBody.DefaultMessagingServiceSid)
 }
if(updateConfigurationBody.DefaultInactiveTimer !== undefined) {
 formUrlEncoded.append(`DefaultInactiveTimer`, updateConfigurationBody.DefaultInactiveTimer)
 }
if(updateConfigurationBody.DefaultClosedTimer !== undefined) {
 formUrlEncoded.append(`DefaultClosedTimer`, updateConfigurationBody.DefaultClosedTimer)
 }

  const res = await fetch(getUpdateConfigurationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateConfigurationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateConfigurationResponse
}




export const getUpdateConfigurationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfiguration>>, TError,{data: UpdateConfigurationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateConfiguration>>, TError,{data: UpdateConfigurationBody}, TContext> => {

const mutationKey = ['updateConfiguration'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConfiguration>>, {data: UpdateConfigurationBody}> = (props) => {
          const {data} = props ?? {};

          return  updateConfiguration(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updateConfiguration>>>
    export type UpdateConfigurationMutationBody = UpdateConfigurationBody
    export type UpdateConfigurationMutationError = unknown

    /**
 * @summary Update the global configuration of conversations on your account
 */
export const useUpdateConfiguration = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfiguration>>, TError,{data: UpdateConfigurationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateConfiguration>>,
        TError,
        {data: UpdateConfigurationBody},
        TContext
      > => {

      const mutationOptions = getUpdateConfigurationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of address configurations for an account
 * @summary Retrieve a list of address configurations for an account
 */
export type listConfigurationAddressResponse200 = {
  data: ListConfigurationAddress200
  status: 200
}
    
export type listConfigurationAddressResponseSuccess = (listConfigurationAddressResponse200) & {
  headers: Headers;
};
;

export type listConfigurationAddressResponse = (listConfigurationAddressResponseSuccess)

export const getListConfigurationAddressUrl = (params?: ListConfigurationAddressParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Configuration/Addresses?${stringifiedParams}` : `https://conversations.twilio.com/v1/Configuration/Addresses`
}

export const listConfigurationAddress = async (params?: ListConfigurationAddressParams, options?: RequestInit): Promise<listConfigurationAddressResponse> => {
  
  const res = await fetch(getListConfigurationAddressUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listConfigurationAddressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listConfigurationAddressResponse
}





export const getListConfigurationAddressQueryKey = (params?: ListConfigurationAddressParams,) => {
    return [
    `https://conversations.twilio.com/v1/Configuration/Addresses`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListConfigurationAddressQueryOptions = <TData = Awaited<ReturnType<typeof listConfigurationAddress>>, TError = unknown>(params?: ListConfigurationAddressParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConfigurationAddress>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListConfigurationAddressQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listConfigurationAddress>>> = ({ signal }) => listConfigurationAddress(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listConfigurationAddress>>, TError, TData> & { queryKey: QueryKey }
}

export type ListConfigurationAddressQueryResult = NonNullable<Awaited<ReturnType<typeof listConfigurationAddress>>>
export type ListConfigurationAddressQueryError = unknown


/**
 * @summary Retrieve a list of address configurations for an account
 */

export function useListConfigurationAddress<TData = Awaited<ReturnType<typeof listConfigurationAddress>>, TError = unknown>(
 params?: ListConfigurationAddressParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConfigurationAddress>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListConfigurationAddressQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new address configuration
 * @summary Create a new address configuration
 */
export type createConfigurationAddressResponse201 = {
  data: ConversationsV1ConfigurationAddress
  status: 201
}
    
export type createConfigurationAddressResponseSuccess = (createConfigurationAddressResponse201) & {
  headers: Headers;
};
;

export type createConfigurationAddressResponse = (createConfigurationAddressResponseSuccess)

export const getCreateConfigurationAddressUrl = () => {


  

  return `https://conversations.twilio.com/v1/Configuration/Addresses`
}

export const createConfigurationAddress = async (createConfigurationAddressBody: CreateConfigurationAddressBody, options?: RequestInit): Promise<createConfigurationAddressResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Type`, createConfigurationAddressBody.Type)
formUrlEncoded.append(`Address`, createConfigurationAddressBody.Address)
if(createConfigurationAddressBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, createConfigurationAddressBody.FriendlyName)
 }
if(createConfigurationAddressBody['AutoCreation.Enabled'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.Enabled`, createConfigurationAddressBody['AutoCreation.Enabled'].toString())
 }
if(createConfigurationAddressBody['AutoCreation.Type'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.Type`, createConfigurationAddressBody['AutoCreation.Type'])
 }
if(createConfigurationAddressBody['AutoCreation.ConversationServiceSid'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.ConversationServiceSid`, createConfigurationAddressBody['AutoCreation.ConversationServiceSid'])
 }
if(createConfigurationAddressBody['AutoCreation.WebhookUrl'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.WebhookUrl`, createConfigurationAddressBody['AutoCreation.WebhookUrl'])
 }
if(createConfigurationAddressBody['AutoCreation.WebhookMethod'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.WebhookMethod`, createConfigurationAddressBody['AutoCreation.WebhookMethod'])
 }
if(createConfigurationAddressBody['AutoCreation.WebhookFilters'] !== undefined) {
 createConfigurationAddressBody['AutoCreation.WebhookFilters'].forEach(value => formUrlEncoded.append(`AutoCreation.WebhookFilters`, value));
 }
if(createConfigurationAddressBody['AutoCreation.StudioFlowSid'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.StudioFlowSid`, createConfigurationAddressBody['AutoCreation.StudioFlowSid'])
 }
if(createConfigurationAddressBody['AutoCreation.StudioRetryCount'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.StudioRetryCount`, createConfigurationAddressBody['AutoCreation.StudioRetryCount'].toString())
 }
if(createConfigurationAddressBody.AddressCountry !== undefined) {
 formUrlEncoded.append(`AddressCountry`, createConfigurationAddressBody.AddressCountry)
 }

  const res = await fetch(getCreateConfigurationAddressUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createConfigurationAddressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createConfigurationAddressResponse
}




export const getCreateConfigurationAddressMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConfigurationAddress>>, TError,{data: CreateConfigurationAddressBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createConfigurationAddress>>, TError,{data: CreateConfigurationAddressBody}, TContext> => {

const mutationKey = ['createConfigurationAddress'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createConfigurationAddress>>, {data: CreateConfigurationAddressBody}> = (props) => {
          const {data} = props ?? {};

          return  createConfigurationAddress(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateConfigurationAddressMutationResult = NonNullable<Awaited<ReturnType<typeof createConfigurationAddress>>>
    export type CreateConfigurationAddressMutationBody = CreateConfigurationAddressBody
    export type CreateConfigurationAddressMutationError = unknown

    /**
 * @summary Create a new address configuration
 */
export const useCreateConfigurationAddress = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConfigurationAddress>>, TError,{data: CreateConfigurationAddressBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createConfigurationAddress>>,
        TError,
        {data: CreateConfigurationAddressBody},
        TContext
      > => {

      const mutationOptions = getCreateConfigurationAddressMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch an address configuration 
 * @summary Fetch an address configuration 
 */
export type fetchConfigurationAddressResponse200 = {
  data: ConversationsV1ConfigurationAddress
  status: 200
}
    
export type fetchConfigurationAddressResponseSuccess = (fetchConfigurationAddressResponse200) & {
  headers: Headers;
};
;

export type fetchConfigurationAddressResponse = (fetchConfigurationAddressResponseSuccess)

export const getFetchConfigurationAddressUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Configuration/Addresses/${sid}`
}

export const fetchConfigurationAddress = async (sid: string, options?: RequestInit): Promise<fetchConfigurationAddressResponse> => {
  
  const res = await fetch(getFetchConfigurationAddressUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchConfigurationAddressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchConfigurationAddressResponse
}





export const getFetchConfigurationAddressQueryKey = (sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Configuration/Addresses/${sid}`
    ] as const;
    }

    
export const getFetchConfigurationAddressQueryOptions = <TData = Awaited<ReturnType<typeof fetchConfigurationAddress>>, TError = unknown>(sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConfigurationAddress>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchConfigurationAddressQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchConfigurationAddress>>> = ({ signal }) => fetchConfigurationAddress(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchConfigurationAddress>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchConfigurationAddressQueryResult = NonNullable<Awaited<ReturnType<typeof fetchConfigurationAddress>>>
export type FetchConfigurationAddressQueryError = unknown


/**
 * @summary Fetch an address configuration 
 */

export function useFetchConfigurationAddress<TData = Awaited<ReturnType<typeof fetchConfigurationAddress>>, TError = unknown>(
 sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConfigurationAddress>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchConfigurationAddressQueryOptions(sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing address configuration
 * @summary Update an existing address configuration
 */
export type updateConfigurationAddressResponse200 = {
  data: ConversationsV1ConfigurationAddress
  status: 200
}
    
export type updateConfigurationAddressResponseSuccess = (updateConfigurationAddressResponse200) & {
  headers: Headers;
};
;

export type updateConfigurationAddressResponse = (updateConfigurationAddressResponseSuccess)

export const getUpdateConfigurationAddressUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Configuration/Addresses/${sid}`
}

export const updateConfigurationAddress = async (sid: string,
    updateConfigurationAddressBody: UpdateConfigurationAddressBody, options?: RequestInit): Promise<updateConfigurationAddressResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateConfigurationAddressBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, updateConfigurationAddressBody.FriendlyName)
 }
if(updateConfigurationAddressBody['AutoCreation.Enabled'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.Enabled`, updateConfigurationAddressBody['AutoCreation.Enabled'].toString())
 }
if(updateConfigurationAddressBody['AutoCreation.Type'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.Type`, updateConfigurationAddressBody['AutoCreation.Type'])
 }
if(updateConfigurationAddressBody['AutoCreation.ConversationServiceSid'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.ConversationServiceSid`, updateConfigurationAddressBody['AutoCreation.ConversationServiceSid'])
 }
if(updateConfigurationAddressBody['AutoCreation.WebhookUrl'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.WebhookUrl`, updateConfigurationAddressBody['AutoCreation.WebhookUrl'])
 }
if(updateConfigurationAddressBody['AutoCreation.WebhookMethod'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.WebhookMethod`, updateConfigurationAddressBody['AutoCreation.WebhookMethod'])
 }
if(updateConfigurationAddressBody['AutoCreation.WebhookFilters'] !== undefined) {
 updateConfigurationAddressBody['AutoCreation.WebhookFilters'].forEach(value => formUrlEncoded.append(`AutoCreation.WebhookFilters`, value));
 }
if(updateConfigurationAddressBody['AutoCreation.StudioFlowSid'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.StudioFlowSid`, updateConfigurationAddressBody['AutoCreation.StudioFlowSid'])
 }
if(updateConfigurationAddressBody['AutoCreation.StudioRetryCount'] !== undefined) {
 formUrlEncoded.append(`AutoCreation.StudioRetryCount`, updateConfigurationAddressBody['AutoCreation.StudioRetryCount'].toString())
 }

  const res = await fetch(getUpdateConfigurationAddressUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateConfigurationAddressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateConfigurationAddressResponse
}




export const getUpdateConfigurationAddressMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfigurationAddress>>, TError,{sid: string;data: UpdateConfigurationAddressBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateConfigurationAddress>>, TError,{sid: string;data: UpdateConfigurationAddressBody}, TContext> => {

const mutationKey = ['updateConfigurationAddress'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConfigurationAddress>>, {sid: string;data: UpdateConfigurationAddressBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateConfigurationAddress(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConfigurationAddressMutationResult = NonNullable<Awaited<ReturnType<typeof updateConfigurationAddress>>>
    export type UpdateConfigurationAddressMutationBody = UpdateConfigurationAddressBody
    export type UpdateConfigurationAddressMutationError = unknown

    /**
 * @summary Update an existing address configuration
 */
export const useUpdateConfigurationAddress = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfigurationAddress>>, TError,{sid: string;data: UpdateConfigurationAddressBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateConfigurationAddress>>,
        TError,
        {sid: string;data: UpdateConfigurationAddressBody},
        TContext
      > => {

      const mutationOptions = getUpdateConfigurationAddressMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove an existing address configuration
 * @summary Remove an existing address configuration
 */
export type deleteConfigurationAddressResponse204 = {
  data: void
  status: 204
}
    
export type deleteConfigurationAddressResponseSuccess = (deleteConfigurationAddressResponse204) & {
  headers: Headers;
};
;

export type deleteConfigurationAddressResponse = (deleteConfigurationAddressResponseSuccess)

export const getDeleteConfigurationAddressUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Configuration/Addresses/${sid}`
}

export const deleteConfigurationAddress = async (sid: string, options?: RequestInit): Promise<deleteConfigurationAddressResponse> => {
  
  const res = await fetch(getDeleteConfigurationAddressUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteConfigurationAddressResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteConfigurationAddressResponse
}




export const getDeleteConfigurationAddressMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConfigurationAddress>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConfigurationAddress>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteConfigurationAddress'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConfigurationAddress>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteConfigurationAddress(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConfigurationAddressMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConfigurationAddress>>>
    
    export type DeleteConfigurationAddressMutationError = unknown

    /**
 * @summary Remove an existing address configuration
 */
export const useDeleteConfigurationAddress = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConfigurationAddress>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteConfigurationAddress>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteConfigurationAddressMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
export type fetchConfigurationWebhookResponse200 = {
  data: ConversationsV1ConfigurationConfigurationWebhook
  status: 200
}
    
export type fetchConfigurationWebhookResponseSuccess = (fetchConfigurationWebhookResponse200) & {
  headers: Headers;
};
;

export type fetchConfigurationWebhookResponse = (fetchConfigurationWebhookResponseSuccess)

export const getFetchConfigurationWebhookUrl = () => {


  

  return `https://conversations.twilio.com/v1/Configuration/Webhooks`
}

export const fetchConfigurationWebhook = async ( options?: RequestInit): Promise<fetchConfigurationWebhookResponse> => {
  
  const res = await fetch(getFetchConfigurationWebhookUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchConfigurationWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchConfigurationWebhookResponse
}





export const getFetchConfigurationWebhookQueryKey = () => {
    return [
    `https://conversations.twilio.com/v1/Configuration/Webhooks`
    ] as const;
    }

    
export const getFetchConfigurationWebhookQueryOptions = <TData = Awaited<ReturnType<typeof fetchConfigurationWebhook>>, TError = unknown>( options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConfigurationWebhook>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchConfigurationWebhookQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchConfigurationWebhook>>> = ({ signal }) => fetchConfigurationWebhook({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchConfigurationWebhook>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchConfigurationWebhookQueryResult = NonNullable<Awaited<ReturnType<typeof fetchConfigurationWebhook>>>
export type FetchConfigurationWebhookQueryError = unknown



export function useFetchConfigurationWebhook<TData = Awaited<ReturnType<typeof fetchConfigurationWebhook>>, TError = unknown>(
  options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConfigurationWebhook>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchConfigurationWebhookQueryOptions(options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





export type updateConfigurationWebhookResponse200 = {
  data: ConversationsV1ConfigurationConfigurationWebhook
  status: 200
}
    
export type updateConfigurationWebhookResponseSuccess = (updateConfigurationWebhookResponse200) & {
  headers: Headers;
};
;

export type updateConfigurationWebhookResponse = (updateConfigurationWebhookResponseSuccess)

export const getUpdateConfigurationWebhookUrl = () => {


  

  return `https://conversations.twilio.com/v1/Configuration/Webhooks`
}

export const updateConfigurationWebhook = async (updateConfigurationWebhookBody: UpdateConfigurationWebhookBody, options?: RequestInit): Promise<updateConfigurationWebhookResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateConfigurationWebhookBody.Method !== undefined) {
 formUrlEncoded.append(`Method`, updateConfigurationWebhookBody.Method)
 }
if(updateConfigurationWebhookBody.Filters !== undefined) {
 updateConfigurationWebhookBody.Filters.forEach(value => formUrlEncoded.append(`Filters`, value));
 }
if(updateConfigurationWebhookBody.PreWebhookUrl !== undefined) {
 formUrlEncoded.append(`PreWebhookUrl`, updateConfigurationWebhookBody.PreWebhookUrl)
 }
if(updateConfigurationWebhookBody.PostWebhookUrl !== undefined) {
 formUrlEncoded.append(`PostWebhookUrl`, updateConfigurationWebhookBody.PostWebhookUrl)
 }
if(updateConfigurationWebhookBody.Target !== undefined) {
 formUrlEncoded.append(`Target`, updateConfigurationWebhookBody.Target)
 }

  const res = await fetch(getUpdateConfigurationWebhookUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateConfigurationWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateConfigurationWebhookResponse
}




export const getUpdateConfigurationWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfigurationWebhook>>, TError,{data: UpdateConfigurationWebhookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateConfigurationWebhook>>, TError,{data: UpdateConfigurationWebhookBody}, TContext> => {

const mutationKey = ['updateConfigurationWebhook'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConfigurationWebhook>>, {data: UpdateConfigurationWebhookBody}> = (props) => {
          const {data} = props ?? {};

          return  updateConfigurationWebhook(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConfigurationWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof updateConfigurationWebhook>>>
    export type UpdateConfigurationWebhookMutationBody = UpdateConfigurationWebhookBody
    export type UpdateConfigurationWebhookMutationError = unknown

    export const useUpdateConfigurationWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConfigurationWebhook>>, TError,{data: UpdateConfigurationWebhookBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateConfigurationWebhook>>,
        TError,
        {data: UpdateConfigurationWebhookBody},
        TContext
      > => {

      const mutationOptions = getUpdateConfigurationWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a new conversation in your account's default service
 * @summary Create a new conversation in your account's default service
 */
export type createConversationResponse201 = {
  data: ConversationsV1Conversation
  status: 201
}
    
export type createConversationResponseSuccess = (createConversationResponse201) & {
  headers: Headers;
};
;

export type createConversationResponse = (createConversationResponseSuccess)

export const getCreateConversationUrl = () => {


  

  return `https://conversations.twilio.com/v1/Conversations`
}

export const createConversation = async (createConversationBody: CreateConversationBody, options?: RequestInit): Promise<createConversationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(createConversationBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, createConversationBody.FriendlyName)
 }
if(createConversationBody.UniqueName !== undefined) {
 formUrlEncoded.append(`UniqueName`, createConversationBody.UniqueName)
 }
if(createConversationBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, createConversationBody.DateCreated)
 }
if(createConversationBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, createConversationBody.DateUpdated)
 }
if(createConversationBody.MessagingServiceSid !== undefined) {
 formUrlEncoded.append(`MessagingServiceSid`, createConversationBody.MessagingServiceSid)
 }
if(createConversationBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createConversationBody.Attributes)
 }
if(createConversationBody.State !== undefined) {
 formUrlEncoded.append(`State`, createConversationBody.State)
 }
if(createConversationBody['Timers.Inactive'] !== undefined) {
 formUrlEncoded.append(`Timers.Inactive`, createConversationBody['Timers.Inactive'])
 }
if(createConversationBody['Timers.Closed'] !== undefined) {
 formUrlEncoded.append(`Timers.Closed`, createConversationBody['Timers.Closed'])
 }
if(createConversationBody['Bindings.Email.Address'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Address`, createConversationBody['Bindings.Email.Address'])
 }
if(createConversationBody['Bindings.Email.Name'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Name`, createConversationBody['Bindings.Email.Name'])
 }

  const res = await fetch(getCreateConversationUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createConversationResponse
}




export const getCreateConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversation>>, TError,{data: CreateConversationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createConversation>>, TError,{data: CreateConversationBody}, TContext> => {

const mutationKey = ['createConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createConversation>>, {data: CreateConversationBody}> = (props) => {
          const {data} = props ?? {};

          return  createConversation(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateConversationMutationResult = NonNullable<Awaited<ReturnType<typeof createConversation>>>
    export type CreateConversationMutationBody = CreateConversationBody
    export type CreateConversationMutationError = unknown

    /**
 * @summary Create a new conversation in your account's default service
 */
export const useCreateConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversation>>, TError,{data: CreateConversationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createConversation>>,
        TError,
        {data: CreateConversationBody},
        TContext
      > => {

      const mutationOptions = getCreateConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of conversations in your account's default service
 * @summary Retrieve a list of conversations in your account's default service
 */
export type listConversationResponse200 = {
  data: ListConversation200
  status: 200
}
    
export type listConversationResponseSuccess = (listConversationResponse200) & {
  headers: Headers;
};
;

export type listConversationResponse = (listConversationResponseSuccess)

export const getListConversationUrl = (params?: ListConversationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Conversations?${stringifiedParams}` : `https://conversations.twilio.com/v1/Conversations`
}

export const listConversation = async (params?: ListConversationParams, options?: RequestInit): Promise<listConversationResponse> => {
  
  const res = await fetch(getListConversationUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listConversationResponse
}





export const getListConversationQueryKey = (params?: ListConversationParams,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListConversationQueryOptions = <TData = Awaited<ReturnType<typeof listConversation>>, TError = unknown>(params?: ListConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListConversationQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listConversation>>> = ({ signal }) => listConversation(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type ListConversationQueryResult = NonNullable<Awaited<ReturnType<typeof listConversation>>>
export type ListConversationQueryError = unknown


/**
 * @summary Retrieve a list of conversations in your account's default service
 */

export function useListConversation<TData = Awaited<ReturnType<typeof listConversation>>, TError = unknown>(
 params?: ListConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListConversationQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing conversation in your account's default service
 * @summary Update an existing conversation in your account's default service
 */
export type updateConversationResponse200 = {
  data: ConversationsV1Conversation
  status: 200
}
    
export type updateConversationResponseSuccess = (updateConversationResponse200) & {
  headers: Headers;
};
;

export type updateConversationResponse = (updateConversationResponseSuccess)

export const getUpdateConversationUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${sid}`
}

export const updateConversation = async (sid: string,
    updateConversationBody: UpdateConversationBody, options?: RequestInit): Promise<updateConversationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateConversationBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, updateConversationBody.FriendlyName)
 }
if(updateConversationBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, updateConversationBody.DateCreated)
 }
if(updateConversationBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, updateConversationBody.DateUpdated)
 }
if(updateConversationBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, updateConversationBody.Attributes)
 }
if(updateConversationBody.MessagingServiceSid !== undefined) {
 formUrlEncoded.append(`MessagingServiceSid`, updateConversationBody.MessagingServiceSid)
 }
if(updateConversationBody.State !== undefined) {
 formUrlEncoded.append(`State`, updateConversationBody.State)
 }
if(updateConversationBody['Timers.Inactive'] !== undefined) {
 formUrlEncoded.append(`Timers.Inactive`, updateConversationBody['Timers.Inactive'])
 }
if(updateConversationBody['Timers.Closed'] !== undefined) {
 formUrlEncoded.append(`Timers.Closed`, updateConversationBody['Timers.Closed'])
 }
if(updateConversationBody.UniqueName !== undefined) {
 formUrlEncoded.append(`UniqueName`, updateConversationBody.UniqueName)
 }
if(updateConversationBody['Bindings.Email.Address'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Address`, updateConversationBody['Bindings.Email.Address'])
 }
if(updateConversationBody['Bindings.Email.Name'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Name`, updateConversationBody['Bindings.Email.Name'])
 }

  const res = await fetch(getUpdateConversationUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateConversationResponse
}




export const getUpdateConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversation>>, TError,{sid: string;data: UpdateConversationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateConversation>>, TError,{sid: string;data: UpdateConversationBody}, TContext> => {

const mutationKey = ['updateConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConversation>>, {sid: string;data: UpdateConversationBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateConversation(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConversationMutationResult = NonNullable<Awaited<ReturnType<typeof updateConversation>>>
    export type UpdateConversationMutationBody = UpdateConversationBody
    export type UpdateConversationMutationError = unknown

    /**
 * @summary Update an existing conversation in your account's default service
 */
export const useUpdateConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversation>>, TError,{sid: string;data: UpdateConversationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateConversation>>,
        TError,
        {sid: string;data: UpdateConversationBody},
        TContext
      > => {

      const mutationOptions = getUpdateConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a conversation from your account's default service
 * @summary Remove a conversation from your account's default service
 */
export type deleteConversationResponse204 = {
  data: void
  status: 204
}
    
export type deleteConversationResponseSuccess = (deleteConversationResponse204) & {
  headers: Headers;
};
;

export type deleteConversationResponse = (deleteConversationResponseSuccess)

export const getDeleteConversationUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${sid}`
}

export const deleteConversation = async (sid: string, options?: RequestInit): Promise<deleteConversationResponse> => {
  
  const res = await fetch(getDeleteConversationUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteConversationResponse
}




export const getDeleteConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversation>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConversation>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConversation>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteConversation(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConversationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConversation>>>
    
    export type DeleteConversationMutationError = unknown

    /**
 * @summary Remove a conversation from your account's default service
 */
export const useDeleteConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversation>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteConversation>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a conversation from your account's default service
 * @summary Fetch a conversation from your account's default service
 */
export type fetchConversationResponse200 = {
  data: ConversationsV1Conversation
  status: 200
}
    
export type fetchConversationResponseSuccess = (fetchConversationResponse200) & {
  headers: Headers;
};
;

export type fetchConversationResponse = (fetchConversationResponseSuccess)

export const getFetchConversationUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${sid}`
}

export const fetchConversation = async (sid: string, options?: RequestInit): Promise<fetchConversationResponse> => {
  
  const res = await fetch(getFetchConversationUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchConversationResponse
}





export const getFetchConversationQueryKey = (sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${sid}`
    ] as const;
    }

    
export const getFetchConversationQueryOptions = <TData = Awaited<ReturnType<typeof fetchConversation>>, TError = unknown>(sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchConversationQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchConversation>>> = ({ signal }) => fetchConversation(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchConversationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchConversation>>>
export type FetchConversationQueryError = unknown


/**
 * @summary Fetch a conversation from your account's default service
 */

export function useFetchConversation<TData = Awaited<ReturnType<typeof fetchConversation>>, TError = unknown>(
 sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchConversationQueryOptions(sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add a new message to the conversation
 * @summary Add a new message to the conversation
 */
export type createConversationMessageResponse201 = {
  data: ConversationsV1ConversationConversationMessage
  status: 201
}
    
export type createConversationMessageResponseSuccess = (createConversationMessageResponse201) & {
  headers: Headers;
};
;

export type createConversationMessageResponse = (createConversationMessageResponseSuccess)

export const getCreateConversationMessageUrl = (conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages`
}

export const createConversationMessage = async (conversationSid: string,
    createConversationMessageBody: CreateConversationMessageBody, options?: RequestInit): Promise<createConversationMessageResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(createConversationMessageBody.Author !== undefined) {
 formUrlEncoded.append(`Author`, createConversationMessageBody.Author)
 }
if(createConversationMessageBody.Body !== undefined) {
 formUrlEncoded.append(`Body`, createConversationMessageBody.Body)
 }
if(createConversationMessageBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, createConversationMessageBody.DateCreated)
 }
if(createConversationMessageBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, createConversationMessageBody.DateUpdated)
 }
if(createConversationMessageBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createConversationMessageBody.Attributes)
 }
if(createConversationMessageBody.MediaSid !== undefined) {
 formUrlEncoded.append(`MediaSid`, createConversationMessageBody.MediaSid)
 }
if(createConversationMessageBody.ContentSid !== undefined) {
 formUrlEncoded.append(`ContentSid`, createConversationMessageBody.ContentSid)
 }
if(createConversationMessageBody.ContentVariables !== undefined) {
 formUrlEncoded.append(`ContentVariables`, createConversationMessageBody.ContentVariables)
 }
if(createConversationMessageBody.Subject !== undefined) {
 formUrlEncoded.append(`Subject`, createConversationMessageBody.Subject)
 }

  const res = await fetch(getCreateConversationMessageUrl(conversationSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createConversationMessageResponse
}




export const getCreateConversationMessageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationMessage>>, TError,{conversationSid: string;data: CreateConversationMessageBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createConversationMessage>>, TError,{conversationSid: string;data: CreateConversationMessageBody}, TContext> => {

const mutationKey = ['createConversationMessage'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createConversationMessage>>, {conversationSid: string;data: CreateConversationMessageBody}> = (props) => {
          const {conversationSid,data} = props ?? {};

          return  createConversationMessage(conversationSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateConversationMessageMutationResult = NonNullable<Awaited<ReturnType<typeof createConversationMessage>>>
    export type CreateConversationMessageMutationBody = CreateConversationMessageBody
    export type CreateConversationMessageMutationError = unknown

    /**
 * @summary Add a new message to the conversation
 */
export const useCreateConversationMessage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationMessage>>, TError,{conversationSid: string;data: CreateConversationMessageBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createConversationMessage>>,
        TError,
        {conversationSid: string;data: CreateConversationMessageBody},
        TContext
      > => {

      const mutationOptions = getCreateConversationMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all messages in the conversation
 * @summary Retrieve a list of all messages in the conversation
 */
export type listConversationMessageResponse200 = {
  data: ListConversationMessage200
  status: 200
}
    
export type listConversationMessageResponseSuccess = (listConversationMessageResponse200) & {
  headers: Headers;
};
;

export type listConversationMessageResponse = (listConversationMessageResponseSuccess)

export const getListConversationMessageUrl = (conversationSid: string,
    params?: ListConversationMessageParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages?${stringifiedParams}` : `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages`
}

export const listConversationMessage = async (conversationSid: string,
    params?: ListConversationMessageParams, options?: RequestInit): Promise<listConversationMessageResponse> => {
  
  const res = await fetch(getListConversationMessageUrl(conversationSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listConversationMessageResponse
}





export const getListConversationMessageQueryKey = (conversationSid?: string,
    params?: ListConversationMessageParams,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListConversationMessageQueryOptions = <TData = Awaited<ReturnType<typeof listConversationMessage>>, TError = unknown>(conversationSid: string,
    params?: ListConversationMessageParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversationMessage>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListConversationMessageQueryKey(conversationSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listConversationMessage>>> = ({ signal }) => listConversationMessage(conversationSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listConversationMessage>>, TError, TData> & { queryKey: QueryKey }
}

export type ListConversationMessageQueryResult = NonNullable<Awaited<ReturnType<typeof listConversationMessage>>>
export type ListConversationMessageQueryError = unknown


/**
 * @summary Retrieve a list of all messages in the conversation
 */

export function useListConversationMessage<TData = Awaited<ReturnType<typeof listConversationMessage>>, TError = unknown>(
 conversationSid: string,
    params?: ListConversationMessageParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversationMessage>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListConversationMessageQueryOptions(conversationSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing message in the conversation
 * @summary Update an existing message in the conversation
 */
export type updateConversationMessageResponse200 = {
  data: ConversationsV1ConversationConversationMessage
  status: 200
}
    
export type updateConversationMessageResponseSuccess = (updateConversationMessageResponse200) & {
  headers: Headers;
};
;

export type updateConversationMessageResponse = (updateConversationMessageResponseSuccess)

export const getUpdateConversationMessageUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${sid}`
}

export const updateConversationMessage = async (conversationSid: string,
    sid: string,
    updateConversationMessageBody: UpdateConversationMessageBody, options?: RequestInit): Promise<updateConversationMessageResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateConversationMessageBody.Author !== undefined) {
 formUrlEncoded.append(`Author`, updateConversationMessageBody.Author)
 }
if(updateConversationMessageBody.Body !== undefined) {
 formUrlEncoded.append(`Body`, updateConversationMessageBody.Body)
 }
if(updateConversationMessageBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, updateConversationMessageBody.DateCreated)
 }
if(updateConversationMessageBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, updateConversationMessageBody.DateUpdated)
 }
if(updateConversationMessageBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, updateConversationMessageBody.Attributes)
 }
if(updateConversationMessageBody.Subject !== undefined) {
 formUrlEncoded.append(`Subject`, updateConversationMessageBody.Subject)
 }

  const res = await fetch(getUpdateConversationMessageUrl(conversationSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateConversationMessageResponse
}




export const getUpdateConversationMessageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversationMessage>>, TError,{conversationSid: string;sid: string;data: UpdateConversationMessageBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateConversationMessage>>, TError,{conversationSid: string;sid: string;data: UpdateConversationMessageBody}, TContext> => {

const mutationKey = ['updateConversationMessage'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConversationMessage>>, {conversationSid: string;sid: string;data: UpdateConversationMessageBody}> = (props) => {
          const {conversationSid,sid,data} = props ?? {};

          return  updateConversationMessage(conversationSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConversationMessageMutationResult = NonNullable<Awaited<ReturnType<typeof updateConversationMessage>>>
    export type UpdateConversationMessageMutationBody = UpdateConversationMessageBody
    export type UpdateConversationMessageMutationError = unknown

    /**
 * @summary Update an existing message in the conversation
 */
export const useUpdateConversationMessage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversationMessage>>, TError,{conversationSid: string;sid: string;data: UpdateConversationMessageBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateConversationMessage>>,
        TError,
        {conversationSid: string;sid: string;data: UpdateConversationMessageBody},
        TContext
      > => {

      const mutationOptions = getUpdateConversationMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a message from the conversation
 * @summary Remove a message from the conversation
 */
export type deleteConversationMessageResponse204 = {
  data: void
  status: 204
}
    
export type deleteConversationMessageResponseSuccess = (deleteConversationMessageResponse204) & {
  headers: Headers;
};
;

export type deleteConversationMessageResponse = (deleteConversationMessageResponseSuccess)

export const getDeleteConversationMessageUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${sid}`
}

export const deleteConversationMessage = async (conversationSid: string,
    sid: string, options?: RequestInit): Promise<deleteConversationMessageResponse> => {
  
  const res = await fetch(getDeleteConversationMessageUrl(conversationSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteConversationMessageResponse
}




export const getDeleteConversationMessageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversationMessage>>, TError,{conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConversationMessage>>, TError,{conversationSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteConversationMessage'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConversationMessage>>, {conversationSid: string;sid: string}> = (props) => {
          const {conversationSid,sid} = props ?? {};

          return  deleteConversationMessage(conversationSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConversationMessageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConversationMessage>>>
    
    export type DeleteConversationMessageMutationError = unknown

    /**
 * @summary Remove a message from the conversation
 */
export const useDeleteConversationMessage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversationMessage>>, TError,{conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteConversationMessage>>,
        TError,
        {conversationSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteConversationMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a message from the conversation
 * @summary Fetch a message from the conversation
 */
export type fetchConversationMessageResponse200 = {
  data: ConversationsV1ConversationConversationMessage
  status: 200
}
    
export type fetchConversationMessageResponseSuccess = (fetchConversationMessageResponse200) & {
  headers: Headers;
};
;

export type fetchConversationMessageResponse = (fetchConversationMessageResponseSuccess)

export const getFetchConversationMessageUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${sid}`
}

export const fetchConversationMessage = async (conversationSid: string,
    sid: string, options?: RequestInit): Promise<fetchConversationMessageResponse> => {
  
  const res = await fetch(getFetchConversationMessageUrl(conversationSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchConversationMessageResponse
}





export const getFetchConversationMessageQueryKey = (conversationSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${sid}`
    ] as const;
    }

    
export const getFetchConversationMessageQueryOptions = <TData = Awaited<ReturnType<typeof fetchConversationMessage>>, TError = unknown>(conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversationMessage>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchConversationMessageQueryKey(conversationSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchConversationMessage>>> = ({ signal }) => fetchConversationMessage(conversationSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchConversationMessage>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchConversationMessageQueryResult = NonNullable<Awaited<ReturnType<typeof fetchConversationMessage>>>
export type FetchConversationMessageQueryError = unknown


/**
 * @summary Fetch a message from the conversation
 */

export function useFetchConversationMessage<TData = Awaited<ReturnType<typeof fetchConversationMessage>>, TError = unknown>(
 conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversationMessage>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchConversationMessageQueryOptions(conversationSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Fetch the delivery and read receipts of the conversation message
 * @summary Fetch the delivery and read receipts of the conversation message
 */
export type fetchConversationMessageReceiptResponse200 = {
  data: ConversationsV1ConversationConversationMessageConversationMessageReceipt
  status: 200
}
    
export type fetchConversationMessageReceiptResponseSuccess = (fetchConversationMessageReceiptResponse200) & {
  headers: Headers;
};
;

export type fetchConversationMessageReceiptResponse = (fetchConversationMessageReceiptResponseSuccess)

export const getFetchConversationMessageReceiptUrl = (conversationSid: string,
    messageSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${messageSid}/Receipts/${sid}`
}

export const fetchConversationMessageReceipt = async (conversationSid: string,
    messageSid: string,
    sid: string, options?: RequestInit): Promise<fetchConversationMessageReceiptResponse> => {
  
  const res = await fetch(getFetchConversationMessageReceiptUrl(conversationSid,messageSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchConversationMessageReceiptResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchConversationMessageReceiptResponse
}





export const getFetchConversationMessageReceiptQueryKey = (conversationSid?: string,
    messageSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${messageSid}/Receipts/${sid}`
    ] as const;
    }

    
export const getFetchConversationMessageReceiptQueryOptions = <TData = Awaited<ReturnType<typeof fetchConversationMessageReceipt>>, TError = unknown>(conversationSid: string,
    messageSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversationMessageReceipt>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchConversationMessageReceiptQueryKey(conversationSid,messageSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchConversationMessageReceipt>>> = ({ signal }) => fetchConversationMessageReceipt(conversationSid,messageSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationSid && messageSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchConversationMessageReceipt>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchConversationMessageReceiptQueryResult = NonNullable<Awaited<ReturnType<typeof fetchConversationMessageReceipt>>>
export type FetchConversationMessageReceiptQueryError = unknown


/**
 * @summary Fetch the delivery and read receipts of the conversation message
 */

export function useFetchConversationMessageReceipt<TData = Awaited<ReturnType<typeof fetchConversationMessageReceipt>>, TError = unknown>(
 conversationSid: string,
    messageSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversationMessageReceipt>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchConversationMessageReceiptQueryOptions(conversationSid,messageSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all delivery and read receipts of the conversation message
 * @summary Retrieve a list of all delivery and read receipts of the conversation message
 */
export type listConversationMessageReceiptResponse200 = {
  data: ListConversationMessageReceipt200
  status: 200
}
    
export type listConversationMessageReceiptResponseSuccess = (listConversationMessageReceiptResponse200) & {
  headers: Headers;
};
;

export type listConversationMessageReceiptResponse = (listConversationMessageReceiptResponseSuccess)

export const getListConversationMessageReceiptUrl = (conversationSid: string,
    messageSid: string,
    params?: ListConversationMessageReceiptParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${messageSid}/Receipts?${stringifiedParams}` : `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${messageSid}/Receipts`
}

export const listConversationMessageReceipt = async (conversationSid: string,
    messageSid: string,
    params?: ListConversationMessageReceiptParams, options?: RequestInit): Promise<listConversationMessageReceiptResponse> => {
  
  const res = await fetch(getListConversationMessageReceiptUrl(conversationSid,messageSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listConversationMessageReceiptResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listConversationMessageReceiptResponse
}





export const getListConversationMessageReceiptQueryKey = (conversationSid?: string,
    messageSid?: string,
    params?: ListConversationMessageReceiptParams,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Messages/${messageSid}/Receipts`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListConversationMessageReceiptQueryOptions = <TData = Awaited<ReturnType<typeof listConversationMessageReceipt>>, TError = unknown>(conversationSid: string,
    messageSid: string,
    params?: ListConversationMessageReceiptParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversationMessageReceipt>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListConversationMessageReceiptQueryKey(conversationSid,messageSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listConversationMessageReceipt>>> = ({ signal }) => listConversationMessageReceipt(conversationSid,messageSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationSid && messageSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listConversationMessageReceipt>>, TError, TData> & { queryKey: QueryKey }
}

export type ListConversationMessageReceiptQueryResult = NonNullable<Awaited<ReturnType<typeof listConversationMessageReceipt>>>
export type ListConversationMessageReceiptQueryError = unknown


/**
 * @summary Retrieve a list of all delivery and read receipts of the conversation message
 */

export function useListConversationMessageReceipt<TData = Awaited<ReturnType<typeof listConversationMessageReceipt>>, TError = unknown>(
 conversationSid: string,
    messageSid: string,
    params?: ListConversationMessageReceiptParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversationMessageReceipt>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListConversationMessageReceiptQueryOptions(conversationSid,messageSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add a new participant to the conversation
 * @summary Add a new participant to the conversation
 */
export type createConversationParticipantResponse201 = {
  data: ConversationsV1ConversationConversationParticipant
  status: 201
}
    
export type createConversationParticipantResponseSuccess = (createConversationParticipantResponse201) & {
  headers: Headers;
};
;

export type createConversationParticipantResponse = (createConversationParticipantResponseSuccess)

export const getCreateConversationParticipantUrl = (conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Participants`
}

export const createConversationParticipant = async (conversationSid: string,
    createConversationParticipantBody: CreateConversationParticipantBody, options?: RequestInit): Promise<createConversationParticipantResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(createConversationParticipantBody.Identity !== undefined) {
 formUrlEncoded.append(`Identity`, createConversationParticipantBody.Identity)
 }
if(createConversationParticipantBody['MessagingBinding.Address'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.Address`, createConversationParticipantBody['MessagingBinding.Address'])
 }
if(createConversationParticipantBody['MessagingBinding.ProxyAddress'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.ProxyAddress`, createConversationParticipantBody['MessagingBinding.ProxyAddress'])
 }
if(createConversationParticipantBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, createConversationParticipantBody.DateCreated)
 }
if(createConversationParticipantBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, createConversationParticipantBody.DateUpdated)
 }
if(createConversationParticipantBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createConversationParticipantBody.Attributes)
 }
if(createConversationParticipantBody['MessagingBinding.ProjectedAddress'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.ProjectedAddress`, createConversationParticipantBody['MessagingBinding.ProjectedAddress'])
 }
if(createConversationParticipantBody.RoleSid !== undefined) {
 formUrlEncoded.append(`RoleSid`, createConversationParticipantBody.RoleSid)
 }

  const res = await fetch(getCreateConversationParticipantUrl(conversationSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createConversationParticipantResponse
}




export const getCreateConversationParticipantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationParticipant>>, TError,{conversationSid: string;data: CreateConversationParticipantBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createConversationParticipant>>, TError,{conversationSid: string;data: CreateConversationParticipantBody}, TContext> => {

const mutationKey = ['createConversationParticipant'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createConversationParticipant>>, {conversationSid: string;data: CreateConversationParticipantBody}> = (props) => {
          const {conversationSid,data} = props ?? {};

          return  createConversationParticipant(conversationSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateConversationParticipantMutationResult = NonNullable<Awaited<ReturnType<typeof createConversationParticipant>>>
    export type CreateConversationParticipantMutationBody = CreateConversationParticipantBody
    export type CreateConversationParticipantMutationError = unknown

    /**
 * @summary Add a new participant to the conversation
 */
export const useCreateConversationParticipant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationParticipant>>, TError,{conversationSid: string;data: CreateConversationParticipantBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createConversationParticipant>>,
        TError,
        {conversationSid: string;data: CreateConversationParticipantBody},
        TContext
      > => {

      const mutationOptions = getCreateConversationParticipantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all participants of the conversation
 * @summary Retrieve a list of all participants of the conversation
 */
export type listConversationParticipantResponse200 = {
  data: ListConversationParticipant200
  status: 200
}
    
export type listConversationParticipantResponseSuccess = (listConversationParticipantResponse200) & {
  headers: Headers;
};
;

export type listConversationParticipantResponse = (listConversationParticipantResponseSuccess)

export const getListConversationParticipantUrl = (conversationSid: string,
    params?: ListConversationParticipantParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Participants?${stringifiedParams}` : `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Participants`
}

export const listConversationParticipant = async (conversationSid: string,
    params?: ListConversationParticipantParams, options?: RequestInit): Promise<listConversationParticipantResponse> => {
  
  const res = await fetch(getListConversationParticipantUrl(conversationSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listConversationParticipantResponse
}





export const getListConversationParticipantQueryKey = (conversationSid?: string,
    params?: ListConversationParticipantParams,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Participants`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListConversationParticipantQueryOptions = <TData = Awaited<ReturnType<typeof listConversationParticipant>>, TError = unknown>(conversationSid: string,
    params?: ListConversationParticipantParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversationParticipant>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListConversationParticipantQueryKey(conversationSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listConversationParticipant>>> = ({ signal }) => listConversationParticipant(conversationSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listConversationParticipant>>, TError, TData> & { queryKey: QueryKey }
}

export type ListConversationParticipantQueryResult = NonNullable<Awaited<ReturnType<typeof listConversationParticipant>>>
export type ListConversationParticipantQueryError = unknown


/**
 * @summary Retrieve a list of all participants of the conversation
 */

export function useListConversationParticipant<TData = Awaited<ReturnType<typeof listConversationParticipant>>, TError = unknown>(
 conversationSid: string,
    params?: ListConversationParticipantParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversationParticipant>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListConversationParticipantQueryOptions(conversationSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing participant in the conversation
 * @summary Update an existing participant in the conversation
 */
export type updateConversationParticipantResponse200 = {
  data: ConversationsV1ConversationConversationParticipant
  status: 200
}
    
export type updateConversationParticipantResponseSuccess = (updateConversationParticipantResponse200) & {
  headers: Headers;
};
;

export type updateConversationParticipantResponse = (updateConversationParticipantResponseSuccess)

export const getUpdateConversationParticipantUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Participants/${sid}`
}

export const updateConversationParticipant = async (conversationSid: string,
    sid: string,
    updateConversationParticipantBody: UpdateConversationParticipantBody, options?: RequestInit): Promise<updateConversationParticipantResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateConversationParticipantBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, updateConversationParticipantBody.DateCreated)
 }
if(updateConversationParticipantBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, updateConversationParticipantBody.DateUpdated)
 }
if(updateConversationParticipantBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, updateConversationParticipantBody.Attributes)
 }
if(updateConversationParticipantBody.RoleSid !== undefined) {
 formUrlEncoded.append(`RoleSid`, updateConversationParticipantBody.RoleSid)
 }
if(updateConversationParticipantBody['MessagingBinding.ProxyAddress'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.ProxyAddress`, updateConversationParticipantBody['MessagingBinding.ProxyAddress'])
 }
if(updateConversationParticipantBody['MessagingBinding.ProjectedAddress'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.ProjectedAddress`, updateConversationParticipantBody['MessagingBinding.ProjectedAddress'])
 }
if(updateConversationParticipantBody.Identity !== undefined) {
 formUrlEncoded.append(`Identity`, updateConversationParticipantBody.Identity)
 }
if(updateConversationParticipantBody.LastReadMessageIndex !== undefined && updateConversationParticipantBody.LastReadMessageIndex !== null) {
 formUrlEncoded.append(`LastReadMessageIndex`, updateConversationParticipantBody.LastReadMessageIndex.toString())
 }
if(updateConversationParticipantBody.LastReadTimestamp !== undefined) {
 formUrlEncoded.append(`LastReadTimestamp`, updateConversationParticipantBody.LastReadTimestamp)
 }

  const res = await fetch(getUpdateConversationParticipantUrl(conversationSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateConversationParticipantResponse
}




export const getUpdateConversationParticipantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversationParticipant>>, TError,{conversationSid: string;sid: string;data: UpdateConversationParticipantBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateConversationParticipant>>, TError,{conversationSid: string;sid: string;data: UpdateConversationParticipantBody}, TContext> => {

const mutationKey = ['updateConversationParticipant'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConversationParticipant>>, {conversationSid: string;sid: string;data: UpdateConversationParticipantBody}> = (props) => {
          const {conversationSid,sid,data} = props ?? {};

          return  updateConversationParticipant(conversationSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConversationParticipantMutationResult = NonNullable<Awaited<ReturnType<typeof updateConversationParticipant>>>
    export type UpdateConversationParticipantMutationBody = UpdateConversationParticipantBody
    export type UpdateConversationParticipantMutationError = unknown

    /**
 * @summary Update an existing participant in the conversation
 */
export const useUpdateConversationParticipant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversationParticipant>>, TError,{conversationSid: string;sid: string;data: UpdateConversationParticipantBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateConversationParticipant>>,
        TError,
        {conversationSid: string;sid: string;data: UpdateConversationParticipantBody},
        TContext
      > => {

      const mutationOptions = getUpdateConversationParticipantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a participant from the conversation
 * @summary Remove a participant from the conversation
 */
export type deleteConversationParticipantResponse204 = {
  data: void
  status: 204
}
    
export type deleteConversationParticipantResponseSuccess = (deleteConversationParticipantResponse204) & {
  headers: Headers;
};
;

export type deleteConversationParticipantResponse = (deleteConversationParticipantResponseSuccess)

export const getDeleteConversationParticipantUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Participants/${sid}`
}

export const deleteConversationParticipant = async (conversationSid: string,
    sid: string, options?: RequestInit): Promise<deleteConversationParticipantResponse> => {
  
  const res = await fetch(getDeleteConversationParticipantUrl(conversationSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteConversationParticipantResponse
}




export const getDeleteConversationParticipantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversationParticipant>>, TError,{conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConversationParticipant>>, TError,{conversationSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteConversationParticipant'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConversationParticipant>>, {conversationSid: string;sid: string}> = (props) => {
          const {conversationSid,sid} = props ?? {};

          return  deleteConversationParticipant(conversationSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConversationParticipantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConversationParticipant>>>
    
    export type DeleteConversationParticipantMutationError = unknown

    /**
 * @summary Remove a participant from the conversation
 */
export const useDeleteConversationParticipant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversationParticipant>>, TError,{conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteConversationParticipant>>,
        TError,
        {conversationSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteConversationParticipantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a participant of the conversation
 * @summary Fetch a participant of the conversation
 */
export type fetchConversationParticipantResponse200 = {
  data: ConversationsV1ConversationConversationParticipant
  status: 200
}
    
export type fetchConversationParticipantResponseSuccess = (fetchConversationParticipantResponse200) & {
  headers: Headers;
};
;

export type fetchConversationParticipantResponse = (fetchConversationParticipantResponseSuccess)

export const getFetchConversationParticipantUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Participants/${sid}`
}

export const fetchConversationParticipant = async (conversationSid: string,
    sid: string, options?: RequestInit): Promise<fetchConversationParticipantResponse> => {
  
  const res = await fetch(getFetchConversationParticipantUrl(conversationSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchConversationParticipantResponse
}





export const getFetchConversationParticipantQueryKey = (conversationSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Participants/${sid}`
    ] as const;
    }

    
export const getFetchConversationParticipantQueryOptions = <TData = Awaited<ReturnType<typeof fetchConversationParticipant>>, TError = unknown>(conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversationParticipant>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchConversationParticipantQueryKey(conversationSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchConversationParticipant>>> = ({ signal }) => fetchConversationParticipant(conversationSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchConversationParticipant>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchConversationParticipantQueryResult = NonNullable<Awaited<ReturnType<typeof fetchConversationParticipant>>>
export type FetchConversationParticipantQueryError = unknown


/**
 * @summary Fetch a participant of the conversation
 */

export function useFetchConversationParticipant<TData = Awaited<ReturnType<typeof fetchConversationParticipant>>, TError = unknown>(
 conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversationParticipant>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchConversationParticipantQueryOptions(conversationSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all webhooks scoped to the conversation
 * @summary Retrieve a list of all webhooks scoped to the conversation
 */
export type listConversationScopedWebhookResponse200 = {
  data: ListConversationScopedWebhook200
  status: 200
}
    
export type listConversationScopedWebhookResponseSuccess = (listConversationScopedWebhookResponse200) & {
  headers: Headers;
};
;

export type listConversationScopedWebhookResponse = (listConversationScopedWebhookResponseSuccess)

export const getListConversationScopedWebhookUrl = (conversationSid: string,
    params?: ListConversationScopedWebhookParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Webhooks?${stringifiedParams}` : `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Webhooks`
}

export const listConversationScopedWebhook = async (conversationSid: string,
    params?: ListConversationScopedWebhookParams, options?: RequestInit): Promise<listConversationScopedWebhookResponse> => {
  
  const res = await fetch(getListConversationScopedWebhookUrl(conversationSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listConversationScopedWebhookResponse
}





export const getListConversationScopedWebhookQueryKey = (conversationSid?: string,
    params?: ListConversationScopedWebhookParams,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Webhooks`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListConversationScopedWebhookQueryOptions = <TData = Awaited<ReturnType<typeof listConversationScopedWebhook>>, TError = unknown>(conversationSid: string,
    params?: ListConversationScopedWebhookParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversationScopedWebhook>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListConversationScopedWebhookQueryKey(conversationSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listConversationScopedWebhook>>> = ({ signal }) => listConversationScopedWebhook(conversationSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listConversationScopedWebhook>>, TError, TData> & { queryKey: QueryKey }
}

export type ListConversationScopedWebhookQueryResult = NonNullable<Awaited<ReturnType<typeof listConversationScopedWebhook>>>
export type ListConversationScopedWebhookQueryError = unknown


/**
 * @summary Retrieve a list of all webhooks scoped to the conversation
 */

export function useListConversationScopedWebhook<TData = Awaited<ReturnType<typeof listConversationScopedWebhook>>, TError = unknown>(
 conversationSid: string,
    params?: ListConversationScopedWebhookParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listConversationScopedWebhook>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListConversationScopedWebhookQueryOptions(conversationSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new webhook scoped to the conversation
 * @summary Create a new webhook scoped to the conversation
 */
export type createConversationScopedWebhookResponse201 = {
  data: ConversationsV1ConversationConversationScopedWebhook
  status: 201
}
    
export type createConversationScopedWebhookResponseSuccess = (createConversationScopedWebhookResponse201) & {
  headers: Headers;
};
;

export type createConversationScopedWebhookResponse = (createConversationScopedWebhookResponseSuccess)

export const getCreateConversationScopedWebhookUrl = (conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Webhooks`
}

export const createConversationScopedWebhook = async (conversationSid: string,
    createConversationScopedWebhookBody: CreateConversationScopedWebhookBody, options?: RequestInit): Promise<createConversationScopedWebhookResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Target`, createConversationScopedWebhookBody.Target)
if(createConversationScopedWebhookBody['Configuration.Url'] !== undefined) {
 formUrlEncoded.append(`Configuration.Url`, createConversationScopedWebhookBody['Configuration.Url'])
 }
if(createConversationScopedWebhookBody['Configuration.Method'] !== undefined) {
 formUrlEncoded.append(`Configuration.Method`, createConversationScopedWebhookBody['Configuration.Method'])
 }
if(createConversationScopedWebhookBody['Configuration.Filters'] !== undefined) {
 createConversationScopedWebhookBody['Configuration.Filters'].forEach(value => formUrlEncoded.append(`Configuration.Filters`, value));
 }
if(createConversationScopedWebhookBody['Configuration.Triggers'] !== undefined) {
 createConversationScopedWebhookBody['Configuration.Triggers'].forEach(value => formUrlEncoded.append(`Configuration.Triggers`, value));
 }
if(createConversationScopedWebhookBody['Configuration.FlowSid'] !== undefined) {
 formUrlEncoded.append(`Configuration.FlowSid`, createConversationScopedWebhookBody['Configuration.FlowSid'])
 }
if(createConversationScopedWebhookBody['Configuration.ReplayAfter'] !== undefined) {
 formUrlEncoded.append(`Configuration.ReplayAfter`, createConversationScopedWebhookBody['Configuration.ReplayAfter'].toString())
 }

  const res = await fetch(getCreateConversationScopedWebhookUrl(conversationSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createConversationScopedWebhookResponse
}




export const getCreateConversationScopedWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationScopedWebhook>>, TError,{conversationSid: string;data: CreateConversationScopedWebhookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createConversationScopedWebhook>>, TError,{conversationSid: string;data: CreateConversationScopedWebhookBody}, TContext> => {

const mutationKey = ['createConversationScopedWebhook'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createConversationScopedWebhook>>, {conversationSid: string;data: CreateConversationScopedWebhookBody}> = (props) => {
          const {conversationSid,data} = props ?? {};

          return  createConversationScopedWebhook(conversationSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateConversationScopedWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof createConversationScopedWebhook>>>
    export type CreateConversationScopedWebhookMutationBody = CreateConversationScopedWebhookBody
    export type CreateConversationScopedWebhookMutationError = unknown

    /**
 * @summary Create a new webhook scoped to the conversation
 */
export const useCreateConversationScopedWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationScopedWebhook>>, TError,{conversationSid: string;data: CreateConversationScopedWebhookBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createConversationScopedWebhook>>,
        TError,
        {conversationSid: string;data: CreateConversationScopedWebhookBody},
        TContext
      > => {

      const mutationOptions = getCreateConversationScopedWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch the configuration of a conversation-scoped webhook
 * @summary Fetch the configuration of a conversation-scoped webhook
 */
export type fetchConversationScopedWebhookResponse200 = {
  data: ConversationsV1ConversationConversationScopedWebhook
  status: 200
}
    
export type fetchConversationScopedWebhookResponseSuccess = (fetchConversationScopedWebhookResponse200) & {
  headers: Headers;
};
;

export type fetchConversationScopedWebhookResponse = (fetchConversationScopedWebhookResponseSuccess)

export const getFetchConversationScopedWebhookUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Webhooks/${sid}`
}

export const fetchConversationScopedWebhook = async (conversationSid: string,
    sid: string, options?: RequestInit): Promise<fetchConversationScopedWebhookResponse> => {
  
  const res = await fetch(getFetchConversationScopedWebhookUrl(conversationSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchConversationScopedWebhookResponse
}





export const getFetchConversationScopedWebhookQueryKey = (conversationSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Webhooks/${sid}`
    ] as const;
    }

    
export const getFetchConversationScopedWebhookQueryOptions = <TData = Awaited<ReturnType<typeof fetchConversationScopedWebhook>>, TError = unknown>(conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversationScopedWebhook>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchConversationScopedWebhookQueryKey(conversationSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchConversationScopedWebhook>>> = ({ signal }) => fetchConversationScopedWebhook(conversationSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(conversationSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchConversationScopedWebhook>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchConversationScopedWebhookQueryResult = NonNullable<Awaited<ReturnType<typeof fetchConversationScopedWebhook>>>
export type FetchConversationScopedWebhookQueryError = unknown


/**
 * @summary Fetch the configuration of a conversation-scoped webhook
 */

export function useFetchConversationScopedWebhook<TData = Awaited<ReturnType<typeof fetchConversationScopedWebhook>>, TError = unknown>(
 conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchConversationScopedWebhook>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchConversationScopedWebhookQueryOptions(conversationSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing conversation-scoped webhook
 * @summary Update an existing conversation-scoped webhook
 */
export type updateConversationScopedWebhookResponse200 = {
  data: ConversationsV1ConversationConversationScopedWebhook
  status: 200
}
    
export type updateConversationScopedWebhookResponseSuccess = (updateConversationScopedWebhookResponse200) & {
  headers: Headers;
};
;

export type updateConversationScopedWebhookResponse = (updateConversationScopedWebhookResponseSuccess)

export const getUpdateConversationScopedWebhookUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Webhooks/${sid}`
}

export const updateConversationScopedWebhook = async (conversationSid: string,
    sid: string,
    updateConversationScopedWebhookBody: UpdateConversationScopedWebhookBody, options?: RequestInit): Promise<updateConversationScopedWebhookResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateConversationScopedWebhookBody['Configuration.Url'] !== undefined) {
 formUrlEncoded.append(`Configuration.Url`, updateConversationScopedWebhookBody['Configuration.Url'])
 }
if(updateConversationScopedWebhookBody['Configuration.Method'] !== undefined) {
 formUrlEncoded.append(`Configuration.Method`, updateConversationScopedWebhookBody['Configuration.Method'])
 }
if(updateConversationScopedWebhookBody['Configuration.Filters'] !== undefined) {
 updateConversationScopedWebhookBody['Configuration.Filters'].forEach(value => formUrlEncoded.append(`Configuration.Filters`, value));
 }
if(updateConversationScopedWebhookBody['Configuration.Triggers'] !== undefined) {
 updateConversationScopedWebhookBody['Configuration.Triggers'].forEach(value => formUrlEncoded.append(`Configuration.Triggers`, value));
 }
if(updateConversationScopedWebhookBody['Configuration.FlowSid'] !== undefined) {
 formUrlEncoded.append(`Configuration.FlowSid`, updateConversationScopedWebhookBody['Configuration.FlowSid'])
 }

  const res = await fetch(getUpdateConversationScopedWebhookUrl(conversationSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateConversationScopedWebhookResponse
}




export const getUpdateConversationScopedWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversationScopedWebhook>>, TError,{conversationSid: string;sid: string;data: UpdateConversationScopedWebhookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateConversationScopedWebhook>>, TError,{conversationSid: string;sid: string;data: UpdateConversationScopedWebhookBody}, TContext> => {

const mutationKey = ['updateConversationScopedWebhook'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateConversationScopedWebhook>>, {conversationSid: string;sid: string;data: UpdateConversationScopedWebhookBody}> = (props) => {
          const {conversationSid,sid,data} = props ?? {};

          return  updateConversationScopedWebhook(conversationSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateConversationScopedWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof updateConversationScopedWebhook>>>
    export type UpdateConversationScopedWebhookMutationBody = UpdateConversationScopedWebhookBody
    export type UpdateConversationScopedWebhookMutationError = unknown

    /**
 * @summary Update an existing conversation-scoped webhook
 */
export const useUpdateConversationScopedWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateConversationScopedWebhook>>, TError,{conversationSid: string;sid: string;data: UpdateConversationScopedWebhookBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateConversationScopedWebhook>>,
        TError,
        {conversationSid: string;sid: string;data: UpdateConversationScopedWebhookBody},
        TContext
      > => {

      const mutationOptions = getUpdateConversationScopedWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove an existing webhook scoped to the conversation
 * @summary Remove an existing webhook scoped to the conversation
 */
export type deleteConversationScopedWebhookResponse204 = {
  data: void
  status: 204
}
    
export type deleteConversationScopedWebhookResponseSuccess = (deleteConversationScopedWebhookResponse204) & {
  headers: Headers;
};
;

export type deleteConversationScopedWebhookResponse = (deleteConversationScopedWebhookResponseSuccess)

export const getDeleteConversationScopedWebhookUrl = (conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Conversations/${conversationSid}/Webhooks/${sid}`
}

export const deleteConversationScopedWebhook = async (conversationSid: string,
    sid: string, options?: RequestInit): Promise<deleteConversationScopedWebhookResponse> => {
  
  const res = await fetch(getDeleteConversationScopedWebhookUrl(conversationSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteConversationScopedWebhookResponse
}




export const getDeleteConversationScopedWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversationScopedWebhook>>, TError,{conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteConversationScopedWebhook>>, TError,{conversationSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteConversationScopedWebhook'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteConversationScopedWebhook>>, {conversationSid: string;sid: string}> = (props) => {
          const {conversationSid,sid} = props ?? {};

          return  deleteConversationScopedWebhook(conversationSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteConversationScopedWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof deleteConversationScopedWebhook>>>
    
    export type DeleteConversationScopedWebhookMutationError = unknown

    /**
 * @summary Remove an existing webhook scoped to the conversation
 */
export const useDeleteConversationScopedWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteConversationScopedWebhook>>, TError,{conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteConversationScopedWebhook>>,
        TError,
        {conversationSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteConversationScopedWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a new conversation with the list of participants in your account's default service
 * @summary Create a new conversation with the list of participants in your account's default service
 */
export type createConversationWithParticipantsResponse201 = {
  data: ConversationsV1ConversationWithParticipants
  status: 201
}

export type createConversationWithParticipantsResponse202 = {
  data: ConversationsV1ConversationWithParticipants
  status: 202
}
    
export type createConversationWithParticipantsResponseSuccess = (createConversationWithParticipantsResponse201 | createConversationWithParticipantsResponse202) & {
  headers: Headers;
};
;

export type createConversationWithParticipantsResponse = (createConversationWithParticipantsResponseSuccess)

export const getCreateConversationWithParticipantsUrl = () => {


  

  return `https://conversations.twilio.com/v1/ConversationWithParticipants`
}

export const createConversationWithParticipants = async (createConversationWithParticipantsBody: CreateConversationWithParticipantsBody, options?: RequestInit): Promise<createConversationWithParticipantsResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(createConversationWithParticipantsBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, createConversationWithParticipantsBody.FriendlyName)
 }
if(createConversationWithParticipantsBody.UniqueName !== undefined) {
 formUrlEncoded.append(`UniqueName`, createConversationWithParticipantsBody.UniqueName)
 }
if(createConversationWithParticipantsBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, createConversationWithParticipantsBody.DateCreated)
 }
if(createConversationWithParticipantsBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, createConversationWithParticipantsBody.DateUpdated)
 }
if(createConversationWithParticipantsBody.MessagingServiceSid !== undefined) {
 formUrlEncoded.append(`MessagingServiceSid`, createConversationWithParticipantsBody.MessagingServiceSid)
 }
if(createConversationWithParticipantsBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createConversationWithParticipantsBody.Attributes)
 }
if(createConversationWithParticipantsBody.State !== undefined) {
 formUrlEncoded.append(`State`, createConversationWithParticipantsBody.State)
 }
if(createConversationWithParticipantsBody['Timers.Inactive'] !== undefined) {
 formUrlEncoded.append(`Timers.Inactive`, createConversationWithParticipantsBody['Timers.Inactive'])
 }
if(createConversationWithParticipantsBody['Timers.Closed'] !== undefined) {
 formUrlEncoded.append(`Timers.Closed`, createConversationWithParticipantsBody['Timers.Closed'])
 }
if(createConversationWithParticipantsBody['Bindings.Email.Address'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Address`, createConversationWithParticipantsBody['Bindings.Email.Address'])
 }
if(createConversationWithParticipantsBody['Bindings.Email.Name'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Name`, createConversationWithParticipantsBody['Bindings.Email.Name'])
 }
if(createConversationWithParticipantsBody.Participant !== undefined) {
 createConversationWithParticipantsBody.Participant.forEach(value => formUrlEncoded.append(`Participant`, value));
 }

  const res = await fetch(getCreateConversationWithParticipantsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createConversationWithParticipantsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createConversationWithParticipantsResponse
}




export const getCreateConversationWithParticipantsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationWithParticipants>>, TError,{data: CreateConversationWithParticipantsBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createConversationWithParticipants>>, TError,{data: CreateConversationWithParticipantsBody}, TContext> => {

const mutationKey = ['createConversationWithParticipants'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createConversationWithParticipants>>, {data: CreateConversationWithParticipantsBody}> = (props) => {
          const {data} = props ?? {};

          return  createConversationWithParticipants(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateConversationWithParticipantsMutationResult = NonNullable<Awaited<ReturnType<typeof createConversationWithParticipants>>>
    export type CreateConversationWithParticipantsMutationBody = CreateConversationWithParticipantsBody
    export type CreateConversationWithParticipantsMutationError = unknown

    /**
 * @summary Create a new conversation with the list of participants in your account's default service
 */
export const useCreateConversationWithParticipants = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createConversationWithParticipants>>, TError,{data: CreateConversationWithParticipantsBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createConversationWithParticipants>>,
        TError,
        {data: CreateConversationWithParticipantsBody},
        TContext
      > => {

      const mutationOptions = getCreateConversationWithParticipantsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Add a new push notification credential to your account
 * @summary Add a new push notification credential to your account
 */
export type createCredentialResponse201 = {
  data: ConversationsV1Credential
  status: 201
}
    
export type createCredentialResponseSuccess = (createCredentialResponse201) & {
  headers: Headers;
};
;

export type createCredentialResponse = (createCredentialResponseSuccess)

export const getCreateCredentialUrl = () => {


  

  return `https://conversations.twilio.com/v1/Credentials`
}

export const createCredential = async (createCredentialBody: CreateCredentialBody, options?: RequestInit): Promise<createCredentialResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Type`, createCredentialBody.Type)
if(createCredentialBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, createCredentialBody.FriendlyName)
 }
if(createCredentialBody.Certificate !== undefined) {
 formUrlEncoded.append(`Certificate`, createCredentialBody.Certificate)
 }
if(createCredentialBody.PrivateKey !== undefined) {
 formUrlEncoded.append(`PrivateKey`, createCredentialBody.PrivateKey)
 }
if(createCredentialBody.Sandbox !== undefined) {
 formUrlEncoded.append(`Sandbox`, createCredentialBody.Sandbox.toString())
 }
if(createCredentialBody.ApiKey !== undefined) {
 formUrlEncoded.append(`ApiKey`, createCredentialBody.ApiKey)
 }
if(createCredentialBody.Secret !== undefined) {
 formUrlEncoded.append(`Secret`, createCredentialBody.Secret)
 }

  const res = await fetch(getCreateCredentialUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createCredentialResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createCredentialResponse
}




export const getCreateCredentialMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCredential>>, TError,{data: CreateCredentialBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createCredential>>, TError,{data: CreateCredentialBody}, TContext> => {

const mutationKey = ['createCredential'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createCredential>>, {data: CreateCredentialBody}> = (props) => {
          const {data} = props ?? {};

          return  createCredential(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateCredentialMutationResult = NonNullable<Awaited<ReturnType<typeof createCredential>>>
    export type CreateCredentialMutationBody = CreateCredentialBody
    export type CreateCredentialMutationError = unknown

    /**
 * @summary Add a new push notification credential to your account
 */
export const useCreateCredential = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createCredential>>, TError,{data: CreateCredentialBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createCredential>>,
        TError,
        {data: CreateCredentialBody},
        TContext
      > => {

      const mutationOptions = getCreateCredentialMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all push notification credentials on your account
 * @summary Retrieve a list of all push notification credentials on your account
 */
export type listCredentialResponse200 = {
  data: ListCredential200
  status: 200
}
    
export type listCredentialResponseSuccess = (listCredentialResponse200) & {
  headers: Headers;
};
;

export type listCredentialResponse = (listCredentialResponseSuccess)

export const getListCredentialUrl = (params?: ListCredentialParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Credentials?${stringifiedParams}` : `https://conversations.twilio.com/v1/Credentials`
}

export const listCredential = async (params?: ListCredentialParams, options?: RequestInit): Promise<listCredentialResponse> => {
  
  const res = await fetch(getListCredentialUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listCredentialResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listCredentialResponse
}





export const getListCredentialQueryKey = (params?: ListCredentialParams,) => {
    return [
    `https://conversations.twilio.com/v1/Credentials`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListCredentialQueryOptions = <TData = Awaited<ReturnType<typeof listCredential>>, TError = unknown>(params?: ListCredentialParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listCredential>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListCredentialQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listCredential>>> = ({ signal }) => listCredential(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listCredential>>, TError, TData> & { queryKey: QueryKey }
}

export type ListCredentialQueryResult = NonNullable<Awaited<ReturnType<typeof listCredential>>>
export type ListCredentialQueryError = unknown


/**
 * @summary Retrieve a list of all push notification credentials on your account
 */

export function useListCredential<TData = Awaited<ReturnType<typeof listCredential>>, TError = unknown>(
 params?: ListCredentialParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listCredential>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListCredentialQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing push notification credential on your account
 * @summary Update an existing push notification credential on your account
 */
export type updateCredentialResponse200 = {
  data: ConversationsV1Credential
  status: 200
}
    
export type updateCredentialResponseSuccess = (updateCredentialResponse200) & {
  headers: Headers;
};
;

export type updateCredentialResponse = (updateCredentialResponseSuccess)

export const getUpdateCredentialUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Credentials/${sid}`
}

export const updateCredential = async (sid: string,
    updateCredentialBody: UpdateCredentialBody, options?: RequestInit): Promise<updateCredentialResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateCredentialBody.Type !== undefined) {
 formUrlEncoded.append(`Type`, updateCredentialBody.Type)
 }
if(updateCredentialBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, updateCredentialBody.FriendlyName)
 }
if(updateCredentialBody.Certificate !== undefined) {
 formUrlEncoded.append(`Certificate`, updateCredentialBody.Certificate)
 }
if(updateCredentialBody.PrivateKey !== undefined) {
 formUrlEncoded.append(`PrivateKey`, updateCredentialBody.PrivateKey)
 }
if(updateCredentialBody.Sandbox !== undefined) {
 formUrlEncoded.append(`Sandbox`, updateCredentialBody.Sandbox.toString())
 }
if(updateCredentialBody.ApiKey !== undefined) {
 formUrlEncoded.append(`ApiKey`, updateCredentialBody.ApiKey)
 }
if(updateCredentialBody.Secret !== undefined) {
 formUrlEncoded.append(`Secret`, updateCredentialBody.Secret)
 }

  const res = await fetch(getUpdateCredentialUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateCredentialResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateCredentialResponse
}




export const getUpdateCredentialMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCredential>>, TError,{sid: string;data: UpdateCredentialBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateCredential>>, TError,{sid: string;data: UpdateCredentialBody}, TContext> => {

const mutationKey = ['updateCredential'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateCredential>>, {sid: string;data: UpdateCredentialBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateCredential(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateCredentialMutationResult = NonNullable<Awaited<ReturnType<typeof updateCredential>>>
    export type UpdateCredentialMutationBody = UpdateCredentialBody
    export type UpdateCredentialMutationError = unknown

    /**
 * @summary Update an existing push notification credential on your account
 */
export const useUpdateCredential = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateCredential>>, TError,{sid: string;data: UpdateCredentialBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateCredential>>,
        TError,
        {sid: string;data: UpdateCredentialBody},
        TContext
      > => {

      const mutationOptions = getUpdateCredentialMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a push notification credential from your account
 * @summary Remove a push notification credential from your account
 */
export type deleteCredentialResponse204 = {
  data: void
  status: 204
}
    
export type deleteCredentialResponseSuccess = (deleteCredentialResponse204) & {
  headers: Headers;
};
;

export type deleteCredentialResponse = (deleteCredentialResponseSuccess)

export const getDeleteCredentialUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Credentials/${sid}`
}

export const deleteCredential = async (sid: string, options?: RequestInit): Promise<deleteCredentialResponse> => {
  
  const res = await fetch(getDeleteCredentialUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteCredentialResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteCredentialResponse
}




export const getDeleteCredentialMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCredential>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteCredential>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteCredential'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteCredential>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteCredential(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteCredentialMutationResult = NonNullable<Awaited<ReturnType<typeof deleteCredential>>>
    
    export type DeleteCredentialMutationError = unknown

    /**
 * @summary Remove a push notification credential from your account
 */
export const useDeleteCredential = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteCredential>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteCredential>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteCredentialMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a push notification credential from your account
 * @summary Fetch a push notification credential from your account
 */
export type fetchCredentialResponse200 = {
  data: ConversationsV1Credential
  status: 200
}
    
export type fetchCredentialResponseSuccess = (fetchCredentialResponse200) & {
  headers: Headers;
};
;

export type fetchCredentialResponse = (fetchCredentialResponseSuccess)

export const getFetchCredentialUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Credentials/${sid}`
}

export const fetchCredential = async (sid: string, options?: RequestInit): Promise<fetchCredentialResponse> => {
  
  const res = await fetch(getFetchCredentialUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchCredentialResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchCredentialResponse
}





export const getFetchCredentialQueryKey = (sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Credentials/${sid}`
    ] as const;
    }

    
export const getFetchCredentialQueryOptions = <TData = Awaited<ReturnType<typeof fetchCredential>>, TError = unknown>(sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchCredential>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchCredentialQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchCredential>>> = ({ signal }) => fetchCredential(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchCredential>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchCredentialQueryResult = NonNullable<Awaited<ReturnType<typeof fetchCredential>>>
export type FetchCredentialQueryError = unknown


/**
 * @summary Fetch a push notification credential from your account
 */

export function useFetchCredential<TData = Awaited<ReturnType<typeof fetchCredential>>, TError = unknown>(
 sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchCredential>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchCredentialQueryOptions(sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
 * @summary Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
 */
export type listParticipantConversationResponse200 = {
  data: ListParticipantConversation200
  status: 200
}
    
export type listParticipantConversationResponseSuccess = (listParticipantConversationResponse200) & {
  headers: Headers;
};
;

export type listParticipantConversationResponse = (listParticipantConversationResponseSuccess)

export const getListParticipantConversationUrl = (params?: ListParticipantConversationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/ParticipantConversations?${stringifiedParams}` : `https://conversations.twilio.com/v1/ParticipantConversations`
}

export const listParticipantConversation = async (params?: ListParticipantConversationParams, options?: RequestInit): Promise<listParticipantConversationResponse> => {
  
  const res = await fetch(getListParticipantConversationUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listParticipantConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listParticipantConversationResponse
}





export const getListParticipantConversationQueryKey = (params?: ListParticipantConversationParams,) => {
    return [
    `https://conversations.twilio.com/v1/ParticipantConversations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListParticipantConversationQueryOptions = <TData = Awaited<ReturnType<typeof listParticipantConversation>>, TError = unknown>(params?: ListParticipantConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listParticipantConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListParticipantConversationQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listParticipantConversation>>> = ({ signal }) => listParticipantConversation(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listParticipantConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type ListParticipantConversationQueryResult = NonNullable<Awaited<ReturnType<typeof listParticipantConversation>>>
export type ListParticipantConversationQueryError = unknown


/**
 * @summary Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
 */

export function useListParticipantConversation<TData = Awaited<ReturnType<typeof listParticipantConversation>>, TError = unknown>(
 params?: ListParticipantConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listParticipantConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListParticipantConversationQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new user role in your account's default service
 * @summary Create a new user role in your account's default service
 */
export type createRoleResponse201 = {
  data: ConversationsV1Role
  status: 201
}
    
export type createRoleResponseSuccess = (createRoleResponse201) & {
  headers: Headers;
};
;

export type createRoleResponse = (createRoleResponseSuccess)

export const getCreateRoleUrl = () => {


  

  return `https://conversations.twilio.com/v1/Roles`
}

export const createRole = async (createRoleBody: CreateRoleBody, options?: RequestInit): Promise<createRoleResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`FriendlyName`, createRoleBody.FriendlyName)
formUrlEncoded.append(`Type`, createRoleBody.Type)
createRoleBody.Permission.forEach(value => formUrlEncoded.append(`Permission`, value));

  const res = await fetch(getCreateRoleUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createRoleResponse
}




export const getCreateRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: CreateRoleBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: CreateRoleBody}, TContext> => {

const mutationKey = ['createRole'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createRole>>, {data: CreateRoleBody}> = (props) => {
          const {data} = props ?? {};

          return  createRole(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof createRole>>>
    export type CreateRoleMutationBody = CreateRoleBody
    export type CreateRoleMutationError = unknown

    /**
 * @summary Create a new user role in your account's default service
 */
export const useCreateRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createRole>>, TError,{data: CreateRoleBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createRole>>,
        TError,
        {data: CreateRoleBody},
        TContext
      > => {

      const mutationOptions = getCreateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all user roles in your account's default service
 * @summary Retrieve a list of all user roles in your account's default service
 */
export type listRoleResponse200 = {
  data: ListRole200
  status: 200
}
    
export type listRoleResponseSuccess = (listRoleResponse200) & {
  headers: Headers;
};
;

export type listRoleResponse = (listRoleResponseSuccess)

export const getListRoleUrl = (params?: ListRoleParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Roles?${stringifiedParams}` : `https://conversations.twilio.com/v1/Roles`
}

export const listRole = async (params?: ListRoleParams, options?: RequestInit): Promise<listRoleResponse> => {
  
  const res = await fetch(getListRoleUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listRoleResponse
}





export const getListRoleQueryKey = (params?: ListRoleParams,) => {
    return [
    `https://conversations.twilio.com/v1/Roles`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListRoleQueryOptions = <TData = Awaited<ReturnType<typeof listRole>>, TError = unknown>(params?: ListRoleParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listRole>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListRoleQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listRole>>> = ({ signal }) => listRole(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listRole>>, TError, TData> & { queryKey: QueryKey }
}

export type ListRoleQueryResult = NonNullable<Awaited<ReturnType<typeof listRole>>>
export type ListRoleQueryError = unknown


/**
 * @summary Retrieve a list of all user roles in your account's default service
 */

export function useListRole<TData = Awaited<ReturnType<typeof listRole>>, TError = unknown>(
 params?: ListRoleParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listRole>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListRoleQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing user role in your account's default service
 * @summary Update an existing user role in your account's default service
 */
export type updateRoleResponse200 = {
  data: ConversationsV1Role
  status: 200
}
    
export type updateRoleResponseSuccess = (updateRoleResponse200) & {
  headers: Headers;
};
;

export type updateRoleResponse = (updateRoleResponseSuccess)

export const getUpdateRoleUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Roles/${sid}`
}

export const updateRole = async (sid: string,
    updateRoleBody: UpdateRoleBody, options?: RequestInit): Promise<updateRoleResponse> => {
    const formUrlEncoded = new URLSearchParams();
updateRoleBody.Permission.forEach(value => formUrlEncoded.append(`Permission`, value));

  const res = await fetch(getUpdateRoleUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateRoleResponse
}




export const getUpdateRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{sid: string;data: UpdateRoleBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{sid: string;data: UpdateRoleBody}, TContext> => {

const mutationKey = ['updateRole'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateRole>>, {sid: string;data: UpdateRoleBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateRole(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateRole>>>
    export type UpdateRoleMutationBody = UpdateRoleBody
    export type UpdateRoleMutationError = unknown

    /**
 * @summary Update an existing user role in your account's default service
 */
export const useUpdateRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateRole>>, TError,{sid: string;data: UpdateRoleBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateRole>>,
        TError,
        {sid: string;data: UpdateRoleBody},
        TContext
      > => {

      const mutationOptions = getUpdateRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a user role from your account's default service
 * @summary Remove a user role from your account's default service
 */
export type deleteRoleResponse204 = {
  data: void
  status: 204
}
    
export type deleteRoleResponseSuccess = (deleteRoleResponse204) & {
  headers: Headers;
};
;

export type deleteRoleResponse = (deleteRoleResponseSuccess)

export const getDeleteRoleUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Roles/${sid}`
}

export const deleteRole = async (sid: string, options?: RequestInit): Promise<deleteRoleResponse> => {
  
  const res = await fetch(getDeleteRoleUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteRoleResponse
}




export const getDeleteRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteRole'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteRole>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteRole(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteRole>>>
    
    export type DeleteRoleMutationError = unknown

    /**
 * @summary Remove a user role from your account's default service
 */
export const useDeleteRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteRole>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteRole>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a user role from your account's default service
 * @summary Fetch a user role from your account's default service
 */
export type fetchRoleResponse200 = {
  data: ConversationsV1Role
  status: 200
}
    
export type fetchRoleResponseSuccess = (fetchRoleResponse200) & {
  headers: Headers;
};
;

export type fetchRoleResponse = (fetchRoleResponseSuccess)

export const getFetchRoleUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Roles/${sid}`
}

export const fetchRole = async (sid: string, options?: RequestInit): Promise<fetchRoleResponse> => {
  
  const res = await fetch(getFetchRoleUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchRoleResponse
}





export const getFetchRoleQueryKey = (sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Roles/${sid}`
    ] as const;
    }

    
export const getFetchRoleQueryOptions = <TData = Awaited<ReturnType<typeof fetchRole>>, TError = unknown>(sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchRole>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchRoleQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchRole>>> = ({ signal }) => fetchRole(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchRole>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchRoleQueryResult = NonNullable<Awaited<ReturnType<typeof fetchRole>>>
export type FetchRoleQueryError = unknown


/**
 * @summary Fetch a user role from your account's default service
 */

export function useFetchRole<TData = Awaited<ReturnType<typeof fetchRole>>, TError = unknown>(
 sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchRole>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchRoleQueryOptions(sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new conversation service on your account
 * @summary Create a new conversation service on your account
 */
export type createServiceResponse201 = {
  data: ConversationsV1Service
  status: 201
}
    
export type createServiceResponseSuccess = (createServiceResponse201) & {
  headers: Headers;
};
;

export type createServiceResponse = (createServiceResponseSuccess)

export const getCreateServiceUrl = () => {


  

  return `https://conversations.twilio.com/v1/Services`
}

export const createService = async (createServiceBody: CreateServiceBody, options?: RequestInit): Promise<createServiceResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`FriendlyName`, createServiceBody.FriendlyName)

  const res = await fetch(getCreateServiceUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceResponse
}




export const getCreateServiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceBody}, TContext> => {

const mutationKey = ['createService'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createService>>, {data: CreateServiceBody}> = (props) => {
          const {data} = props ?? {};

          return  createService(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceMutationResult = NonNullable<Awaited<ReturnType<typeof createService>>>
    export type CreateServiceMutationBody = CreateServiceBody
    export type CreateServiceMutationError = unknown

    /**
 * @summary Create a new conversation service on your account
 */
export const useCreateService = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createService>>, TError,{data: CreateServiceBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createService>>,
        TError,
        {data: CreateServiceBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all conversation services on your account
 * @summary Retrieve a list of all conversation services on your account
 */
export type listServiceResponse200 = {
  data: ListService200
  status: 200
}
    
export type listServiceResponseSuccess = (listServiceResponse200) & {
  headers: Headers;
};
;

export type listServiceResponse = (listServiceResponseSuccess)

export const getListServiceUrl = (params?: ListServiceParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services`
}

export const listService = async (params?: ListServiceParams, options?: RequestInit): Promise<listServiceResponse> => {
  
  const res = await fetch(getListServiceUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceResponse
}





export const getListServiceQueryKey = (params?: ListServiceParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceQueryOptions = <TData = Awaited<ReturnType<typeof listService>>, TError = unknown>(params?: ListServiceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listService>>> = ({ signal }) => listService(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceQueryResult = NonNullable<Awaited<ReturnType<typeof listService>>>
export type ListServiceQueryError = unknown


/**
 * @summary Retrieve a list of all conversation services on your account
 */

export function useListService<TData = Awaited<ReturnType<typeof listService>>, TError = unknown>(
 params?: ListServiceParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listService>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Remove a conversation service with all its nested resources from your account
 * @summary Remove a conversation service with all its nested resources from your account
 */
export type deleteServiceResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceResponseSuccess = (deleteServiceResponse204) & {
  headers: Headers;
};
;

export type deleteServiceResponse = (deleteServiceResponseSuccess)

export const getDeleteServiceUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${sid}`
}

export const deleteService = async (sid: string, options?: RequestInit): Promise<deleteServiceResponse> => {
  
  const res = await fetch(getDeleteServiceUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceResponse
}




export const getDeleteServiceMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteService'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteService>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteService(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceMutationResult = NonNullable<Awaited<ReturnType<typeof deleteService>>>
    
    export type DeleteServiceMutationError = unknown

    /**
 * @summary Remove a conversation service with all its nested resources from your account
 */
export const useDeleteService = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteService>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteService>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a conversation service from your account
 * @summary Fetch a conversation service from your account
 */
export type fetchServiceResponse200 = {
  data: ConversationsV1Service
  status: 200
}
    
export type fetchServiceResponseSuccess = (fetchServiceResponse200) & {
  headers: Headers;
};
;

export type fetchServiceResponse = (fetchServiceResponseSuccess)

export const getFetchServiceUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${sid}`
}

export const fetchService = async (sid: string, options?: RequestInit): Promise<fetchServiceResponse> => {
  
  const res = await fetch(getFetchServiceUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceResponse
}





export const getFetchServiceQueryKey = (sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${sid}`
    ] as const;
    }

    
export const getFetchServiceQueryOptions = <TData = Awaited<ReturnType<typeof fetchService>>, TError = unknown>(sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchService>>> = ({ signal }) => fetchService(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceQueryResult = NonNullable<Awaited<ReturnType<typeof fetchService>>>
export type FetchServiceQueryError = unknown


/**
 * @summary Fetch a conversation service from your account
 */

export function useFetchService<TData = Awaited<ReturnType<typeof fetchService>>, TError = unknown>(
 sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchService>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceQueryOptions(sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Remove a push notification binding from the conversation service
 * @summary Remove a push notification binding from the conversation service
 */
export type deleteServiceBindingResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceBindingResponseSuccess = (deleteServiceBindingResponse204) & {
  headers: Headers;
};
;

export type deleteServiceBindingResponse = (deleteServiceBindingResponseSuccess)

export const getDeleteServiceBindingUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Bindings/${sid}`
}

export const deleteServiceBinding = async (chatServiceSid: string,
    sid: string, options?: RequestInit): Promise<deleteServiceBindingResponse> => {
  
  const res = await fetch(getDeleteServiceBindingUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceBindingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceBindingResponse
}




export const getDeleteServiceBindingMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceBinding>>, TError,{chatServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceBinding>>, TError,{chatServiceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteServiceBinding'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceBinding>>, {chatServiceSid: string;sid: string}> = (props) => {
          const {chatServiceSid,sid} = props ?? {};

          return  deleteServiceBinding(chatServiceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceBindingMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceBinding>>>
    
    export type DeleteServiceBindingMutationError = unknown

    /**
 * @summary Remove a push notification binding from the conversation service
 */
export const useDeleteServiceBinding = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceBinding>>, TError,{chatServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceBinding>>,
        TError,
        {chatServiceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceBindingMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a push notification binding from the conversation service
 * @summary Fetch a push notification binding from the conversation service
 */
export type fetchServiceBindingResponse200 = {
  data: ConversationsV1ServiceServiceBinding
  status: 200
}
    
export type fetchServiceBindingResponseSuccess = (fetchServiceBindingResponse200) & {
  headers: Headers;
};
;

export type fetchServiceBindingResponse = (fetchServiceBindingResponseSuccess)

export const getFetchServiceBindingUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Bindings/${sid}`
}

export const fetchServiceBinding = async (chatServiceSid: string,
    sid: string, options?: RequestInit): Promise<fetchServiceBindingResponse> => {
  
  const res = await fetch(getFetchServiceBindingUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceBindingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceBindingResponse
}





export const getFetchServiceBindingQueryKey = (chatServiceSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Bindings/${sid}`
    ] as const;
    }

    
export const getFetchServiceBindingQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceBinding>>, TError = unknown>(chatServiceSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceBinding>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceBindingQueryKey(chatServiceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceBinding>>> = ({ signal }) => fetchServiceBinding(chatServiceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceBinding>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceBindingQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceBinding>>>
export type FetchServiceBindingQueryError = unknown


/**
 * @summary Fetch a push notification binding from the conversation service
 */

export function useFetchServiceBinding<TData = Awaited<ReturnType<typeof fetchServiceBinding>>, TError = unknown>(
 chatServiceSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceBinding>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceBindingQueryOptions(chatServiceSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all push notification bindings in the conversation service
 * @summary Retrieve a list of all push notification bindings in the conversation service
 */
export type listServiceBindingResponse200 = {
  data: ListServiceBinding200
  status: 200
}
    
export type listServiceBindingResponseSuccess = (listServiceBindingResponse200) & {
  headers: Headers;
};
;

export type listServiceBindingResponse = (listServiceBindingResponseSuccess)

export const getListServiceBindingUrl = (chatServiceSid: string,
    params?: ListServiceBindingParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["BindingType","Identity"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Bindings?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Bindings`
}

export const listServiceBinding = async (chatServiceSid: string,
    params?: ListServiceBindingParams, options?: RequestInit): Promise<listServiceBindingResponse> => {
  
  const res = await fetch(getListServiceBindingUrl(chatServiceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceBindingResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceBindingResponse
}





export const getListServiceBindingQueryKey = (chatServiceSid?: string,
    params?: ListServiceBindingParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Bindings`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceBindingQueryOptions = <TData = Awaited<ReturnType<typeof listServiceBinding>>, TError = unknown>(chatServiceSid: string,
    params?: ListServiceBindingParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceBinding>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceBindingQueryKey(chatServiceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceBinding>>> = ({ signal }) => listServiceBinding(chatServiceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceBinding>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceBindingQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceBinding>>>
export type ListServiceBindingQueryError = unknown


/**
 * @summary Retrieve a list of all push notification bindings in the conversation service
 */

export function useListServiceBinding<TData = Awaited<ReturnType<typeof listServiceBinding>>, TError = unknown>(
 chatServiceSid: string,
    params?: ListServiceBindingParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceBinding>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceBindingQueryOptions(chatServiceSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Fetch the configuration of a conversation service
 * @summary Fetch the configuration of a conversation service
 */
export type fetchServiceConfigurationResponse200 = {
  data: ConversationsV1ServiceServiceConfiguration
  status: 200
}
    
export type fetchServiceConfigurationResponseSuccess = (fetchServiceConfigurationResponse200) & {
  headers: Headers;
};
;

export type fetchServiceConfigurationResponse = (fetchServiceConfigurationResponseSuccess)

export const getFetchServiceConfigurationUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration`
}

export const fetchServiceConfiguration = async (chatServiceSid: string, options?: RequestInit): Promise<fetchServiceConfigurationResponse> => {
  
  const res = await fetch(getFetchServiceConfigurationUrl(chatServiceSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceConfigurationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceConfigurationResponse
}





export const getFetchServiceConfigurationQueryKey = (chatServiceSid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration`
    ] as const;
    }

    
export const getFetchServiceConfigurationQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceConfiguration>>, TError = unknown>(chatServiceSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConfiguration>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceConfigurationQueryKey(chatServiceSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceConfiguration>>> = ({ signal }) => fetchServiceConfiguration(chatServiceSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConfiguration>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceConfiguration>>>
export type FetchServiceConfigurationQueryError = unknown


/**
 * @summary Fetch the configuration of a conversation service
 */

export function useFetchServiceConfiguration<TData = Awaited<ReturnType<typeof fetchServiceConfiguration>>, TError = unknown>(
 chatServiceSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConfiguration>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceConfigurationQueryOptions(chatServiceSid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update configuration settings of a conversation service
 * @summary Update configuration settings of a conversation service
 */
export type updateServiceConfigurationResponse200 = {
  data: ConversationsV1ServiceServiceConfiguration
  status: 200
}
    
export type updateServiceConfigurationResponseSuccess = (updateServiceConfigurationResponse200) & {
  headers: Headers;
};
;

export type updateServiceConfigurationResponse = (updateServiceConfigurationResponseSuccess)

export const getUpdateServiceConfigurationUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration`
}

export const updateServiceConfiguration = async (chatServiceSid: string,
    updateServiceConfigurationBody: UpdateServiceConfigurationBody, options?: RequestInit): Promise<updateServiceConfigurationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceConfigurationBody.DefaultConversationCreatorRoleSid !== undefined) {
 formUrlEncoded.append(`DefaultConversationCreatorRoleSid`, updateServiceConfigurationBody.DefaultConversationCreatorRoleSid)
 }
if(updateServiceConfigurationBody.DefaultConversationRoleSid !== undefined) {
 formUrlEncoded.append(`DefaultConversationRoleSid`, updateServiceConfigurationBody.DefaultConversationRoleSid)
 }
if(updateServiceConfigurationBody.DefaultChatServiceRoleSid !== undefined) {
 formUrlEncoded.append(`DefaultChatServiceRoleSid`, updateServiceConfigurationBody.DefaultChatServiceRoleSid)
 }
if(updateServiceConfigurationBody.ReachabilityEnabled !== undefined) {
 formUrlEncoded.append(`ReachabilityEnabled`, updateServiceConfigurationBody.ReachabilityEnabled.toString())
 }

  const res = await fetch(getUpdateServiceConfigurationUrl(chatServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceConfigurationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceConfigurationResponse
}




export const getUpdateServiceConfigurationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConfiguration>>, TError,{chatServiceSid: string;data: UpdateServiceConfigurationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceConfiguration>>, TError,{chatServiceSid: string;data: UpdateServiceConfigurationBody}, TContext> => {

const mutationKey = ['updateServiceConfiguration'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceConfiguration>>, {chatServiceSid: string;data: UpdateServiceConfigurationBody}> = (props) => {
          const {chatServiceSid,data} = props ?? {};

          return  updateServiceConfiguration(chatServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceConfiguration>>>
    export type UpdateServiceConfigurationMutationBody = UpdateServiceConfigurationBody
    export type UpdateServiceConfigurationMutationError = unknown

    /**
 * @summary Update configuration settings of a conversation service
 */
export const useUpdateServiceConfiguration = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConfiguration>>, TError,{chatServiceSid: string;data: UpdateServiceConfigurationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceConfiguration>>,
        TError,
        {chatServiceSid: string;data: UpdateServiceConfigurationBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceConfigurationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Create a new conversation in your service
 * @summary Create a new conversation in your service
 */
export type createServiceConversationResponse201 = {
  data: ConversationsV1ServiceServiceConversation
  status: 201
}
    
export type createServiceConversationResponseSuccess = (createServiceConversationResponse201) & {
  headers: Headers;
};
;

export type createServiceConversationResponse = (createServiceConversationResponseSuccess)

export const getCreateServiceConversationUrl = (chatServiceSid: string,) => {



  
  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations`
}

export const createServiceConversation = async (chatServiceSid: string,
    createServiceConversationBody: CreateServiceConversationBody, options?: RequestInit): Promise<createServiceConversationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(createServiceConversationBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, createServiceConversationBody.FriendlyName)
 }
if(createServiceConversationBody.UniqueName !== undefined) {
 formUrlEncoded.append(`UniqueName`, createServiceConversationBody.UniqueName)
 }
if(createServiceConversationBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createServiceConversationBody.Attributes)
 }
if(createServiceConversationBody.MessagingServiceSid !== undefined) {
 formUrlEncoded.append(`MessagingServiceSid`, createServiceConversationBody.MessagingServiceSid)
 }
if(createServiceConversationBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, createServiceConversationBody.DateCreated)
 }
if(createServiceConversationBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, createServiceConversationBody.DateUpdated)
 }
if(createServiceConversationBody.State !== undefined) {
 formUrlEncoded.append(`State`, createServiceConversationBody.State)
 }
if(createServiceConversationBody['Timers.Inactive'] !== undefined) {
 formUrlEncoded.append(`Timers.Inactive`, createServiceConversationBody['Timers.Inactive'])
 }
if(createServiceConversationBody['Timers.Closed'] !== undefined) {
 formUrlEncoded.append(`Timers.Closed`, createServiceConversationBody['Timers.Closed'])
 }
if(createServiceConversationBody['Bindings.Email.Address'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Address`, createServiceConversationBody['Bindings.Email.Address'])
 }
if(createServiceConversationBody['Bindings.Email.Name'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Name`, createServiceConversationBody['Bindings.Email.Name'])
 }

  const res = await fetch(getCreateServiceConversationUrl(chatServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceConversationResponse
}




export const getCreateServiceConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversation>>, TError,{chatServiceSid: string;data: CreateServiceConversationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceConversation>>, TError,{chatServiceSid: string;data: CreateServiceConversationBody}, TContext> => {

const mutationKey = ['createServiceConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceConversation>>, {chatServiceSid: string;data: CreateServiceConversationBody}> = (props) => {
          const {chatServiceSid,data} = props ?? {};

          return  createServiceConversation(chatServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceConversationMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceConversation>>>
    export type CreateServiceConversationMutationBody = CreateServiceConversationBody
    export type CreateServiceConversationMutationError = unknown

    /**
 * @summary Create a new conversation in your service
 */
export const useCreateServiceConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversation>>, TError,{chatServiceSid: string;data: CreateServiceConversationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createServiceConversation>>,
        TError,
        {chatServiceSid: string;data: CreateServiceConversationBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of conversations in your service
 * @summary Retrieve a list of conversations in your service
 */
export type listServiceConversationResponse200 = {
  data: ListServiceConversation200
  status: 200
}
    
export type listServiceConversationResponseSuccess = (listServiceConversationResponse200) & {
  headers: Headers;
};
;

export type listServiceConversationResponse = (listServiceConversationResponseSuccess)

export const getListServiceConversationUrl = (chatServiceSid: string,
    params?: ListServiceConversationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations`
}

export const listServiceConversation = async (chatServiceSid: string,
    params?: ListServiceConversationParams, options?: RequestInit): Promise<listServiceConversationResponse> => {
  
  const res = await fetch(getListServiceConversationUrl(chatServiceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceConversationResponse
}





export const getListServiceConversationQueryKey = (chatServiceSid?: string,
    params?: ListServiceConversationParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceConversationQueryOptions = <TData = Awaited<ReturnType<typeof listServiceConversation>>, TError = unknown>(chatServiceSid: string,
    params?: ListServiceConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceConversationQueryKey(chatServiceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceConversation>>> = ({ signal }) => listServiceConversation(chatServiceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceConversationQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceConversation>>>
export type ListServiceConversationQueryError = unknown


/**
 * @summary Retrieve a list of conversations in your service
 */

export function useListServiceConversation<TData = Awaited<ReturnType<typeof listServiceConversation>>, TError = unknown>(
 chatServiceSid: string,
    params?: ListServiceConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceConversationQueryOptions(chatServiceSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing conversation in your service
 * @summary Update an existing conversation in your service
 */
export type updateServiceConversationResponse200 = {
  data: ConversationsV1ServiceServiceConversation
  status: 200
}
    
export type updateServiceConversationResponseSuccess = (updateServiceConversationResponse200) & {
  headers: Headers;
};
;

export type updateServiceConversationResponse = (updateServiceConversationResponseSuccess)

export const getUpdateServiceConversationUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${sid}`
}

export const updateServiceConversation = async (chatServiceSid: string,
    sid: string,
    updateServiceConversationBody: UpdateServiceConversationBody, options?: RequestInit): Promise<updateServiceConversationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceConversationBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, updateServiceConversationBody.FriendlyName)
 }
if(updateServiceConversationBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, updateServiceConversationBody.DateCreated)
 }
if(updateServiceConversationBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, updateServiceConversationBody.DateUpdated)
 }
if(updateServiceConversationBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, updateServiceConversationBody.Attributes)
 }
if(updateServiceConversationBody.MessagingServiceSid !== undefined) {
 formUrlEncoded.append(`MessagingServiceSid`, updateServiceConversationBody.MessagingServiceSid)
 }
if(updateServiceConversationBody.State !== undefined) {
 formUrlEncoded.append(`State`, updateServiceConversationBody.State)
 }
if(updateServiceConversationBody['Timers.Inactive'] !== undefined) {
 formUrlEncoded.append(`Timers.Inactive`, updateServiceConversationBody['Timers.Inactive'])
 }
if(updateServiceConversationBody['Timers.Closed'] !== undefined) {
 formUrlEncoded.append(`Timers.Closed`, updateServiceConversationBody['Timers.Closed'])
 }
if(updateServiceConversationBody.UniqueName !== undefined) {
 formUrlEncoded.append(`UniqueName`, updateServiceConversationBody.UniqueName)
 }
if(updateServiceConversationBody['Bindings.Email.Address'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Address`, updateServiceConversationBody['Bindings.Email.Address'])
 }
if(updateServiceConversationBody['Bindings.Email.Name'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Name`, updateServiceConversationBody['Bindings.Email.Name'])
 }

  const res = await fetch(getUpdateServiceConversationUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceConversationResponse
}




export const getUpdateServiceConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversation>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceConversationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversation>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceConversationBody}, TContext> => {

const mutationKey = ['updateServiceConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceConversation>>, {chatServiceSid: string;sid: string;data: UpdateServiceConversationBody}> = (props) => {
          const {chatServiceSid,sid,data} = props ?? {};

          return  updateServiceConversation(chatServiceSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceConversationMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceConversation>>>
    export type UpdateServiceConversationMutationBody = UpdateServiceConversationBody
    export type UpdateServiceConversationMutationError = unknown

    /**
 * @summary Update an existing conversation in your service
 */
export const useUpdateServiceConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversation>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceConversationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceConversation>>,
        TError,
        {chatServiceSid: string;sid: string;data: UpdateServiceConversationBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a conversation from your service
 * @summary Remove a conversation from your service
 */
export type deleteServiceConversationResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceConversationResponseSuccess = (deleteServiceConversationResponse204) & {
  headers: Headers;
};
;

export type deleteServiceConversationResponse = (deleteServiceConversationResponseSuccess)

export const getDeleteServiceConversationUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${sid}`
}

export const deleteServiceConversation = async (chatServiceSid: string,
    sid: string, options?: RequestInit): Promise<deleteServiceConversationResponse> => {
  
  const res = await fetch(getDeleteServiceConversationUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceConversationResponse
}




export const getDeleteServiceConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversation>>, TError,{chatServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversation>>, TError,{chatServiceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteServiceConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceConversation>>, {chatServiceSid: string;sid: string}> = (props) => {
          const {chatServiceSid,sid} = props ?? {};

          return  deleteServiceConversation(chatServiceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceConversationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceConversation>>>
    
    export type DeleteServiceConversationMutationError = unknown

    /**
 * @summary Remove a conversation from your service
 */
export const useDeleteServiceConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversation>>, TError,{chatServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceConversation>>,
        TError,
        {chatServiceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a conversation from your service
 * @summary Fetch a conversation from your service
 */
export type fetchServiceConversationResponse200 = {
  data: ConversationsV1ServiceServiceConversation
  status: 200
}
    
export type fetchServiceConversationResponseSuccess = (fetchServiceConversationResponse200) & {
  headers: Headers;
};
;

export type fetchServiceConversationResponse = (fetchServiceConversationResponseSuccess)

export const getFetchServiceConversationUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${sid}`
}

export const fetchServiceConversation = async (chatServiceSid: string,
    sid: string, options?: RequestInit): Promise<fetchServiceConversationResponse> => {
  
  const res = await fetch(getFetchServiceConversationUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceConversationResponse
}





export const getFetchServiceConversationQueryKey = (chatServiceSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${sid}`
    ] as const;
    }

    
export const getFetchServiceConversationQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceConversation>>, TError = unknown>(chatServiceSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceConversationQueryKey(chatServiceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceConversation>>> = ({ signal }) => fetchServiceConversation(chatServiceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceConversationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceConversation>>>
export type FetchServiceConversationQueryError = unknown


/**
 * @summary Fetch a conversation from your service
 */

export function useFetchServiceConversation<TData = Awaited<ReturnType<typeof fetchServiceConversation>>, TError = unknown>(
 chatServiceSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceConversationQueryOptions(chatServiceSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add a new message to the conversation in a specific service
 * @summary Add a new message to the conversation in a specific service
 */
export type createServiceConversationMessageResponse201 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationMessage
  status: 201
}
    
export type createServiceConversationMessageResponseSuccess = (createServiceConversationMessageResponse201) & {
  headers: Headers;
};
;

export type createServiceConversationMessageResponse = (createServiceConversationMessageResponseSuccess)

export const getCreateServiceConversationMessageUrl = (chatServiceSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages`
}

export const createServiceConversationMessage = async (chatServiceSid: string,
    conversationSid: string,
    createServiceConversationMessageBody: CreateServiceConversationMessageBody, options?: RequestInit): Promise<createServiceConversationMessageResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(createServiceConversationMessageBody.Author !== undefined) {
 formUrlEncoded.append(`Author`, createServiceConversationMessageBody.Author)
 }
if(createServiceConversationMessageBody.Body !== undefined) {
 formUrlEncoded.append(`Body`, createServiceConversationMessageBody.Body)
 }
if(createServiceConversationMessageBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, createServiceConversationMessageBody.DateCreated)
 }
if(createServiceConversationMessageBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, createServiceConversationMessageBody.DateUpdated)
 }
if(createServiceConversationMessageBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createServiceConversationMessageBody.Attributes)
 }
if(createServiceConversationMessageBody.MediaSid !== undefined) {
 formUrlEncoded.append(`MediaSid`, createServiceConversationMessageBody.MediaSid)
 }
if(createServiceConversationMessageBody.ContentSid !== undefined) {
 formUrlEncoded.append(`ContentSid`, createServiceConversationMessageBody.ContentSid)
 }
if(createServiceConversationMessageBody.ContentVariables !== undefined) {
 formUrlEncoded.append(`ContentVariables`, createServiceConversationMessageBody.ContentVariables)
 }
if(createServiceConversationMessageBody.Subject !== undefined) {
 formUrlEncoded.append(`Subject`, createServiceConversationMessageBody.Subject)
 }

  const res = await fetch(getCreateServiceConversationMessageUrl(chatServiceSid,conversationSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceConversationMessageResponse
}




export const getCreateServiceConversationMessageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationMessageBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationMessageBody}, TContext> => {

const mutationKey = ['createServiceConversationMessage'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceConversationMessage>>, {chatServiceSid: string;conversationSid: string;data: CreateServiceConversationMessageBody}> = (props) => {
          const {chatServiceSid,conversationSid,data} = props ?? {};

          return  createServiceConversationMessage(chatServiceSid,conversationSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceConversationMessageMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceConversationMessage>>>
    export type CreateServiceConversationMessageMutationBody = CreateServiceConversationMessageBody
    export type CreateServiceConversationMessageMutationError = unknown

    /**
 * @summary Add a new message to the conversation in a specific service
 */
export const useCreateServiceConversationMessage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationMessageBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createServiceConversationMessage>>,
        TError,
        {chatServiceSid: string;conversationSid: string;data: CreateServiceConversationMessageBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceConversationMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all messages in the conversation
 * @summary Retrieve a list of all messages in the conversation
 */
export type listServiceConversationMessageResponse200 = {
  data: ListServiceConversationMessage200
  status: 200
}
    
export type listServiceConversationMessageResponseSuccess = (listServiceConversationMessageResponse200) & {
  headers: Headers;
};
;

export type listServiceConversationMessageResponse = (listServiceConversationMessageResponseSuccess)

export const getListServiceConversationMessageUrl = (chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationMessageParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages`
}

export const listServiceConversationMessage = async (chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationMessageParams, options?: RequestInit): Promise<listServiceConversationMessageResponse> => {
  
  const res = await fetch(getListServiceConversationMessageUrl(chatServiceSid,conversationSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceConversationMessageResponse
}





export const getListServiceConversationMessageQueryKey = (chatServiceSid?: string,
    conversationSid?: string,
    params?: ListServiceConversationMessageParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceConversationMessageQueryOptions = <TData = Awaited<ReturnType<typeof listServiceConversationMessage>>, TError = unknown>(chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationMessageParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationMessage>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceConversationMessageQueryKey(chatServiceSid,conversationSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceConversationMessage>>> = ({ signal }) => listServiceConversationMessage(chatServiceSid,conversationSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && conversationSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationMessage>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceConversationMessageQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceConversationMessage>>>
export type ListServiceConversationMessageQueryError = unknown


/**
 * @summary Retrieve a list of all messages in the conversation
 */

export function useListServiceConversationMessage<TData = Awaited<ReturnType<typeof listServiceConversationMessage>>, TError = unknown>(
 chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationMessageParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationMessage>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceConversationMessageQueryOptions(chatServiceSid,conversationSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing message in the conversation
 * @summary Update an existing message in the conversation
 */
export type updateServiceConversationMessageResponse200 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationMessage
  status: 200
}
    
export type updateServiceConversationMessageResponseSuccess = (updateServiceConversationMessageResponse200) & {
  headers: Headers;
};
;

export type updateServiceConversationMessageResponse = (updateServiceConversationMessageResponseSuccess)

export const getUpdateServiceConversationMessageUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${sid}`
}

export const updateServiceConversationMessage = async (chatServiceSid: string,
    conversationSid: string,
    sid: string,
    updateServiceConversationMessageBody: UpdateServiceConversationMessageBody, options?: RequestInit): Promise<updateServiceConversationMessageResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceConversationMessageBody.Author !== undefined) {
 formUrlEncoded.append(`Author`, updateServiceConversationMessageBody.Author)
 }
if(updateServiceConversationMessageBody.Body !== undefined) {
 formUrlEncoded.append(`Body`, updateServiceConversationMessageBody.Body)
 }
if(updateServiceConversationMessageBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, updateServiceConversationMessageBody.DateCreated)
 }
if(updateServiceConversationMessageBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, updateServiceConversationMessageBody.DateUpdated)
 }
if(updateServiceConversationMessageBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, updateServiceConversationMessageBody.Attributes)
 }
if(updateServiceConversationMessageBody.Subject !== undefined) {
 formUrlEncoded.append(`Subject`, updateServiceConversationMessageBody.Subject)
 }

  const res = await fetch(getUpdateServiceConversationMessageUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceConversationMessageResponse
}




export const getUpdateServiceConversationMessageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationMessageBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationMessageBody}, TContext> => {

const mutationKey = ['updateServiceConversationMessage'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceConversationMessage>>, {chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationMessageBody}> = (props) => {
          const {chatServiceSid,conversationSid,sid,data} = props ?? {};

          return  updateServiceConversationMessage(chatServiceSid,conversationSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceConversationMessageMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceConversationMessage>>>
    export type UpdateServiceConversationMessageMutationBody = UpdateServiceConversationMessageBody
    export type UpdateServiceConversationMessageMutationError = unknown

    /**
 * @summary Update an existing message in the conversation
 */
export const useUpdateServiceConversationMessage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationMessageBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceConversationMessage>>,
        TError,
        {chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationMessageBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceConversationMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a message from the conversation
 * @summary Remove a message from the conversation
 */
export type deleteServiceConversationMessageResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceConversationMessageResponseSuccess = (deleteServiceConversationMessageResponse204) & {
  headers: Headers;
};
;

export type deleteServiceConversationMessageResponse = (deleteServiceConversationMessageResponseSuccess)

export const getDeleteServiceConversationMessageUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${sid}`
}

export const deleteServiceConversationMessage = async (chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: RequestInit): Promise<deleteServiceConversationMessageResponse> => {
  
  const res = await fetch(getDeleteServiceConversationMessageUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceConversationMessageResponse
}




export const getDeleteServiceConversationMessageMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteServiceConversationMessage'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceConversationMessage>>, {chatServiceSid: string;conversationSid: string;sid: string}> = (props) => {
          const {chatServiceSid,conversationSid,sid} = props ?? {};

          return  deleteServiceConversationMessage(chatServiceSid,conversationSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceConversationMessageMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceConversationMessage>>>
    
    export type DeleteServiceConversationMessageMutationError = unknown

    /**
 * @summary Remove a message from the conversation
 */
export const useDeleteServiceConversationMessage = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationMessage>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceConversationMessage>>,
        TError,
        {chatServiceSid: string;conversationSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceConversationMessageMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a message from the conversation
 * @summary Fetch a message from the conversation
 */
export type fetchServiceConversationMessageResponse200 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationMessage
  status: 200
}
    
export type fetchServiceConversationMessageResponseSuccess = (fetchServiceConversationMessageResponse200) & {
  headers: Headers;
};
;

export type fetchServiceConversationMessageResponse = (fetchServiceConversationMessageResponseSuccess)

export const getFetchServiceConversationMessageUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${sid}`
}

export const fetchServiceConversationMessage = async (chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: RequestInit): Promise<fetchServiceConversationMessageResponse> => {
  
  const res = await fetch(getFetchServiceConversationMessageUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceConversationMessageResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceConversationMessageResponse
}





export const getFetchServiceConversationMessageQueryKey = (chatServiceSid?: string,
    conversationSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${sid}`
    ] as const;
    }

    
export const getFetchServiceConversationMessageQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceConversationMessage>>, TError = unknown>(chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationMessage>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceConversationMessageQueryKey(chatServiceSid,conversationSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceConversationMessage>>> = ({ signal }) => fetchServiceConversationMessage(chatServiceSid,conversationSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && conversationSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationMessage>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceConversationMessageQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceConversationMessage>>>
export type FetchServiceConversationMessageQueryError = unknown


/**
 * @summary Fetch a message from the conversation
 */

export function useFetchServiceConversationMessage<TData = Awaited<ReturnType<typeof fetchServiceConversationMessage>>, TError = unknown>(
 chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationMessage>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceConversationMessageQueryOptions(chatServiceSid,conversationSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Fetch the delivery and read receipts of the conversation message
 * @summary Fetch the delivery and read receipts of the conversation message
 */
export type fetchServiceConversationMessageReceiptResponse200 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationMessageServiceConversationMessageReceipt
  status: 200
}
    
export type fetchServiceConversationMessageReceiptResponseSuccess = (fetchServiceConversationMessageReceiptResponse200) & {
  headers: Headers;
};
;

export type fetchServiceConversationMessageReceiptResponse = (fetchServiceConversationMessageReceiptResponseSuccess)

export const getFetchServiceConversationMessageReceiptUrl = (chatServiceSid: string,
    conversationSid: string,
    messageSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${messageSid}/Receipts/${sid}`
}

export const fetchServiceConversationMessageReceipt = async (chatServiceSid: string,
    conversationSid: string,
    messageSid: string,
    sid: string, options?: RequestInit): Promise<fetchServiceConversationMessageReceiptResponse> => {
  
  const res = await fetch(getFetchServiceConversationMessageReceiptUrl(chatServiceSid,conversationSid,messageSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceConversationMessageReceiptResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceConversationMessageReceiptResponse
}





export const getFetchServiceConversationMessageReceiptQueryKey = (chatServiceSid?: string,
    conversationSid?: string,
    messageSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${messageSid}/Receipts/${sid}`
    ] as const;
    }

    
export const getFetchServiceConversationMessageReceiptQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceConversationMessageReceipt>>, TError = unknown>(chatServiceSid: string,
    conversationSid: string,
    messageSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationMessageReceipt>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceConversationMessageReceiptQueryKey(chatServiceSid,conversationSid,messageSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceConversationMessageReceipt>>> = ({ signal }) => fetchServiceConversationMessageReceipt(chatServiceSid,conversationSid,messageSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && conversationSid && messageSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationMessageReceipt>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceConversationMessageReceiptQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceConversationMessageReceipt>>>
export type FetchServiceConversationMessageReceiptQueryError = unknown


/**
 * @summary Fetch the delivery and read receipts of the conversation message
 */

export function useFetchServiceConversationMessageReceipt<TData = Awaited<ReturnType<typeof fetchServiceConversationMessageReceipt>>, TError = unknown>(
 chatServiceSid: string,
    conversationSid: string,
    messageSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationMessageReceipt>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceConversationMessageReceiptQueryOptions(chatServiceSid,conversationSid,messageSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all delivery and read receipts of the conversation message
 * @summary Retrieve a list of all delivery and read receipts of the conversation message
 */
export type listServiceConversationMessageReceiptResponse200 = {
  data: ListServiceConversationMessageReceipt200
  status: 200
}
    
export type listServiceConversationMessageReceiptResponseSuccess = (listServiceConversationMessageReceiptResponse200) & {
  headers: Headers;
};
;

export type listServiceConversationMessageReceiptResponse = (listServiceConversationMessageReceiptResponseSuccess)

export const getListServiceConversationMessageReceiptUrl = (chatServiceSid: string,
    conversationSid: string,
    messageSid: string,
    params?: ListServiceConversationMessageReceiptParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${messageSid}/Receipts?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${messageSid}/Receipts`
}

export const listServiceConversationMessageReceipt = async (chatServiceSid: string,
    conversationSid: string,
    messageSid: string,
    params?: ListServiceConversationMessageReceiptParams, options?: RequestInit): Promise<listServiceConversationMessageReceiptResponse> => {
  
  const res = await fetch(getListServiceConversationMessageReceiptUrl(chatServiceSid,conversationSid,messageSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceConversationMessageReceiptResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceConversationMessageReceiptResponse
}





export const getListServiceConversationMessageReceiptQueryKey = (chatServiceSid?: string,
    conversationSid?: string,
    messageSid?: string,
    params?: ListServiceConversationMessageReceiptParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Messages/${messageSid}/Receipts`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceConversationMessageReceiptQueryOptions = <TData = Awaited<ReturnType<typeof listServiceConversationMessageReceipt>>, TError = unknown>(chatServiceSid: string,
    conversationSid: string,
    messageSid: string,
    params?: ListServiceConversationMessageReceiptParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationMessageReceipt>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceConversationMessageReceiptQueryKey(chatServiceSid,conversationSid,messageSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceConversationMessageReceipt>>> = ({ signal }) => listServiceConversationMessageReceipt(chatServiceSid,conversationSid,messageSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && conversationSid && messageSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationMessageReceipt>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceConversationMessageReceiptQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceConversationMessageReceipt>>>
export type ListServiceConversationMessageReceiptQueryError = unknown


/**
 * @summary Retrieve a list of all delivery and read receipts of the conversation message
 */

export function useListServiceConversationMessageReceipt<TData = Awaited<ReturnType<typeof listServiceConversationMessageReceipt>>, TError = unknown>(
 chatServiceSid: string,
    conversationSid: string,
    messageSid: string,
    params?: ListServiceConversationMessageReceiptParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationMessageReceipt>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceConversationMessageReceiptQueryOptions(chatServiceSid,conversationSid,messageSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add a new participant to the conversation in a specific service
 * @summary Add a new participant to the conversation in a specific service
 */
export type createServiceConversationParticipantResponse201 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationParticipant
  status: 201
}
    
export type createServiceConversationParticipantResponseSuccess = (createServiceConversationParticipantResponse201) & {
  headers: Headers;
};
;

export type createServiceConversationParticipantResponse = (createServiceConversationParticipantResponseSuccess)

export const getCreateServiceConversationParticipantUrl = (chatServiceSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Participants`
}

export const createServiceConversationParticipant = async (chatServiceSid: string,
    conversationSid: string,
    createServiceConversationParticipantBody: CreateServiceConversationParticipantBody, options?: RequestInit): Promise<createServiceConversationParticipantResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(createServiceConversationParticipantBody.Identity !== undefined) {
 formUrlEncoded.append(`Identity`, createServiceConversationParticipantBody.Identity)
 }
if(createServiceConversationParticipantBody['MessagingBinding.Address'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.Address`, createServiceConversationParticipantBody['MessagingBinding.Address'])
 }
if(createServiceConversationParticipantBody['MessagingBinding.ProxyAddress'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.ProxyAddress`, createServiceConversationParticipantBody['MessagingBinding.ProxyAddress'])
 }
if(createServiceConversationParticipantBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, createServiceConversationParticipantBody.DateCreated)
 }
if(createServiceConversationParticipantBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, createServiceConversationParticipantBody.DateUpdated)
 }
if(createServiceConversationParticipantBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createServiceConversationParticipantBody.Attributes)
 }
if(createServiceConversationParticipantBody['MessagingBinding.ProjectedAddress'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.ProjectedAddress`, createServiceConversationParticipantBody['MessagingBinding.ProjectedAddress'])
 }
if(createServiceConversationParticipantBody.RoleSid !== undefined) {
 formUrlEncoded.append(`RoleSid`, createServiceConversationParticipantBody.RoleSid)
 }

  const res = await fetch(getCreateServiceConversationParticipantUrl(chatServiceSid,conversationSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceConversationParticipantResponse
}




export const getCreateServiceConversationParticipantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationParticipantBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationParticipantBody}, TContext> => {

const mutationKey = ['createServiceConversationParticipant'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceConversationParticipant>>, {chatServiceSid: string;conversationSid: string;data: CreateServiceConversationParticipantBody}> = (props) => {
          const {chatServiceSid,conversationSid,data} = props ?? {};

          return  createServiceConversationParticipant(chatServiceSid,conversationSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceConversationParticipantMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceConversationParticipant>>>
    export type CreateServiceConversationParticipantMutationBody = CreateServiceConversationParticipantBody
    export type CreateServiceConversationParticipantMutationError = unknown

    /**
 * @summary Add a new participant to the conversation in a specific service
 */
export const useCreateServiceConversationParticipant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationParticipantBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createServiceConversationParticipant>>,
        TError,
        {chatServiceSid: string;conversationSid: string;data: CreateServiceConversationParticipantBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceConversationParticipantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all participants of the conversation
 * @summary Retrieve a list of all participants of the conversation
 */
export type listServiceConversationParticipantResponse200 = {
  data: ListServiceConversationParticipant200
  status: 200
}
    
export type listServiceConversationParticipantResponseSuccess = (listServiceConversationParticipantResponse200) & {
  headers: Headers;
};
;

export type listServiceConversationParticipantResponse = (listServiceConversationParticipantResponseSuccess)

export const getListServiceConversationParticipantUrl = (chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationParticipantParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Participants?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Participants`
}

export const listServiceConversationParticipant = async (chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationParticipantParams, options?: RequestInit): Promise<listServiceConversationParticipantResponse> => {
  
  const res = await fetch(getListServiceConversationParticipantUrl(chatServiceSid,conversationSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceConversationParticipantResponse
}





export const getListServiceConversationParticipantQueryKey = (chatServiceSid?: string,
    conversationSid?: string,
    params?: ListServiceConversationParticipantParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Participants`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceConversationParticipantQueryOptions = <TData = Awaited<ReturnType<typeof listServiceConversationParticipant>>, TError = unknown>(chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationParticipantParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationParticipant>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceConversationParticipantQueryKey(chatServiceSid,conversationSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceConversationParticipant>>> = ({ signal }) => listServiceConversationParticipant(chatServiceSid,conversationSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && conversationSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationParticipant>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceConversationParticipantQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceConversationParticipant>>>
export type ListServiceConversationParticipantQueryError = unknown


/**
 * @summary Retrieve a list of all participants of the conversation
 */

export function useListServiceConversationParticipant<TData = Awaited<ReturnType<typeof listServiceConversationParticipant>>, TError = unknown>(
 chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationParticipantParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationParticipant>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceConversationParticipantQueryOptions(chatServiceSid,conversationSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing participant in the conversation
 * @summary Update an existing participant in the conversation
 */
export type updateServiceConversationParticipantResponse200 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationParticipant
  status: 200
}
    
export type updateServiceConversationParticipantResponseSuccess = (updateServiceConversationParticipantResponse200) & {
  headers: Headers;
};
;

export type updateServiceConversationParticipantResponse = (updateServiceConversationParticipantResponseSuccess)

export const getUpdateServiceConversationParticipantUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Participants/${sid}`
}

export const updateServiceConversationParticipant = async (chatServiceSid: string,
    conversationSid: string,
    sid: string,
    updateServiceConversationParticipantBody: UpdateServiceConversationParticipantBody, options?: RequestInit): Promise<updateServiceConversationParticipantResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceConversationParticipantBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, updateServiceConversationParticipantBody.DateCreated)
 }
if(updateServiceConversationParticipantBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, updateServiceConversationParticipantBody.DateUpdated)
 }
if(updateServiceConversationParticipantBody.Identity !== undefined) {
 formUrlEncoded.append(`Identity`, updateServiceConversationParticipantBody.Identity)
 }
if(updateServiceConversationParticipantBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, updateServiceConversationParticipantBody.Attributes)
 }
if(updateServiceConversationParticipantBody.RoleSid !== undefined) {
 formUrlEncoded.append(`RoleSid`, updateServiceConversationParticipantBody.RoleSid)
 }
if(updateServiceConversationParticipantBody['MessagingBinding.ProxyAddress'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.ProxyAddress`, updateServiceConversationParticipantBody['MessagingBinding.ProxyAddress'])
 }
if(updateServiceConversationParticipantBody['MessagingBinding.ProjectedAddress'] !== undefined) {
 formUrlEncoded.append(`MessagingBinding.ProjectedAddress`, updateServiceConversationParticipantBody['MessagingBinding.ProjectedAddress'])
 }
if(updateServiceConversationParticipantBody.LastReadMessageIndex !== undefined && updateServiceConversationParticipantBody.LastReadMessageIndex !== null) {
 formUrlEncoded.append(`LastReadMessageIndex`, updateServiceConversationParticipantBody.LastReadMessageIndex.toString())
 }
if(updateServiceConversationParticipantBody.LastReadTimestamp !== undefined) {
 formUrlEncoded.append(`LastReadTimestamp`, updateServiceConversationParticipantBody.LastReadTimestamp)
 }

  const res = await fetch(getUpdateServiceConversationParticipantUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceConversationParticipantResponse
}




export const getUpdateServiceConversationParticipantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationParticipantBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationParticipantBody}, TContext> => {

const mutationKey = ['updateServiceConversationParticipant'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceConversationParticipant>>, {chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationParticipantBody}> = (props) => {
          const {chatServiceSid,conversationSid,sid,data} = props ?? {};

          return  updateServiceConversationParticipant(chatServiceSid,conversationSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceConversationParticipantMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceConversationParticipant>>>
    export type UpdateServiceConversationParticipantMutationBody = UpdateServiceConversationParticipantBody
    export type UpdateServiceConversationParticipantMutationError = unknown

    /**
 * @summary Update an existing participant in the conversation
 */
export const useUpdateServiceConversationParticipant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationParticipantBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceConversationParticipant>>,
        TError,
        {chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationParticipantBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceConversationParticipantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a participant from the conversation
 * @summary Remove a participant from the conversation
 */
export type deleteServiceConversationParticipantResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceConversationParticipantResponseSuccess = (deleteServiceConversationParticipantResponse204) & {
  headers: Headers;
};
;

export type deleteServiceConversationParticipantResponse = (deleteServiceConversationParticipantResponseSuccess)

export const getDeleteServiceConversationParticipantUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Participants/${sid}`
}

export const deleteServiceConversationParticipant = async (chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: RequestInit): Promise<deleteServiceConversationParticipantResponse> => {
  
  const res = await fetch(getDeleteServiceConversationParticipantUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceConversationParticipantResponse
}




export const getDeleteServiceConversationParticipantMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteServiceConversationParticipant'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceConversationParticipant>>, {chatServiceSid: string;conversationSid: string;sid: string}> = (props) => {
          const {chatServiceSid,conversationSid,sid} = props ?? {};

          return  deleteServiceConversationParticipant(chatServiceSid,conversationSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceConversationParticipantMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceConversationParticipant>>>
    
    export type DeleteServiceConversationParticipantMutationError = unknown

    /**
 * @summary Remove a participant from the conversation
 */
export const useDeleteServiceConversationParticipant = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationParticipant>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceConversationParticipant>>,
        TError,
        {chatServiceSid: string;conversationSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceConversationParticipantMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a participant of the conversation
 * @summary Fetch a participant of the conversation
 */
export type fetchServiceConversationParticipantResponse200 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationParticipant
  status: 200
}
    
export type fetchServiceConversationParticipantResponseSuccess = (fetchServiceConversationParticipantResponse200) & {
  headers: Headers;
};
;

export type fetchServiceConversationParticipantResponse = (fetchServiceConversationParticipantResponseSuccess)

export const getFetchServiceConversationParticipantUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Participants/${sid}`
}

export const fetchServiceConversationParticipant = async (chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: RequestInit): Promise<fetchServiceConversationParticipantResponse> => {
  
  const res = await fetch(getFetchServiceConversationParticipantUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceConversationParticipantResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceConversationParticipantResponse
}





export const getFetchServiceConversationParticipantQueryKey = (chatServiceSid?: string,
    conversationSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Participants/${sid}`
    ] as const;
    }

    
export const getFetchServiceConversationParticipantQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceConversationParticipant>>, TError = unknown>(chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationParticipant>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceConversationParticipantQueryKey(chatServiceSid,conversationSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceConversationParticipant>>> = ({ signal }) => fetchServiceConversationParticipant(chatServiceSid,conversationSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && conversationSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationParticipant>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceConversationParticipantQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceConversationParticipant>>>
export type FetchServiceConversationParticipantQueryError = unknown


/**
 * @summary Fetch a participant of the conversation
 */

export function useFetchServiceConversationParticipant<TData = Awaited<ReturnType<typeof fetchServiceConversationParticipant>>, TError = unknown>(
 chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationParticipant>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceConversationParticipantQueryOptions(chatServiceSid,conversationSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new webhook scoped to the conversation in a specific service
 * @summary Create a new webhook scoped to the conversation in a specific service
 */
export type createServiceConversationScopedWebhookResponse201 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
  status: 201
}
    
export type createServiceConversationScopedWebhookResponseSuccess = (createServiceConversationScopedWebhookResponse201) & {
  headers: Headers;
};
;

export type createServiceConversationScopedWebhookResponse = (createServiceConversationScopedWebhookResponseSuccess)

export const getCreateServiceConversationScopedWebhookUrl = (chatServiceSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Webhooks`
}

export const createServiceConversationScopedWebhook = async (chatServiceSid: string,
    conversationSid: string,
    createServiceConversationScopedWebhookBody: CreateServiceConversationScopedWebhookBody, options?: RequestInit): Promise<createServiceConversationScopedWebhookResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Target`, createServiceConversationScopedWebhookBody.Target)
if(createServiceConversationScopedWebhookBody['Configuration.Url'] !== undefined) {
 formUrlEncoded.append(`Configuration.Url`, createServiceConversationScopedWebhookBody['Configuration.Url'])
 }
if(createServiceConversationScopedWebhookBody['Configuration.Method'] !== undefined) {
 formUrlEncoded.append(`Configuration.Method`, createServiceConversationScopedWebhookBody['Configuration.Method'])
 }
if(createServiceConversationScopedWebhookBody['Configuration.Filters'] !== undefined) {
 createServiceConversationScopedWebhookBody['Configuration.Filters'].forEach(value => formUrlEncoded.append(`Configuration.Filters`, value));
 }
if(createServiceConversationScopedWebhookBody['Configuration.Triggers'] !== undefined) {
 createServiceConversationScopedWebhookBody['Configuration.Triggers'].forEach(value => formUrlEncoded.append(`Configuration.Triggers`, value));
 }
if(createServiceConversationScopedWebhookBody['Configuration.FlowSid'] !== undefined) {
 formUrlEncoded.append(`Configuration.FlowSid`, createServiceConversationScopedWebhookBody['Configuration.FlowSid'])
 }
if(createServiceConversationScopedWebhookBody['Configuration.ReplayAfter'] !== undefined) {
 formUrlEncoded.append(`Configuration.ReplayAfter`, createServiceConversationScopedWebhookBody['Configuration.ReplayAfter'].toString())
 }

  const res = await fetch(getCreateServiceConversationScopedWebhookUrl(chatServiceSid,conversationSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceConversationScopedWebhookResponse
}




export const getCreateServiceConversationScopedWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationScopedWebhookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationScopedWebhookBody}, TContext> => {

const mutationKey = ['createServiceConversationScopedWebhook'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceConversationScopedWebhook>>, {chatServiceSid: string;conversationSid: string;data: CreateServiceConversationScopedWebhookBody}> = (props) => {
          const {chatServiceSid,conversationSid,data} = props ?? {};

          return  createServiceConversationScopedWebhook(chatServiceSid,conversationSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceConversationScopedWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceConversationScopedWebhook>>>
    export type CreateServiceConversationScopedWebhookMutationBody = CreateServiceConversationScopedWebhookBody
    export type CreateServiceConversationScopedWebhookMutationError = unknown

    /**
 * @summary Create a new webhook scoped to the conversation in a specific service
 */
export const useCreateServiceConversationScopedWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;data: CreateServiceConversationScopedWebhookBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createServiceConversationScopedWebhook>>,
        TError,
        {chatServiceSid: string;conversationSid: string;data: CreateServiceConversationScopedWebhookBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceConversationScopedWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all webhooks scoped to the conversation
 * @summary Retrieve a list of all webhooks scoped to the conversation
 */
export type listServiceConversationScopedWebhookResponse200 = {
  data: ListServiceConversationScopedWebhook200
  status: 200
}
    
export type listServiceConversationScopedWebhookResponseSuccess = (listServiceConversationScopedWebhookResponse200) & {
  headers: Headers;
};
;

export type listServiceConversationScopedWebhookResponse = (listServiceConversationScopedWebhookResponseSuccess)

export const getListServiceConversationScopedWebhookUrl = (chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationScopedWebhookParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Webhooks?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Webhooks`
}

export const listServiceConversationScopedWebhook = async (chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationScopedWebhookParams, options?: RequestInit): Promise<listServiceConversationScopedWebhookResponse> => {
  
  const res = await fetch(getListServiceConversationScopedWebhookUrl(chatServiceSid,conversationSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceConversationScopedWebhookResponse
}





export const getListServiceConversationScopedWebhookQueryKey = (chatServiceSid?: string,
    conversationSid?: string,
    params?: ListServiceConversationScopedWebhookParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Webhooks`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceConversationScopedWebhookQueryOptions = <TData = Awaited<ReturnType<typeof listServiceConversationScopedWebhook>>, TError = unknown>(chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationScopedWebhookParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationScopedWebhook>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceConversationScopedWebhookQueryKey(chatServiceSid,conversationSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceConversationScopedWebhook>>> = ({ signal }) => listServiceConversationScopedWebhook(chatServiceSid,conversationSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && conversationSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationScopedWebhook>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceConversationScopedWebhookQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceConversationScopedWebhook>>>
export type ListServiceConversationScopedWebhookQueryError = unknown


/**
 * @summary Retrieve a list of all webhooks scoped to the conversation
 */

export function useListServiceConversationScopedWebhook<TData = Awaited<ReturnType<typeof listServiceConversationScopedWebhook>>, TError = unknown>(
 chatServiceSid: string,
    conversationSid: string,
    params?: ListServiceConversationScopedWebhookParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceConversationScopedWebhook>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceConversationScopedWebhookQueryOptions(chatServiceSid,conversationSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing conversation-scoped webhook
 * @summary Update an existing conversation-scoped webhook
 */
export type updateServiceConversationScopedWebhookResponse200 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
  status: 200
}
    
export type updateServiceConversationScopedWebhookResponseSuccess = (updateServiceConversationScopedWebhookResponse200) & {
  headers: Headers;
};
;

export type updateServiceConversationScopedWebhookResponse = (updateServiceConversationScopedWebhookResponseSuccess)

export const getUpdateServiceConversationScopedWebhookUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Webhooks/${sid}`
}

export const updateServiceConversationScopedWebhook = async (chatServiceSid: string,
    conversationSid: string,
    sid: string,
    updateServiceConversationScopedWebhookBody: UpdateServiceConversationScopedWebhookBody, options?: RequestInit): Promise<updateServiceConversationScopedWebhookResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceConversationScopedWebhookBody['Configuration.Url'] !== undefined) {
 formUrlEncoded.append(`Configuration.Url`, updateServiceConversationScopedWebhookBody['Configuration.Url'])
 }
if(updateServiceConversationScopedWebhookBody['Configuration.Method'] !== undefined) {
 formUrlEncoded.append(`Configuration.Method`, updateServiceConversationScopedWebhookBody['Configuration.Method'])
 }
if(updateServiceConversationScopedWebhookBody['Configuration.Filters'] !== undefined) {
 updateServiceConversationScopedWebhookBody['Configuration.Filters'].forEach(value => formUrlEncoded.append(`Configuration.Filters`, value));
 }
if(updateServiceConversationScopedWebhookBody['Configuration.Triggers'] !== undefined) {
 updateServiceConversationScopedWebhookBody['Configuration.Triggers'].forEach(value => formUrlEncoded.append(`Configuration.Triggers`, value));
 }
if(updateServiceConversationScopedWebhookBody['Configuration.FlowSid'] !== undefined) {
 formUrlEncoded.append(`Configuration.FlowSid`, updateServiceConversationScopedWebhookBody['Configuration.FlowSid'])
 }

  const res = await fetch(getUpdateServiceConversationScopedWebhookUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceConversationScopedWebhookResponse
}




export const getUpdateServiceConversationScopedWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationScopedWebhookBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationScopedWebhookBody}, TContext> => {

const mutationKey = ['updateServiceConversationScopedWebhook'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceConversationScopedWebhook>>, {chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationScopedWebhookBody}> = (props) => {
          const {chatServiceSid,conversationSid,sid,data} = props ?? {};

          return  updateServiceConversationScopedWebhook(chatServiceSid,conversationSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceConversationScopedWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceConversationScopedWebhook>>>
    export type UpdateServiceConversationScopedWebhookMutationBody = UpdateServiceConversationScopedWebhookBody
    export type UpdateServiceConversationScopedWebhookMutationError = unknown

    /**
 * @summary Update an existing conversation-scoped webhook
 */
export const useUpdateServiceConversationScopedWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationScopedWebhookBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceConversationScopedWebhook>>,
        TError,
        {chatServiceSid: string;conversationSid: string;sid: string;data: UpdateServiceConversationScopedWebhookBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceConversationScopedWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove an existing webhook scoped to the conversation
 * @summary Remove an existing webhook scoped to the conversation
 */
export type deleteServiceConversationScopedWebhookResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceConversationScopedWebhookResponseSuccess = (deleteServiceConversationScopedWebhookResponse204) & {
  headers: Headers;
};
;

export type deleteServiceConversationScopedWebhookResponse = (deleteServiceConversationScopedWebhookResponseSuccess)

export const getDeleteServiceConversationScopedWebhookUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Webhooks/${sid}`
}

export const deleteServiceConversationScopedWebhook = async (chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: RequestInit): Promise<deleteServiceConversationScopedWebhookResponse> => {
  
  const res = await fetch(getDeleteServiceConversationScopedWebhookUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceConversationScopedWebhookResponse
}




export const getDeleteServiceConversationScopedWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteServiceConversationScopedWebhook'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceConversationScopedWebhook>>, {chatServiceSid: string;conversationSid: string;sid: string}> = (props) => {
          const {chatServiceSid,conversationSid,sid} = props ?? {};

          return  deleteServiceConversationScopedWebhook(chatServiceSid,conversationSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceConversationScopedWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceConversationScopedWebhook>>>
    
    export type DeleteServiceConversationScopedWebhookMutationError = unknown

    /**
 * @summary Remove an existing webhook scoped to the conversation
 */
export const useDeleteServiceConversationScopedWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceConversationScopedWebhook>>, TError,{chatServiceSid: string;conversationSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceConversationScopedWebhook>>,
        TError,
        {chatServiceSid: string;conversationSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceConversationScopedWebhookMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch the configuration of a conversation-scoped webhook
 * @summary Fetch the configuration of a conversation-scoped webhook
 */
export type fetchServiceConversationScopedWebhookResponse200 = {
  data: ConversationsV1ServiceServiceConversationServiceConversationScopedWebhook
  status: 200
}
    
export type fetchServiceConversationScopedWebhookResponseSuccess = (fetchServiceConversationScopedWebhookResponse200) & {
  headers: Headers;
};
;

export type fetchServiceConversationScopedWebhookResponse = (fetchServiceConversationScopedWebhookResponseSuccess)

export const getFetchServiceConversationScopedWebhookUrl = (chatServiceSid: string,
    conversationSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Webhooks/${sid}`
}

export const fetchServiceConversationScopedWebhook = async (chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: RequestInit): Promise<fetchServiceConversationScopedWebhookResponse> => {
  
  const res = await fetch(getFetchServiceConversationScopedWebhookUrl(chatServiceSid,conversationSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceConversationScopedWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceConversationScopedWebhookResponse
}





export const getFetchServiceConversationScopedWebhookQueryKey = (chatServiceSid?: string,
    conversationSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Conversations/${conversationSid}/Webhooks/${sid}`
    ] as const;
    }

    
export const getFetchServiceConversationScopedWebhookQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceConversationScopedWebhook>>, TError = unknown>(chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationScopedWebhook>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceConversationScopedWebhookQueryKey(chatServiceSid,conversationSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceConversationScopedWebhook>>> = ({ signal }) => fetchServiceConversationScopedWebhook(chatServiceSid,conversationSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && conversationSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationScopedWebhook>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceConversationScopedWebhookQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceConversationScopedWebhook>>>
export type FetchServiceConversationScopedWebhookQueryError = unknown


/**
 * @summary Fetch the configuration of a conversation-scoped webhook
 */

export function useFetchServiceConversationScopedWebhook<TData = Awaited<ReturnType<typeof fetchServiceConversationScopedWebhook>>, TError = unknown>(
 chatServiceSid: string,
    conversationSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceConversationScopedWebhook>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceConversationScopedWebhookQueryOptions(chatServiceSid,conversationSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new conversation with the list of participants in your account's default service
 * @summary Create a new conversation with the list of participants in your account's default service
 */
export type createServiceConversationWithParticipantsResponse201 = {
  data: ConversationsV1ServiceServiceConversationWithParticipants
  status: 201
}

export type createServiceConversationWithParticipantsResponse202 = {
  data: ConversationsV1ServiceServiceConversationWithParticipants
  status: 202
}
    
export type createServiceConversationWithParticipantsResponseSuccess = (createServiceConversationWithParticipantsResponse201 | createServiceConversationWithParticipantsResponse202) & {
  headers: Headers;
};
;

export type createServiceConversationWithParticipantsResponse = (createServiceConversationWithParticipantsResponseSuccess)

export const getCreateServiceConversationWithParticipantsUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/ConversationWithParticipants`
}

export const createServiceConversationWithParticipants = async (chatServiceSid: string,
    createServiceConversationWithParticipantsBody: CreateServiceConversationWithParticipantsBody, options?: RequestInit): Promise<createServiceConversationWithParticipantsResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(createServiceConversationWithParticipantsBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, createServiceConversationWithParticipantsBody.FriendlyName)
 }
if(createServiceConversationWithParticipantsBody.UniqueName !== undefined) {
 formUrlEncoded.append(`UniqueName`, createServiceConversationWithParticipantsBody.UniqueName)
 }
if(createServiceConversationWithParticipantsBody.DateCreated !== undefined) {
 formUrlEncoded.append(`DateCreated`, createServiceConversationWithParticipantsBody.DateCreated)
 }
if(createServiceConversationWithParticipantsBody.DateUpdated !== undefined) {
 formUrlEncoded.append(`DateUpdated`, createServiceConversationWithParticipantsBody.DateUpdated)
 }
if(createServiceConversationWithParticipantsBody.MessagingServiceSid !== undefined) {
 formUrlEncoded.append(`MessagingServiceSid`, createServiceConversationWithParticipantsBody.MessagingServiceSid)
 }
if(createServiceConversationWithParticipantsBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createServiceConversationWithParticipantsBody.Attributes)
 }
if(createServiceConversationWithParticipantsBody.State !== undefined) {
 formUrlEncoded.append(`State`, createServiceConversationWithParticipantsBody.State)
 }
if(createServiceConversationWithParticipantsBody['Timers.Inactive'] !== undefined) {
 formUrlEncoded.append(`Timers.Inactive`, createServiceConversationWithParticipantsBody['Timers.Inactive'])
 }
if(createServiceConversationWithParticipantsBody['Timers.Closed'] !== undefined) {
 formUrlEncoded.append(`Timers.Closed`, createServiceConversationWithParticipantsBody['Timers.Closed'])
 }
if(createServiceConversationWithParticipantsBody['Bindings.Email.Address'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Address`, createServiceConversationWithParticipantsBody['Bindings.Email.Address'])
 }
if(createServiceConversationWithParticipantsBody['Bindings.Email.Name'] !== undefined) {
 formUrlEncoded.append(`Bindings.Email.Name`, createServiceConversationWithParticipantsBody['Bindings.Email.Name'])
 }
if(createServiceConversationWithParticipantsBody.Participant !== undefined) {
 createServiceConversationWithParticipantsBody.Participant.forEach(value => formUrlEncoded.append(`Participant`, value));
 }

  const res = await fetch(getCreateServiceConversationWithParticipantsUrl(chatServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceConversationWithParticipantsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceConversationWithParticipantsResponse
}




export const getCreateServiceConversationWithParticipantsMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationWithParticipants>>, TError,{chatServiceSid: string;data: CreateServiceConversationWithParticipantsBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationWithParticipants>>, TError,{chatServiceSid: string;data: CreateServiceConversationWithParticipantsBody}, TContext> => {

const mutationKey = ['createServiceConversationWithParticipants'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceConversationWithParticipants>>, {chatServiceSid: string;data: CreateServiceConversationWithParticipantsBody}> = (props) => {
          const {chatServiceSid,data} = props ?? {};

          return  createServiceConversationWithParticipants(chatServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceConversationWithParticipantsMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceConversationWithParticipants>>>
    export type CreateServiceConversationWithParticipantsMutationBody = CreateServiceConversationWithParticipantsBody
    export type CreateServiceConversationWithParticipantsMutationError = unknown

    /**
 * @summary Create a new conversation with the list of participants in your account's default service
 */
export const useCreateServiceConversationWithParticipants = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceConversationWithParticipants>>, TError,{chatServiceSid: string;data: CreateServiceConversationWithParticipantsBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createServiceConversationWithParticipants>>,
        TError,
        {chatServiceSid: string;data: CreateServiceConversationWithParticipantsBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceConversationWithParticipantsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Update push notification service settings
 * @summary Update push notification service settings
 */
export type updateServiceNotificationResponse200 = {
  data: ConversationsV1ServiceServiceConfigurationServiceNotification
  status: 200
}
    
export type updateServiceNotificationResponseSuccess = (updateServiceNotificationResponse200) & {
  headers: Headers;
};
;

export type updateServiceNotificationResponse = (updateServiceNotificationResponseSuccess)

export const getUpdateServiceNotificationUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration/Notifications`
}

export const updateServiceNotification = async (chatServiceSid: string,
    updateServiceNotificationBody: UpdateServiceNotificationBody, options?: RequestInit): Promise<updateServiceNotificationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceNotificationBody.LogEnabled !== undefined) {
 formUrlEncoded.append(`LogEnabled`, updateServiceNotificationBody.LogEnabled.toString())
 }
if(updateServiceNotificationBody['NewMessage.Enabled'] !== undefined) {
 formUrlEncoded.append(`NewMessage.Enabled`, updateServiceNotificationBody['NewMessage.Enabled'].toString())
 }
if(updateServiceNotificationBody['NewMessage.Template'] !== undefined) {
 formUrlEncoded.append(`NewMessage.Template`, updateServiceNotificationBody['NewMessage.Template'])
 }
if(updateServiceNotificationBody['NewMessage.Sound'] !== undefined) {
 formUrlEncoded.append(`NewMessage.Sound`, updateServiceNotificationBody['NewMessage.Sound'])
 }
if(updateServiceNotificationBody['NewMessage.BadgeCountEnabled'] !== undefined) {
 formUrlEncoded.append(`NewMessage.BadgeCountEnabled`, updateServiceNotificationBody['NewMessage.BadgeCountEnabled'].toString())
 }
if(updateServiceNotificationBody['AddedToConversation.Enabled'] !== undefined) {
 formUrlEncoded.append(`AddedToConversation.Enabled`, updateServiceNotificationBody['AddedToConversation.Enabled'].toString())
 }
if(updateServiceNotificationBody['AddedToConversation.Template'] !== undefined) {
 formUrlEncoded.append(`AddedToConversation.Template`, updateServiceNotificationBody['AddedToConversation.Template'])
 }
if(updateServiceNotificationBody['AddedToConversation.Sound'] !== undefined) {
 formUrlEncoded.append(`AddedToConversation.Sound`, updateServiceNotificationBody['AddedToConversation.Sound'])
 }
if(updateServiceNotificationBody['RemovedFromConversation.Enabled'] !== undefined) {
 formUrlEncoded.append(`RemovedFromConversation.Enabled`, updateServiceNotificationBody['RemovedFromConversation.Enabled'].toString())
 }
if(updateServiceNotificationBody['RemovedFromConversation.Template'] !== undefined) {
 formUrlEncoded.append(`RemovedFromConversation.Template`, updateServiceNotificationBody['RemovedFromConversation.Template'])
 }
if(updateServiceNotificationBody['RemovedFromConversation.Sound'] !== undefined) {
 formUrlEncoded.append(`RemovedFromConversation.Sound`, updateServiceNotificationBody['RemovedFromConversation.Sound'])
 }
if(updateServiceNotificationBody['NewMessage.WithMedia.Enabled'] !== undefined) {
 formUrlEncoded.append(`NewMessage.WithMedia.Enabled`, updateServiceNotificationBody['NewMessage.WithMedia.Enabled'].toString())
 }
if(updateServiceNotificationBody['NewMessage.WithMedia.Template'] !== undefined) {
 formUrlEncoded.append(`NewMessage.WithMedia.Template`, updateServiceNotificationBody['NewMessage.WithMedia.Template'])
 }

  const res = await fetch(getUpdateServiceNotificationUrl(chatServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceNotificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceNotificationResponse
}




export const getUpdateServiceNotificationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceNotification>>, TError,{chatServiceSid: string;data: UpdateServiceNotificationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceNotification>>, TError,{chatServiceSid: string;data: UpdateServiceNotificationBody}, TContext> => {

const mutationKey = ['updateServiceNotification'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceNotification>>, {chatServiceSid: string;data: UpdateServiceNotificationBody}> = (props) => {
          const {chatServiceSid,data} = props ?? {};

          return  updateServiceNotification(chatServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceNotificationMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceNotification>>>
    export type UpdateServiceNotificationMutationBody = UpdateServiceNotificationBody
    export type UpdateServiceNotificationMutationError = unknown

    /**
 * @summary Update push notification service settings
 */
export const useUpdateServiceNotification = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceNotification>>, TError,{chatServiceSid: string;data: UpdateServiceNotificationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceNotification>>,
        TError,
        {chatServiceSid: string;data: UpdateServiceNotificationBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceNotificationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch push notification service settings
 * @summary Fetch push notification service settings
 */
export type fetchServiceNotificationResponse200 = {
  data: ConversationsV1ServiceServiceConfigurationServiceNotification
  status: 200
}
    
export type fetchServiceNotificationResponseSuccess = (fetchServiceNotificationResponse200) & {
  headers: Headers;
};
;

export type fetchServiceNotificationResponse = (fetchServiceNotificationResponseSuccess)

export const getFetchServiceNotificationUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration/Notifications`
}

export const fetchServiceNotification = async (chatServiceSid: string, options?: RequestInit): Promise<fetchServiceNotificationResponse> => {
  
  const res = await fetch(getFetchServiceNotificationUrl(chatServiceSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceNotificationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceNotificationResponse
}





export const getFetchServiceNotificationQueryKey = (chatServiceSid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration/Notifications`
    ] as const;
    }

    
export const getFetchServiceNotificationQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceNotification>>, TError = unknown>(chatServiceSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceNotification>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceNotificationQueryKey(chatServiceSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceNotification>>> = ({ signal }) => fetchServiceNotification(chatServiceSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceNotification>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceNotificationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceNotification>>>
export type FetchServiceNotificationQueryError = unknown


/**
 * @summary Fetch push notification service settings
 */

export function useFetchServiceNotification<TData = Awaited<ReturnType<typeof fetchServiceNotification>>, TError = unknown>(
 chatServiceSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceNotification>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceNotificationQueryOptions(chatServiceSid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
 * @summary Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
 */
export type listServiceParticipantConversationResponse200 = {
  data: ListServiceParticipantConversation200
  status: 200
}
    
export type listServiceParticipantConversationResponseSuccess = (listServiceParticipantConversationResponse200) & {
  headers: Headers;
};
;

export type listServiceParticipantConversationResponse = (listServiceParticipantConversationResponseSuccess)

export const getListServiceParticipantConversationUrl = (chatServiceSid: string,
    params?: ListServiceParticipantConversationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/ParticipantConversations?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/ParticipantConversations`
}

export const listServiceParticipantConversation = async (chatServiceSid: string,
    params?: ListServiceParticipantConversationParams, options?: RequestInit): Promise<listServiceParticipantConversationResponse> => {
  
  const res = await fetch(getListServiceParticipantConversationUrl(chatServiceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceParticipantConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceParticipantConversationResponse
}





export const getListServiceParticipantConversationQueryKey = (chatServiceSid?: string,
    params?: ListServiceParticipantConversationParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/ParticipantConversations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceParticipantConversationQueryOptions = <TData = Awaited<ReturnType<typeof listServiceParticipantConversation>>, TError = unknown>(chatServiceSid: string,
    params?: ListServiceParticipantConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceParticipantConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceParticipantConversationQueryKey(chatServiceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceParticipantConversation>>> = ({ signal }) => listServiceParticipantConversation(chatServiceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceParticipantConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceParticipantConversationQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceParticipantConversation>>>
export type ListServiceParticipantConversationQueryError = unknown


/**
 * @summary Retrieve a list of all Conversations that this Participant belongs to by identity or by address. Only one parameter should be specified.
 */

export function useListServiceParticipantConversation<TData = Awaited<ReturnType<typeof listServiceParticipantConversation>>, TError = unknown>(
 chatServiceSid: string,
    params?: ListServiceParticipantConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceParticipantConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceParticipantConversationQueryOptions(chatServiceSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Create a new user role in your service
 * @summary Create a new user role in your service
 */
export type createServiceRoleResponse201 = {
  data: ConversationsV1ServiceServiceRole
  status: 201
}
    
export type createServiceRoleResponseSuccess = (createServiceRoleResponse201) & {
  headers: Headers;
};
;

export type createServiceRoleResponse = (createServiceRoleResponseSuccess)

export const getCreateServiceRoleUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Roles`
}

export const createServiceRole = async (chatServiceSid: string,
    createServiceRoleBody: CreateServiceRoleBody, options?: RequestInit): Promise<createServiceRoleResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`FriendlyName`, createServiceRoleBody.FriendlyName)
formUrlEncoded.append(`Type`, createServiceRoleBody.Type)
createServiceRoleBody.Permission.forEach(value => formUrlEncoded.append(`Permission`, value));

  const res = await fetch(getCreateServiceRoleUrl(chatServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceRoleResponse
}




export const getCreateServiceRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceRole>>, TError,{chatServiceSid: string;data: CreateServiceRoleBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceRole>>, TError,{chatServiceSid: string;data: CreateServiceRoleBody}, TContext> => {

const mutationKey = ['createServiceRole'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceRole>>, {chatServiceSid: string;data: CreateServiceRoleBody}> = (props) => {
          const {chatServiceSid,data} = props ?? {};

          return  createServiceRole(chatServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceRoleMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceRole>>>
    export type CreateServiceRoleMutationBody = CreateServiceRoleBody
    export type CreateServiceRoleMutationError = unknown

    /**
 * @summary Create a new user role in your service
 */
export const useCreateServiceRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceRole>>, TError,{chatServiceSid: string;data: CreateServiceRoleBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createServiceRole>>,
        TError,
        {chatServiceSid: string;data: CreateServiceRoleBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all user roles in your service
 * @summary Retrieve a list of all user roles in your service
 */
export type listServiceRoleResponse200 = {
  data: ListServiceRole200
  status: 200
}
    
export type listServiceRoleResponseSuccess = (listServiceRoleResponse200) & {
  headers: Headers;
};
;

export type listServiceRoleResponse = (listServiceRoleResponseSuccess)

export const getListServiceRoleUrl = (chatServiceSid: string,
    params?: ListServiceRoleParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Roles?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Roles`
}

export const listServiceRole = async (chatServiceSid: string,
    params?: ListServiceRoleParams, options?: RequestInit): Promise<listServiceRoleResponse> => {
  
  const res = await fetch(getListServiceRoleUrl(chatServiceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceRoleResponse
}





export const getListServiceRoleQueryKey = (chatServiceSid?: string,
    params?: ListServiceRoleParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Roles`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceRoleQueryOptions = <TData = Awaited<ReturnType<typeof listServiceRole>>, TError = unknown>(chatServiceSid: string,
    params?: ListServiceRoleParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceRole>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceRoleQueryKey(chatServiceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceRole>>> = ({ signal }) => listServiceRole(chatServiceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceRole>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceRoleQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceRole>>>
export type ListServiceRoleQueryError = unknown


/**
 * @summary Retrieve a list of all user roles in your service
 */

export function useListServiceRole<TData = Awaited<ReturnType<typeof listServiceRole>>, TError = unknown>(
 chatServiceSid: string,
    params?: ListServiceRoleParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceRole>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceRoleQueryOptions(chatServiceSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing user role in your service
 * @summary Update an existing user role in your service
 */
export type updateServiceRoleResponse200 = {
  data: ConversationsV1ServiceServiceRole
  status: 200
}
    
export type updateServiceRoleResponseSuccess = (updateServiceRoleResponse200) & {
  headers: Headers;
};
;

export type updateServiceRoleResponse = (updateServiceRoleResponseSuccess)

export const getUpdateServiceRoleUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Roles/${sid}`
}

export const updateServiceRole = async (chatServiceSid: string,
    sid: string,
    updateServiceRoleBody: UpdateServiceRoleBody, options?: RequestInit): Promise<updateServiceRoleResponse> => {
    const formUrlEncoded = new URLSearchParams();
updateServiceRoleBody.Permission.forEach(value => formUrlEncoded.append(`Permission`, value));

  const res = await fetch(getUpdateServiceRoleUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceRoleResponse
}




export const getUpdateServiceRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceRole>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceRoleBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceRole>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceRoleBody}, TContext> => {

const mutationKey = ['updateServiceRole'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceRole>>, {chatServiceSid: string;sid: string;data: UpdateServiceRoleBody}> = (props) => {
          const {chatServiceSid,sid,data} = props ?? {};

          return  updateServiceRole(chatServiceSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceRoleMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceRole>>>
    export type UpdateServiceRoleMutationBody = UpdateServiceRoleBody
    export type UpdateServiceRoleMutationError = unknown

    /**
 * @summary Update an existing user role in your service
 */
export const useUpdateServiceRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceRole>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceRoleBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceRole>>,
        TError,
        {chatServiceSid: string;sid: string;data: UpdateServiceRoleBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a user role from your service
 * @summary Remove a user role from your service
 */
export type deleteServiceRoleResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceRoleResponseSuccess = (deleteServiceRoleResponse204) & {
  headers: Headers;
};
;

export type deleteServiceRoleResponse = (deleteServiceRoleResponseSuccess)

export const getDeleteServiceRoleUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Roles/${sid}`
}

export const deleteServiceRole = async (chatServiceSid: string,
    sid: string, options?: RequestInit): Promise<deleteServiceRoleResponse> => {
  
  const res = await fetch(getDeleteServiceRoleUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceRoleResponse
}




export const getDeleteServiceRoleMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceRole>>, TError,{chatServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceRole>>, TError,{chatServiceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteServiceRole'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceRole>>, {chatServiceSid: string;sid: string}> = (props) => {
          const {chatServiceSid,sid} = props ?? {};

          return  deleteServiceRole(chatServiceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceRoleMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceRole>>>
    
    export type DeleteServiceRoleMutationError = unknown

    /**
 * @summary Remove a user role from your service
 */
export const useDeleteServiceRole = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceRole>>, TError,{chatServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceRole>>,
        TError,
        {chatServiceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceRoleMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a user role from your service
 * @summary Fetch a user role from your service
 */
export type fetchServiceRoleResponse200 = {
  data: ConversationsV1ServiceServiceRole
  status: 200
}
    
export type fetchServiceRoleResponseSuccess = (fetchServiceRoleResponse200) & {
  headers: Headers;
};
;

export type fetchServiceRoleResponse = (fetchServiceRoleResponseSuccess)

export const getFetchServiceRoleUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Roles/${sid}`
}

export const fetchServiceRole = async (chatServiceSid: string,
    sid: string, options?: RequestInit): Promise<fetchServiceRoleResponse> => {
  
  const res = await fetch(getFetchServiceRoleUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceRoleResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceRoleResponse
}





export const getFetchServiceRoleQueryKey = (chatServiceSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Roles/${sid}`
    ] as const;
    }

    
export const getFetchServiceRoleQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceRole>>, TError = unknown>(chatServiceSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceRole>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceRoleQueryKey(chatServiceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceRole>>> = ({ signal }) => fetchServiceRole(chatServiceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceRole>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceRoleQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceRole>>>
export type FetchServiceRoleQueryError = unknown


/**
 * @summary Fetch a user role from your service
 */

export function useFetchServiceRole<TData = Awaited<ReturnType<typeof fetchServiceRole>>, TError = unknown>(
 chatServiceSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceRole>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceRoleQueryOptions(chatServiceSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add a new conversation user to your service
 * @summary Add a new conversation user to your service
 */
export type createServiceUserResponse201 = {
  data: ConversationsV1ServiceServiceUser
  status: 201
}
    
export type createServiceUserResponseSuccess = (createServiceUserResponse201) & {
  headers: Headers;
};
;

export type createServiceUserResponse = (createServiceUserResponseSuccess)

export const getCreateServiceUserUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users`
}

export const createServiceUser = async (chatServiceSid: string,
    createServiceUserBody: CreateServiceUserBody, options?: RequestInit): Promise<createServiceUserResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Identity`, createServiceUserBody.Identity)
if(createServiceUserBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, createServiceUserBody.FriendlyName)
 }
if(createServiceUserBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createServiceUserBody.Attributes)
 }
if(createServiceUserBody.RoleSid !== undefined) {
 formUrlEncoded.append(`RoleSid`, createServiceUserBody.RoleSid)
 }

  const res = await fetch(getCreateServiceUserUrl(chatServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createServiceUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createServiceUserResponse
}




export const getCreateServiceUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceUser>>, TError,{chatServiceSid: string;data: CreateServiceUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createServiceUser>>, TError,{chatServiceSid: string;data: CreateServiceUserBody}, TContext> => {

const mutationKey = ['createServiceUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createServiceUser>>, {chatServiceSid: string;data: CreateServiceUserBody}> = (props) => {
          const {chatServiceSid,data} = props ?? {};

          return  createServiceUser(chatServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateServiceUserMutationResult = NonNullable<Awaited<ReturnType<typeof createServiceUser>>>
    export type CreateServiceUserMutationBody = CreateServiceUserBody
    export type CreateServiceUserMutationError = unknown

    /**
 * @summary Add a new conversation user to your service
 */
export const useCreateServiceUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createServiceUser>>, TError,{chatServiceSid: string;data: CreateServiceUserBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createServiceUser>>,
        TError,
        {chatServiceSid: string;data: CreateServiceUserBody},
        TContext
      > => {

      const mutationOptions = getCreateServiceUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all conversation users in your service
 * @summary Retrieve a list of all conversation users in your service
 */
export type listServiceUserResponse200 = {
  data: ListServiceUser200
  status: 200
}
    
export type listServiceUserResponseSuccess = (listServiceUserResponse200) & {
  headers: Headers;
};
;

export type listServiceUserResponse = (listServiceUserResponseSuccess)

export const getListServiceUserUrl = (chatServiceSid: string,
    params?: ListServiceUserParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users`
}

export const listServiceUser = async (chatServiceSid: string,
    params?: ListServiceUserParams, options?: RequestInit): Promise<listServiceUserResponse> => {
  
  const res = await fetch(getListServiceUserUrl(chatServiceSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceUserResponse
}





export const getListServiceUserQueryKey = (chatServiceSid?: string,
    params?: ListServiceUserParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceUserQueryOptions = <TData = Awaited<ReturnType<typeof listServiceUser>>, TError = unknown>(chatServiceSid: string,
    params?: ListServiceUserParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceUser>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceUserQueryKey(chatServiceSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceUser>>> = ({ signal }) => listServiceUser(chatServiceSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceUser>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceUserQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceUser>>>
export type ListServiceUserQueryError = unknown


/**
 * @summary Retrieve a list of all conversation users in your service
 */

export function useListServiceUser<TData = Awaited<ReturnType<typeof listServiceUser>>, TError = unknown>(
 chatServiceSid: string,
    params?: ListServiceUserParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceUser>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceUserQueryOptions(chatServiceSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing conversation user in your service
 * @summary Update an existing conversation user in your service
 */
export type updateServiceUserResponse200 = {
  data: ConversationsV1ServiceServiceUser
  status: 200
}
    
export type updateServiceUserResponseSuccess = (updateServiceUserResponse200) & {
  headers: Headers;
};
;

export type updateServiceUserResponse = (updateServiceUserResponseSuccess)

export const getUpdateServiceUserUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${sid}`
}

export const updateServiceUser = async (chatServiceSid: string,
    sid: string,
    updateServiceUserBody: UpdateServiceUserBody, options?: RequestInit): Promise<updateServiceUserResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceUserBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, updateServiceUserBody.FriendlyName)
 }
if(updateServiceUserBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, updateServiceUserBody.Attributes)
 }
if(updateServiceUserBody.RoleSid !== undefined) {
 formUrlEncoded.append(`RoleSid`, updateServiceUserBody.RoleSid)
 }

  const res = await fetch(getUpdateServiceUserUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceUserResponse
}




export const getUpdateServiceUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceUser>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceUser>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceUserBody}, TContext> => {

const mutationKey = ['updateServiceUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceUser>>, {chatServiceSid: string;sid: string;data: UpdateServiceUserBody}> = (props) => {
          const {chatServiceSid,sid,data} = props ?? {};

          return  updateServiceUser(chatServiceSid,sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceUser>>>
    export type UpdateServiceUserMutationBody = UpdateServiceUserBody
    export type UpdateServiceUserMutationError = unknown

    /**
 * @summary Update an existing conversation user in your service
 */
export const useUpdateServiceUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceUser>>, TError,{chatServiceSid: string;sid: string;data: UpdateServiceUserBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceUser>>,
        TError,
        {chatServiceSid: string;sid: string;data: UpdateServiceUserBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a conversation user from your service
 * @summary Remove a conversation user from your service
 */
export type deleteServiceUserResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceUserResponseSuccess = (deleteServiceUserResponse204) & {
  headers: Headers;
};
;

export type deleteServiceUserResponse = (deleteServiceUserResponseSuccess)

export const getDeleteServiceUserUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${sid}`
}

export const deleteServiceUser = async (chatServiceSid: string,
    sid: string, options?: RequestInit): Promise<deleteServiceUserResponse> => {
  
  const res = await fetch(getDeleteServiceUserUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceUserResponse
}




export const getDeleteServiceUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceUser>>, TError,{chatServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceUser>>, TError,{chatServiceSid: string;sid: string}, TContext> => {

const mutationKey = ['deleteServiceUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceUser>>, {chatServiceSid: string;sid: string}> = (props) => {
          const {chatServiceSid,sid} = props ?? {};

          return  deleteServiceUser(chatServiceSid,sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceUser>>>
    
    export type DeleteServiceUserMutationError = unknown

    /**
 * @summary Remove a conversation user from your service
 */
export const useDeleteServiceUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceUser>>, TError,{chatServiceSid: string;sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceUser>>,
        TError,
        {chatServiceSid: string;sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a conversation user from your service
 * @summary Fetch a conversation user from your service
 */
export type fetchServiceUserResponse200 = {
  data: ConversationsV1ServiceServiceUser
  status: 200
}
    
export type fetchServiceUserResponseSuccess = (fetchServiceUserResponse200) & {
  headers: Headers;
};
;

export type fetchServiceUserResponse = (fetchServiceUserResponseSuccess)

export const getFetchServiceUserUrl = (chatServiceSid: string,
    sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${sid}`
}

export const fetchServiceUser = async (chatServiceSid: string,
    sid: string, options?: RequestInit): Promise<fetchServiceUserResponse> => {
  
  const res = await fetch(getFetchServiceUserUrl(chatServiceSid,sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceUserResponse
}





export const getFetchServiceUserQueryKey = (chatServiceSid?: string,
    sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${sid}`
    ] as const;
    }

    
export const getFetchServiceUserQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceUser>>, TError = unknown>(chatServiceSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceUser>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceUserQueryKey(chatServiceSid,sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceUser>>> = ({ signal }) => fetchServiceUser(chatServiceSid,sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceUser>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceUserQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceUser>>>
export type FetchServiceUserQueryError = unknown


/**
 * @summary Fetch a conversation user from your service
 */

export function useFetchServiceUser<TData = Awaited<ReturnType<typeof fetchServiceUser>>, TError = unknown>(
 chatServiceSid: string,
    sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceUser>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceUserQueryOptions(chatServiceSid,sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a specific User Conversation.
 * @summary Update a specific User Conversation.
 */
export type updateServiceUserConversationResponse200 = {
  data: ConversationsV1ServiceServiceUserServiceUserConversation
  status: 200
}
    
export type updateServiceUserConversationResponseSuccess = (updateServiceUserConversationResponse200) & {
  headers: Headers;
};
;

export type updateServiceUserConversationResponse = (updateServiceUserConversationResponseSuccess)

export const getUpdateServiceUserConversationUrl = (chatServiceSid: string,
    userSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${userSid}/Conversations/${conversationSid}`
}

export const updateServiceUserConversation = async (chatServiceSid: string,
    userSid: string,
    conversationSid: string,
    updateServiceUserConversationBody: UpdateServiceUserConversationBody, options?: RequestInit): Promise<updateServiceUserConversationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceUserConversationBody.NotificationLevel !== undefined) {
 formUrlEncoded.append(`NotificationLevel`, updateServiceUserConversationBody.NotificationLevel)
 }
if(updateServiceUserConversationBody.LastReadTimestamp !== undefined) {
 formUrlEncoded.append(`LastReadTimestamp`, updateServiceUserConversationBody.LastReadTimestamp)
 }
if(updateServiceUserConversationBody.LastReadMessageIndex !== undefined && updateServiceUserConversationBody.LastReadMessageIndex !== null) {
 formUrlEncoded.append(`LastReadMessageIndex`, updateServiceUserConversationBody.LastReadMessageIndex.toString())
 }

  const res = await fetch(getUpdateServiceUserConversationUrl(chatServiceSid,userSid,conversationSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceUserConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceUserConversationResponse
}




export const getUpdateServiceUserConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceUserConversation>>, TError,{chatServiceSid: string;userSid: string;conversationSid: string;data: UpdateServiceUserConversationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceUserConversation>>, TError,{chatServiceSid: string;userSid: string;conversationSid: string;data: UpdateServiceUserConversationBody}, TContext> => {

const mutationKey = ['updateServiceUserConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceUserConversation>>, {chatServiceSid: string;userSid: string;conversationSid: string;data: UpdateServiceUserConversationBody}> = (props) => {
          const {chatServiceSid,userSid,conversationSid,data} = props ?? {};

          return  updateServiceUserConversation(chatServiceSid,userSid,conversationSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceUserConversationMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceUserConversation>>>
    export type UpdateServiceUserConversationMutationBody = UpdateServiceUserConversationBody
    export type UpdateServiceUserConversationMutationError = unknown

    /**
 * @summary Update a specific User Conversation.
 */
export const useUpdateServiceUserConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceUserConversation>>, TError,{chatServiceSid: string;userSid: string;conversationSid: string;data: UpdateServiceUserConversationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceUserConversation>>,
        TError,
        {chatServiceSid: string;userSid: string;conversationSid: string;data: UpdateServiceUserConversationBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceUserConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete a specific User Conversation.
 * @summary Delete a specific User Conversation.
 */
export type deleteServiceUserConversationResponse204 = {
  data: void
  status: 204
}
    
export type deleteServiceUserConversationResponseSuccess = (deleteServiceUserConversationResponse204) & {
  headers: Headers;
};
;

export type deleteServiceUserConversationResponse = (deleteServiceUserConversationResponseSuccess)

export const getDeleteServiceUserConversationUrl = (chatServiceSid: string,
    userSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${userSid}/Conversations/${conversationSid}`
}

export const deleteServiceUserConversation = async (chatServiceSid: string,
    userSid: string,
    conversationSid: string, options?: RequestInit): Promise<deleteServiceUserConversationResponse> => {
  
  const res = await fetch(getDeleteServiceUserConversationUrl(chatServiceSid,userSid,conversationSid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteServiceUserConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteServiceUserConversationResponse
}




export const getDeleteServiceUserConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceUserConversation>>, TError,{chatServiceSid: string;userSid: string;conversationSid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteServiceUserConversation>>, TError,{chatServiceSid: string;userSid: string;conversationSid: string}, TContext> => {

const mutationKey = ['deleteServiceUserConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteServiceUserConversation>>, {chatServiceSid: string;userSid: string;conversationSid: string}> = (props) => {
          const {chatServiceSid,userSid,conversationSid} = props ?? {};

          return  deleteServiceUserConversation(chatServiceSid,userSid,conversationSid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteServiceUserConversationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteServiceUserConversation>>>
    
    export type DeleteServiceUserConversationMutationError = unknown

    /**
 * @summary Delete a specific User Conversation.
 */
export const useDeleteServiceUserConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteServiceUserConversation>>, TError,{chatServiceSid: string;userSid: string;conversationSid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteServiceUserConversation>>,
        TError,
        {chatServiceSid: string;userSid: string;conversationSid: string},
        TContext
      > => {

      const mutationOptions = getDeleteServiceUserConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a specific User Conversation.
 * @summary Fetch a specific User Conversation.
 */
export type fetchServiceUserConversationResponse200 = {
  data: ConversationsV1ServiceServiceUserServiceUserConversation
  status: 200
}
    
export type fetchServiceUserConversationResponseSuccess = (fetchServiceUserConversationResponse200) & {
  headers: Headers;
};
;

export type fetchServiceUserConversationResponse = (fetchServiceUserConversationResponseSuccess)

export const getFetchServiceUserConversationUrl = (chatServiceSid: string,
    userSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${userSid}/Conversations/${conversationSid}`
}

export const fetchServiceUserConversation = async (chatServiceSid: string,
    userSid: string,
    conversationSid: string, options?: RequestInit): Promise<fetchServiceUserConversationResponse> => {
  
  const res = await fetch(getFetchServiceUserConversationUrl(chatServiceSid,userSid,conversationSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceUserConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceUserConversationResponse
}





export const getFetchServiceUserConversationQueryKey = (chatServiceSid?: string,
    userSid?: string,
    conversationSid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${userSid}/Conversations/${conversationSid}`
    ] as const;
    }

    
export const getFetchServiceUserConversationQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceUserConversation>>, TError = unknown>(chatServiceSid: string,
    userSid: string,
    conversationSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceUserConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceUserConversationQueryKey(chatServiceSid,userSid,conversationSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceUserConversation>>> = ({ signal }) => fetchServiceUserConversation(chatServiceSid,userSid,conversationSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && userSid && conversationSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceUserConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceUserConversationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceUserConversation>>>
export type FetchServiceUserConversationQueryError = unknown


/**
 * @summary Fetch a specific User Conversation.
 */

export function useFetchServiceUserConversation<TData = Awaited<ReturnType<typeof fetchServiceUserConversation>>, TError = unknown>(
 chatServiceSid: string,
    userSid: string,
    conversationSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceUserConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceUserConversationQueryOptions(chatServiceSid,userSid,conversationSid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all User Conversations for the User.
 * @summary Retrieve a list of all User Conversations for the User.
 */
export type listServiceUserConversationResponse200 = {
  data: ListServiceUserConversation200
  status: 200
}
    
export type listServiceUserConversationResponseSuccess = (listServiceUserConversationResponse200) & {
  headers: Headers;
};
;

export type listServiceUserConversationResponse = (listServiceUserConversationResponseSuccess)

export const getListServiceUserConversationUrl = (chatServiceSid: string,
    userSid: string,
    params?: ListServiceUserConversationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${userSid}/Conversations?${stringifiedParams}` : `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${userSid}/Conversations`
}

export const listServiceUserConversation = async (chatServiceSid: string,
    userSid: string,
    params?: ListServiceUserConversationParams, options?: RequestInit): Promise<listServiceUserConversationResponse> => {
  
  const res = await fetch(getListServiceUserConversationUrl(chatServiceSid,userSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listServiceUserConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listServiceUserConversationResponse
}





export const getListServiceUserConversationQueryKey = (chatServiceSid?: string,
    userSid?: string,
    params?: ListServiceUserConversationParams,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Users/${userSid}/Conversations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListServiceUserConversationQueryOptions = <TData = Awaited<ReturnType<typeof listServiceUserConversation>>, TError = unknown>(chatServiceSid: string,
    userSid: string,
    params?: ListServiceUserConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceUserConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListServiceUserConversationQueryKey(chatServiceSid,userSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listServiceUserConversation>>> = ({ signal }) => listServiceUserConversation(chatServiceSid,userSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid && userSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listServiceUserConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type ListServiceUserConversationQueryResult = NonNullable<Awaited<ReturnType<typeof listServiceUserConversation>>>
export type ListServiceUserConversationQueryError = unknown


/**
 * @summary Retrieve a list of all User Conversations for the User.
 */

export function useListServiceUserConversation<TData = Awaited<ReturnType<typeof listServiceUserConversation>>, TError = unknown>(
 chatServiceSid: string,
    userSid: string,
    params?: ListServiceUserConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listServiceUserConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListServiceUserConversationQueryOptions(chatServiceSid,userSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a specific Webhook.
 * @summary Update a specific Webhook.
 */
export type updateServiceWebhookConfigurationResponse200 = {
  data: ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration
  status: 200
}
    
export type updateServiceWebhookConfigurationResponseSuccess = (updateServiceWebhookConfigurationResponse200) & {
  headers: Headers;
};
;

export type updateServiceWebhookConfigurationResponse = (updateServiceWebhookConfigurationResponseSuccess)

export const getUpdateServiceWebhookConfigurationUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration/Webhooks`
}

export const updateServiceWebhookConfiguration = async (chatServiceSid: string,
    updateServiceWebhookConfigurationBody: UpdateServiceWebhookConfigurationBody, options?: RequestInit): Promise<updateServiceWebhookConfigurationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateServiceWebhookConfigurationBody.PreWebhookUrl !== undefined) {
 formUrlEncoded.append(`PreWebhookUrl`, updateServiceWebhookConfigurationBody.PreWebhookUrl)
 }
if(updateServiceWebhookConfigurationBody.PostWebhookUrl !== undefined) {
 formUrlEncoded.append(`PostWebhookUrl`, updateServiceWebhookConfigurationBody.PostWebhookUrl)
 }
if(updateServiceWebhookConfigurationBody.Filters !== undefined) {
 updateServiceWebhookConfigurationBody.Filters.forEach(value => formUrlEncoded.append(`Filters`, value));
 }
if(updateServiceWebhookConfigurationBody.Method !== undefined) {
 formUrlEncoded.append(`Method`, updateServiceWebhookConfigurationBody.Method)
 }

  const res = await fetch(getUpdateServiceWebhookConfigurationUrl(chatServiceSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateServiceWebhookConfigurationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateServiceWebhookConfigurationResponse
}




export const getUpdateServiceWebhookConfigurationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceWebhookConfiguration>>, TError,{chatServiceSid: string;data: UpdateServiceWebhookConfigurationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateServiceWebhookConfiguration>>, TError,{chatServiceSid: string;data: UpdateServiceWebhookConfigurationBody}, TContext> => {

const mutationKey = ['updateServiceWebhookConfiguration'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateServiceWebhookConfiguration>>, {chatServiceSid: string;data: UpdateServiceWebhookConfigurationBody}> = (props) => {
          const {chatServiceSid,data} = props ?? {};

          return  updateServiceWebhookConfiguration(chatServiceSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateServiceWebhookConfigurationMutationResult = NonNullable<Awaited<ReturnType<typeof updateServiceWebhookConfiguration>>>
    export type UpdateServiceWebhookConfigurationMutationBody = UpdateServiceWebhookConfigurationBody
    export type UpdateServiceWebhookConfigurationMutationError = unknown

    /**
 * @summary Update a specific Webhook.
 */
export const useUpdateServiceWebhookConfiguration = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateServiceWebhookConfiguration>>, TError,{chatServiceSid: string;data: UpdateServiceWebhookConfigurationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateServiceWebhookConfiguration>>,
        TError,
        {chatServiceSid: string;data: UpdateServiceWebhookConfigurationBody},
        TContext
      > => {

      const mutationOptions = getUpdateServiceWebhookConfigurationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a specific service webhook configuration.
 * @summary Fetch a specific service webhook configuration.
 */
export type fetchServiceWebhookConfigurationResponse200 = {
  data: ConversationsV1ServiceServiceConfigurationServiceWebhookConfiguration
  status: 200
}
    
export type fetchServiceWebhookConfigurationResponseSuccess = (fetchServiceWebhookConfigurationResponse200) & {
  headers: Headers;
};
;

export type fetchServiceWebhookConfigurationResponse = (fetchServiceWebhookConfigurationResponseSuccess)

export const getFetchServiceWebhookConfigurationUrl = (chatServiceSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration/Webhooks`
}

export const fetchServiceWebhookConfiguration = async (chatServiceSid: string, options?: RequestInit): Promise<fetchServiceWebhookConfigurationResponse> => {
  
  const res = await fetch(getFetchServiceWebhookConfigurationUrl(chatServiceSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchServiceWebhookConfigurationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchServiceWebhookConfigurationResponse
}





export const getFetchServiceWebhookConfigurationQueryKey = (chatServiceSid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Services/${chatServiceSid}/Configuration/Webhooks`
    ] as const;
    }

    
export const getFetchServiceWebhookConfigurationQueryOptions = <TData = Awaited<ReturnType<typeof fetchServiceWebhookConfiguration>>, TError = unknown>(chatServiceSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceWebhookConfiguration>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchServiceWebhookConfigurationQueryKey(chatServiceSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchServiceWebhookConfiguration>>> = ({ signal }) => fetchServiceWebhookConfiguration(chatServiceSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(chatServiceSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchServiceWebhookConfiguration>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchServiceWebhookConfigurationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchServiceWebhookConfiguration>>>
export type FetchServiceWebhookConfigurationQueryError = unknown


/**
 * @summary Fetch a specific service webhook configuration.
 */

export function useFetchServiceWebhookConfiguration<TData = Awaited<ReturnType<typeof fetchServiceWebhookConfiguration>>, TError = unknown>(
 chatServiceSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchServiceWebhookConfiguration>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchServiceWebhookConfigurationQueryOptions(chatServiceSid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Add a new conversation user to your account's default service
 * @summary Add a new conversation user to your account's default service
 */
export type createUserResponse201 = {
  data: ConversationsV1User
  status: 201
}
    
export type createUserResponseSuccess = (createUserResponse201) & {
  headers: Headers;
};
;

export type createUserResponse = (createUserResponseSuccess)

export const getCreateUserUrl = () => {


  

  return `https://conversations.twilio.com/v1/Users`
}

export const createUser = async (createUserBody: CreateUserBody, options?: RequestInit): Promise<createUserResponse> => {
    const formUrlEncoded = new URLSearchParams();
formUrlEncoded.append(`Identity`, createUserBody.Identity)
if(createUserBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, createUserBody.FriendlyName)
 }
if(createUserBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, createUserBody.Attributes)
 }
if(createUserBody.RoleSid !== undefined) {
 formUrlEncoded.append(`RoleSid`, createUserBody.RoleSid)
 }

  const res = await fetch(getCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: createUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as createUserResponse
}




export const getCreateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext> => {

const mutationKey = ['createUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof createUser>>, {data: CreateUserBody}> = (props) => {
          const {data} = props ?? {};

          return  createUser(data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type CreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof createUser>>>
    export type CreateUserMutationBody = CreateUserBody
    export type CreateUserMutationError = unknown

    /**
 * @summary Add a new conversation user to your account's default service
 */
export const useCreateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof createUser>>, TError,{data: CreateUserBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof createUser>>,
        TError,
        {data: CreateUserBody},
        TContext
      > => {

      const mutationOptions = getCreateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Retrieve a list of all conversation users in your account's default service
 * @summary Retrieve a list of all conversation users in your account's default service
 */
export type listUserResponse200 = {
  data: ListUser200
  status: 200
}
    
export type listUserResponseSuccess = (listUserResponse200) & {
  headers: Headers;
};
;

export type listUserResponse = (listUserResponseSuccess)

export const getListUserUrl = (params?: ListUserParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Users?${stringifiedParams}` : `https://conversations.twilio.com/v1/Users`
}

export const listUser = async (params?: ListUserParams, options?: RequestInit): Promise<listUserResponse> => {
  
  const res = await fetch(getListUserUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUserResponse
}





export const getListUserQueryKey = (params?: ListUserParams,) => {
    return [
    `https://conversations.twilio.com/v1/Users`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListUserQueryOptions = <TData = Awaited<ReturnType<typeof listUser>>, TError = unknown>(params?: ListUserParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listUser>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUserQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUser>>> = ({ signal }) => listUser(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUser>>, TError, TData> & { queryKey: QueryKey }
}

export type ListUserQueryResult = NonNullable<Awaited<ReturnType<typeof listUser>>>
export type ListUserQueryError = unknown


/**
 * @summary Retrieve a list of all conversation users in your account's default service
 */

export function useListUser<TData = Awaited<ReturnType<typeof listUser>>, TError = unknown>(
 params?: ListUserParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listUser>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListUserQueryOptions(params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update an existing conversation user in your account's default service
 * @summary Update an existing conversation user in your account's default service
 */
export type updateUserResponse200 = {
  data: ConversationsV1User
  status: 200
}
    
export type updateUserResponseSuccess = (updateUserResponse200) & {
  headers: Headers;
};
;

export type updateUserResponse = (updateUserResponseSuccess)

export const getUpdateUserUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Users/${sid}`
}

export const updateUser = async (sid: string,
    updateUserBody: UpdateUserBody, options?: RequestInit): Promise<updateUserResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateUserBody.FriendlyName !== undefined) {
 formUrlEncoded.append(`FriendlyName`, updateUserBody.FriendlyName)
 }
if(updateUserBody.Attributes !== undefined) {
 formUrlEncoded.append(`Attributes`, updateUserBody.Attributes)
 }
if(updateUserBody.RoleSid !== undefined) {
 formUrlEncoded.append(`RoleSid`, updateUserBody.RoleSid)
 }

  const res = await fetch(getUpdateUserUrl(sid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateUserResponse
}




export const getUpdateUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{sid: string;data: UpdateUserBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{sid: string;data: UpdateUserBody}, TContext> => {

const mutationKey = ['updateUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUser>>, {sid: string;data: UpdateUserBody}> = (props) => {
          const {sid,data} = props ?? {};

          return  updateUser(sid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof updateUser>>>
    export type UpdateUserMutationBody = UpdateUserBody
    export type UpdateUserMutationError = unknown

    /**
 * @summary Update an existing conversation user in your account's default service
 */
export const useUpdateUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUser>>, TError,{sid: string;data: UpdateUserBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateUser>>,
        TError,
        {sid: string;data: UpdateUserBody},
        TContext
      > => {

      const mutationOptions = getUpdateUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Remove a conversation user from your account's default service
 * @summary Remove a conversation user from your account's default service
 */
export type deleteUserResponse204 = {
  data: void
  status: 204
}
    
export type deleteUserResponseSuccess = (deleteUserResponse204) & {
  headers: Headers;
};
;

export type deleteUserResponse = (deleteUserResponseSuccess)

export const getDeleteUserUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Users/${sid}`
}

export const deleteUser = async (sid: string, options?: RequestInit): Promise<deleteUserResponse> => {
  
  const res = await fetch(getDeleteUserUrl(sid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteUserResponse
}




export const getDeleteUserMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{sid: string}, TContext> => {

const mutationKey = ['deleteUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUser>>, {sid: string}> = (props) => {
          const {sid} = props ?? {};

          return  deleteUser(sid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUser>>>
    
    export type DeleteUserMutationError = unknown

    /**
 * @summary Remove a conversation user from your account's default service
 */
export const useDeleteUser = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUser>>, TError,{sid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteUser>>,
        TError,
        {sid: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a conversation user from your account's default service
 * @summary Fetch a conversation user from your account's default service
 */
export type fetchUserResponse200 = {
  data: ConversationsV1User
  status: 200
}
    
export type fetchUserResponseSuccess = (fetchUserResponse200) & {
  headers: Headers;
};
;

export type fetchUserResponse = (fetchUserResponseSuccess)

export const getFetchUserUrl = (sid: string,) => {


  

  return `https://conversations.twilio.com/v1/Users/${sid}`
}

export const fetchUser = async (sid: string, options?: RequestInit): Promise<fetchUserResponse> => {
  
  const res = await fetch(getFetchUserUrl(sid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchUserResponse
}





export const getFetchUserQueryKey = (sid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Users/${sid}`
    ] as const;
    }

    
export const getFetchUserQueryOptions = <TData = Awaited<ReturnType<typeof fetchUser>>, TError = unknown>(sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchUser>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchUserQueryKey(sid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchUser>>> = ({ signal }) => fetchUser(sid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(sid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchUser>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchUserQueryResult = NonNullable<Awaited<ReturnType<typeof fetchUser>>>
export type FetchUserQueryError = unknown


/**
 * @summary Fetch a conversation user from your account's default service
 */

export function useFetchUser<TData = Awaited<ReturnType<typeof fetchUser>>, TError = unknown>(
 sid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchUser>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchUserQueryOptions(sid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Update a specific User Conversation.
 * @summary Update a specific User Conversation.
 */
export type updateUserConversationResponse200 = {
  data: ConversationsV1UserUserConversation
  status: 200
}
    
export type updateUserConversationResponseSuccess = (updateUserConversationResponse200) & {
  headers: Headers;
};
;

export type updateUserConversationResponse = (updateUserConversationResponseSuccess)

export const getUpdateUserConversationUrl = (userSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Users/${userSid}/Conversations/${conversationSid}`
}

export const updateUserConversation = async (userSid: string,
    conversationSid: string,
    updateUserConversationBody: UpdateUserConversationBody, options?: RequestInit): Promise<updateUserConversationResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(updateUserConversationBody.NotificationLevel !== undefined) {
 formUrlEncoded.append(`NotificationLevel`, updateUserConversationBody.NotificationLevel)
 }
if(updateUserConversationBody.LastReadTimestamp !== undefined) {
 formUrlEncoded.append(`LastReadTimestamp`, updateUserConversationBody.LastReadTimestamp)
 }
if(updateUserConversationBody.LastReadMessageIndex !== undefined && updateUserConversationBody.LastReadMessageIndex !== null) {
 formUrlEncoded.append(`LastReadMessageIndex`, updateUserConversationBody.LastReadMessageIndex.toString())
 }

  const res = await fetch(getUpdateUserConversationUrl(userSid,conversationSid),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: updateUserConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as updateUserConversationResponse
}




export const getUpdateUserConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserConversation>>, TError,{userSid: string;conversationSid: string;data: UpdateUserConversationBody}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof updateUserConversation>>, TError,{userSid: string;conversationSid: string;data: UpdateUserConversationBody}, TContext> => {

const mutationKey = ['updateUserConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof updateUserConversation>>, {userSid: string;conversationSid: string;data: UpdateUserConversationBody}> = (props) => {
          const {userSid,conversationSid,data} = props ?? {};

          return  updateUserConversation(userSid,conversationSid,data,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type UpdateUserConversationMutationResult = NonNullable<Awaited<ReturnType<typeof updateUserConversation>>>
    export type UpdateUserConversationMutationBody = UpdateUserConversationBody
    export type UpdateUserConversationMutationError = unknown

    /**
 * @summary Update a specific User Conversation.
 */
export const useUpdateUserConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof updateUserConversation>>, TError,{userSid: string;conversationSid: string;data: UpdateUserConversationBody}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof updateUserConversation>>,
        TError,
        {userSid: string;conversationSid: string;data: UpdateUserConversationBody},
        TContext
      > => {

      const mutationOptions = getUpdateUserConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Delete a specific User Conversation.
 * @summary Delete a specific User Conversation.
 */
export type deleteUserConversationResponse204 = {
  data: void
  status: 204
}
    
export type deleteUserConversationResponseSuccess = (deleteUserConversationResponse204) & {
  headers: Headers;
};
;

export type deleteUserConversationResponse = (deleteUserConversationResponseSuccess)

export const getDeleteUserConversationUrl = (userSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Users/${userSid}/Conversations/${conversationSid}`
}

export const deleteUserConversation = async (userSid: string,
    conversationSid: string, options?: RequestInit): Promise<deleteUserConversationResponse> => {
  
  const res = await fetch(getDeleteUserConversationUrl(userSid,conversationSid),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: deleteUserConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as deleteUserConversationResponse
}




export const getDeleteUserConversationMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserConversation>>, TError,{userSid: string;conversationSid: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof deleteUserConversation>>, TError,{userSid: string;conversationSid: string}, TContext> => {

const mutationKey = ['deleteUserConversation'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof deleteUserConversation>>, {userSid: string;conversationSid: string}> = (props) => {
          const {userSid,conversationSid} = props ?? {};

          return  deleteUserConversation(userSid,conversationSid,fetchOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type DeleteUserConversationMutationResult = NonNullable<Awaited<ReturnType<typeof deleteUserConversation>>>
    
    export type DeleteUserConversationMutationError = unknown

    /**
 * @summary Delete a specific User Conversation.
 */
export const useDeleteUserConversation = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof deleteUserConversation>>, TError,{userSid: string;conversationSid: string}, TContext>, fetch?: RequestInit}
 ): UseMutationResult<
        Awaited<ReturnType<typeof deleteUserConversation>>,
        TError,
        {userSid: string;conversationSid: string},
        TContext
      > => {

      const mutationOptions = getDeleteUserConversationMutationOptions(options);

      return useMutation(mutationOptions);
    }
    
/**
 * Fetch a specific User Conversation.
 * @summary Fetch a specific User Conversation.
 */
export type fetchUserConversationResponse200 = {
  data: ConversationsV1UserUserConversation
  status: 200
}
    
export type fetchUserConversationResponseSuccess = (fetchUserConversationResponse200) & {
  headers: Headers;
};
;

export type fetchUserConversationResponse = (fetchUserConversationResponseSuccess)

export const getFetchUserConversationUrl = (userSid: string,
    conversationSid: string,) => {


  

  return `https://conversations.twilio.com/v1/Users/${userSid}/Conversations/${conversationSid}`
}

export const fetchUserConversation = async (userSid: string,
    conversationSid: string, options?: RequestInit): Promise<fetchUserConversationResponse> => {
  
  const res = await fetch(getFetchUserConversationUrl(userSid,conversationSid),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: fetchUserConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as fetchUserConversationResponse
}





export const getFetchUserConversationQueryKey = (userSid?: string,
    conversationSid?: string,) => {
    return [
    `https://conversations.twilio.com/v1/Users/${userSid}/Conversations/${conversationSid}`
    ] as const;
    }

    
export const getFetchUserConversationQueryOptions = <TData = Awaited<ReturnType<typeof fetchUserConversation>>, TError = unknown>(userSid: string,
    conversationSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchUserConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getFetchUserConversationQueryKey(userSid,conversationSid);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof fetchUserConversation>>> = ({ signal }) => fetchUserConversation(userSid,conversationSid, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userSid && conversationSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof fetchUserConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type FetchUserConversationQueryResult = NonNullable<Awaited<ReturnType<typeof fetchUserConversation>>>
export type FetchUserConversationQueryError = unknown


/**
 * @summary Fetch a specific User Conversation.
 */

export function useFetchUserConversation<TData = Awaited<ReturnType<typeof fetchUserConversation>>, TError = unknown>(
 userSid: string,
    conversationSid: string, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof fetchUserConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getFetchUserConversationQueryOptions(userSid,conversationSid,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}





/**
 * Retrieve a list of all User Conversations for the User.
 * @summary Retrieve a list of all User Conversations for the User.
 */
export type listUserConversationResponse200 = {
  data: ListUserConversation200
  status: 200
}
    
export type listUserConversationResponseSuccess = (listUserConversationResponse200) & {
  headers: Headers;
};
;

export type listUserConversationResponse = (listUserConversationResponseSuccess)

export const getListUserConversationUrl = (userSid: string,
    params?: ListUserConversationParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `https://conversations.twilio.com/v1/Users/${userSid}/Conversations?${stringifiedParams}` : `https://conversations.twilio.com/v1/Users/${userSid}/Conversations`
}

export const listUserConversation = async (userSid: string,
    params?: ListUserConversationParams, options?: RequestInit): Promise<listUserConversationResponse> => {
  
  const res = await fetch(getListUserConversationUrl(userSid,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: listUserConversationResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as listUserConversationResponse
}





export const getListUserConversationQueryKey = (userSid?: string,
    params?: ListUserConversationParams,) => {
    return [
    `https://conversations.twilio.com/v1/Users/${userSid}/Conversations`, ...(params ? [params]: [])
    ] as const;
    }

    
export const getListUserConversationQueryOptions = <TData = Awaited<ReturnType<typeof listUserConversation>>, TError = unknown>(userSid: string,
    params?: ListUserConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listUserConversation>>, TError, TData>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getListUserConversationQueryKey(userSid,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof listUserConversation>>> = ({ signal }) => listUserConversation(userSid,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userSid), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof listUserConversation>>, TError, TData> & { queryKey: QueryKey }
}

export type ListUserConversationQueryResult = NonNullable<Awaited<ReturnType<typeof listUserConversation>>>
export type ListUserConversationQueryError = unknown


/**
 * @summary Retrieve a list of all User Conversations for the User.
 */

export function useListUserConversation<TData = Awaited<ReturnType<typeof listUserConversation>>, TError = unknown>(
 userSid: string,
    params?: ListUserConversationParams, options?: { query?:UseQueryOptions<Awaited<ReturnType<typeof listUserConversation>>, TError, TData>, fetch?: RequestInit}
  
 ):  UseQueryResult<TData, TError> & { queryKey: QueryKey } {

  const queryOptions = getListUserConversationQueryOptions(userSid,params,options)

  const query = useQuery(queryOptions) as  UseQueryResult<TData, TError> & { queryKey: QueryKey };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
